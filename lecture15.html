<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml" lang="en" xml:lang="en"><head>

<meta charset="utf-8">
<meta name="generator" content="quarto-1.3.340">

<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes">


<title>Kittenlab lecture notes - Lecture 15: Cospans</title>
<style>
code{white-space: pre-wrap;}
span.smallcaps{font-variant: small-caps;}
div.columns{display: flex; gap: min(4vw, 1.5em);}
div.column{flex: auto; overflow-x: auto;}
div.hanging-indent{margin-left: 1.5em; text-indent: -1.5em;}
ul.task-list{list-style: none;}
ul.task-list li input[type="checkbox"] {
  width: 0.8em;
  margin: 0 0.8em 0.2em -1em; /* quarto-specific, see https://github.com/quarto-dev/quarto-cli/issues/4556 */ 
  vertical-align: middle;
}
</style>


<script src="site_libs/quarto-nav/quarto-nav.js"></script>
<script src="site_libs/quarto-nav/headroom.min.js"></script>
<script src="site_libs/clipboard/clipboard.min.js"></script>
<script src="site_libs/quarto-search/autocomplete.umd.js"></script>
<script src="site_libs/quarto-search/fuse.min.js"></script>
<script src="site_libs/quarto-search/quarto-search.js"></script>
<meta name="quarto:offset" content="./">
<link href="./references.html" rel="next">
<link href="./lecture14.html" rel="prev">
<script src="site_libs/quarto-html/quarto.js"></script>
<script src="site_libs/quarto-html/popper.min.js"></script>
<script src="site_libs/quarto-html/tippy.umd.min.js"></script>
<script src="site_libs/quarto-html/anchor.min.js"></script>
<link href="site_libs/quarto-html/tippy.css" rel="stylesheet">
<link href="site_libs/quarto-html/quarto-syntax-highlighting.css" rel="stylesheet" id="quarto-text-highlighting-styles">
<script src="site_libs/bootstrap/bootstrap.min.js"></script>
<link href="site_libs/bootstrap/bootstrap-icons.css" rel="stylesheet">
<link href="site_libs/bootstrap/bootstrap.min.css" rel="stylesheet" id="quarto-bootstrap" data-mode="light">
<script id="quarto-search-options" type="application/json">{
  "location": "sidebar",
  "copy-button": false,
  "collapse-after": 3,
  "panel-placement": "start",
  "type": "textbox",
  "limit": 20,
  "language": {
    "search-no-results-text": "No results",
    "search-matching-documents-text": "matching documents",
    "search-copy-link-title": "Copy link to search",
    "search-hide-matches-text": "Hide additional matches",
    "search-more-match-text": "more match in this document",
    "search-more-matches-text": "more matches in this document",
    "search-clear-button-title": "Clear",
    "search-detached-cancel-button-title": "Cancel",
    "search-submit-button-title": "Submit"
  }
}</script>

  <script>window.backupDefine = window.define; window.define = undefined;</script><script src="https://cdn.jsdelivr.net/npm/katex@0.15.1/dist/katex.min.js"></script>
  <script>document.addEventListener("DOMContentLoaded", function () {
 var mathElements = document.getElementsByClassName("math");
 var macros = [];
 for (var i = 0; i < mathElements.length; i++) {
  var texText = mathElements[i].firstChild;
  if (mathElements[i].tagName == "SPAN") {
   katex.render(texText.data, mathElements[i], {
    displayMode: mathElements[i].classList.contains('display'),
    throwOnError: false,
    macros: macros,
    fleqn: false
   });
}}});
  </script>
  <script>window.define = window.backupDefine; window.backupDefine = undefined;</script><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.15.1/dist/katex.min.css">

<link rel="stylesheet" href="main.css">
</head>

<body class="nav-sidebar floating">


<div id="quarto-search-results"></div>
  <header id="quarto-header" class="headroom fixed-top">
  <nav class="quarto-secondary-nav">
    <div class="container-fluid d-flex">
      <button type="button" class="quarto-btn-toggle btn" data-bs-toggle="collapse" data-bs-target="#quarto-sidebar,#quarto-sidebar-glass" aria-controls="quarto-sidebar" aria-expanded="false" aria-label="Toggle sidebar navigation" onclick="if (window.quartoToggleHeadroom) { window.quartoToggleHeadroom(); }">
        <i class="bi bi-layout-text-sidebar-reverse"></i>
      </button>
      <nav class="quarto-page-breadcrumbs" aria-label="breadcrumb"><ol class="breadcrumb"><li class="breadcrumb-item"><a href="./lecture15.html">Lecture 15: Cospans</a></li></ol></nav>
      <a class="flex-grow-1" role="button" data-bs-toggle="collapse" data-bs-target="#quarto-sidebar,#quarto-sidebar-glass" aria-controls="quarto-sidebar" aria-expanded="false" aria-label="Toggle sidebar navigation" onclick="if (window.quartoToggleHeadroom) { window.quartoToggleHeadroom(); }">      
      </a>
      <button type="button" class="btn quarto-search-button" aria-label="Search" onclick="window.quartoOpenSearch();">
        <i class="bi bi-search"></i>
      </button>
    </div>
  </nav>
</header>
<!-- content -->
<div id="quarto-content" class="quarto-container page-columns page-rows-contents page-layout-article">
<!-- sidebar -->
  <nav id="quarto-sidebar" class="sidebar collapse collapse-horizontal sidebar-navigation floating overflow-auto">
    <div class="pt-lg-2 mt-2 text-left sidebar-header">
    <div class="sidebar-title mb-0 py-0">
      <a href="./">Kittenlab lecture notes</a> 
    </div>
      </div>
        <div class="mt-2 flex-shrink-0 align-items-center">
        <div class="sidebar-search">
        <div id="quarto-search" class="" title="Search"></div>
        </div>
        </div>
    <div class="sidebar-menu-container"> 
    <ul class="list-unstyled mt-1">
        <li class="sidebar-item">
  <div class="sidebar-item-container"> 
  <a href="./index.html" class="sidebar-item-text sidebar-link">
 <span class="menu-text">Introduction</span></a>
  </div>
</li>
        <li class="sidebar-item">
  <div class="sidebar-item-container"> 
  <a href="./lecture1.html" class="sidebar-item-text sidebar-link">
 <span class="menu-text">Lecture 1: Formal Math</span></a>
  </div>
</li>
        <li class="sidebar-item">
  <div class="sidebar-item-container"> 
  <a href="./lecture2.html" class="sidebar-item-text sidebar-link">
 <span class="menu-text">Lecture 2: The Category Theory of Finite Sets</span></a>
  </div>
</li>
        <li class="sidebar-item">
  <div class="sidebar-item-container"> 
  <a href="./lecture3.html" class="sidebar-item-text sidebar-link">
 <span class="menu-text">Lecture 3: Category Theory</span></a>
  </div>
</li>
        <li class="sidebar-item">
  <div class="sidebar-item-container"> 
  <a href="./lecture4.html" class="sidebar-item-text sidebar-link">
 <span class="menu-text">Lecture 4: Functors</span></a>
  </div>
</li>
        <li class="sidebar-item">
  <div class="sidebar-item-container"> 
  <a href="./lecture5.html" class="sidebar-item-text sidebar-link">
 <span class="menu-text">Lecture 5: A Variety of Categories and Functors</span></a>
  </div>
</li>
        <li class="sidebar-item">
  <div class="sidebar-item-container"> 
  <a href="./lecture6.html" class="sidebar-item-text sidebar-link">
 <span class="menu-text">Lecture 6: Path categories and functors as data structures</span></a>
  </div>
</li>
        <li class="sidebar-item">
  <div class="sidebar-item-container"> 
  <a href="./lecture7.html" class="sidebar-item-text sidebar-link">
 <span class="menu-text">Lecture 7: Natural Transformations</span></a>
  </div>
</li>
        <li class="sidebar-item">
  <div class="sidebar-item-container"> 
  <a href="./lecture8.html" class="sidebar-item-text sidebar-link">
 <span class="menu-text">Lecture 8: Universal Mapping Properties</span></a>
  </div>
</li>
        <li class="sidebar-item">
  <div class="sidebar-item-container"> 
  <a href="./lecture9.html" class="sidebar-item-text sidebar-link">
 <span class="menu-text">Lecture 9: Colimits</span></a>
  </div>
</li>
        <li class="sidebar-item">
  <div class="sidebar-item-container"> 
  <a href="./lecture10.html" class="sidebar-item-text sidebar-link">
 <span class="menu-text">Lecture 10: Representables revisited</span></a>
  </div>
</li>
        <li class="sidebar-item">
  <div class="sidebar-item-container"> 
  <a href="./lecture11.html" class="sidebar-item-text sidebar-link">
 <span class="menu-text">Lecture 11: Adding and squishing</span></a>
  </div>
</li>
        <li class="sidebar-item">
  <div class="sidebar-item-container"> 
  <a href="./lecture12.html" class="sidebar-item-text sidebar-link">
 <span class="menu-text">Lecture 12: That’s Yoneda, Babe</span></a>
  </div>
</li>
        <li class="sidebar-item">
  <div class="sidebar-item-container"> 
  <a href="./lecture13.html" class="sidebar-item-text sidebar-link">
 <span class="menu-text">Lecture 13: Products and typed products</span></a>
  </div>
</li>
        <li class="sidebar-item">
  <div class="sidebar-item-container"> 
  <a href="./lecture14.html" class="sidebar-item-text sidebar-link">
 <span class="menu-text">Lecture 14: Relations</span></a>
  </div>
</li>
        <li class="sidebar-item">
  <div class="sidebar-item-container"> 
  <a href="./lecture15.html" class="sidebar-item-text sidebar-link active">
 <span class="menu-text">Lecture 15: Cospans</span></a>
  </div>
</li>
        <li class="sidebar-item">
  <div class="sidebar-item-container"> 
  <a href="./references.html" class="sidebar-item-text sidebar-link">
 <span class="menu-text">References</span></a>
  </div>
</li>
    </ul>
    </div>
</nav>
<div id="quarto-sidebar-glass" data-bs-toggle="collapse" data-bs-target="#quarto-sidebar,#quarto-sidebar-glass"></div>
<!-- margin-sidebar -->
    <div id="quarto-margin-sidebar" class="sidebar margin-sidebar">
        
    </div>
<!-- main -->
<main class="content" id="quarto-document-content">

<header id="title-block-header" class="quarto-title-block default">
<div class="quarto-title">
<h1 class="title">Lecture 15: Cospans</h1>
</div>



<div class="quarto-title-meta">

    
  
    
  </div>
  

</header>

<div class="hidden">
<p>$$ </p>
<!-- Math: categories -->
<!-- Math: graphs -->
<p>$$</p>
</div>
<p>In the previous lecture, we learned about the category of relations, and we thought about subsets as a way of modeling the semantics of a system; a system consists of a universum and a behavior set. We are now going to start to think about syntax for systems.</p>
<p>Our goal for the next couple lectures is to learn how to compose <em>open graphs</em>. Along the way, we will end up learning category theory tools for doing a variety of other things, but open graphs are the end goal.</p>
<div id="def-open-graph" class="theorem definition">
<p><span class="theorem-title"><strong>Definition 1 </strong></span>An <strong>open graph</strong> is a graph <span class="math inline">G</span> along with an input set <span class="math inline">I</span> and an output set <span class="math inline">O</span> and maps <span class="math inline">i \colon I \to G(V)</span>, <span class="math inline">o \colon O \to G(V)</span>.</p>
</div>
<div class="quarto-figure quarto-figure-center">
<figure class="figure">
<p><img src="open_graph.png" class="img-fluid figure-img"></p>
<figcaption class="figure-caption">An Open Graph</figcaption>
</figure>
</div>
<p>We want to make a category where the objects are finite sets and the morphisms are open graphs between the finite sets.</p>
<p>We are going to build up the technology for this category in parts. The first step is defining what a <em>cospan category</em> is. The second step is going to generalize this.</p>
<p>One way of a thinking about a relation <span class="math inline">R \subset X \times Y</span> is that it is a <em>span</em></p>
<div class="tikzcd">
<img src="tikz/2d8eb8a8355324605e3630c3c44d5e8ae5c8ad82.svg" class="img-fluid">
</div>
<p>There is a general principle that “syntax and semantics are dual”, which we won’t go into too far today, but it shows up in the fact that we are going to think about <em>cospans</em> today, as given in the next definition.</p>
<div id="def-cospan" class="theorem definition">
<p><span class="theorem-title"><strong>Definition 2 </strong></span>A <strong>cospan</strong> in a category <span class="math inline">\mathsf{C}</span> from an object <span class="math inline">X \in \mathsf{C}</span> to an object <span class="math inline">Y \in \mathsf{C}</span> is a diagram of the form</p>
<div class="tikzcd">
<img src="tikz/0ed268054fb1727ca788d701d87a2e6a2ae94ca8.svg" class="img-fluid">
</div>
</div>
<div id="fig-uwd-cospan" class="quarto-layout-panel">
<figure class="figure">
<div class="quarto-layout-row quarto-layout-valign-bottom">
<div class="quarto-layout-cell" style="flex-basis: 50.0%;justify-content: center;">
<div class="quarto-figure quarto-figure-center">
<figure class="figure">
<p><img src="uwd_fincospan_equiv.svg" class="img-fluid figure-img" width="500"></p>
<figcaption class="figure-caption">Cospan style</figcaption>
</figure>
</div>
</div>
<div class="quarto-layout-cell" style="flex-basis: 50.0%;justify-content: center;">
<div class="quarto-figure quarto-figure-center">
<figure class="figure">
<p><img src="uwd.svg" class="img-fluid figure-img" width="500"></p>
<figcaption class="figure-caption">Undirected wiring diagram style</figcaption>
</figure>
</div>
</div>
</div>
<p></p><figcaption class="figure-caption">Figure&nbsp;1: Two styles of drawing an undirected wiring diagram</figcaption><p></p>
</figure>
</div>
<div id="exm-fincospan" class="theorem example">
<p><span class="theorem-title"><strong>Example 1 </strong></span>We can visualize a cospan in <span class="math inline">\mathsf{FinSet}</span> in two different ways, as shown in <a href="#fig-uwd-cospan">Figure&nbsp;<span>1</span></a>.</p>
</div>
<div id="def-cospan-category" class="theorem definition">
<p><span class="theorem-title"><strong>Definition 3 </strong></span>Let <span class="math inline">\mathsf{C}</span> be a category that has pushouts. Then define the category <span class="math inline">\operatorname{Csp}(\mathsf{C})</span> in the following way. The objects of <span class="math inline">\operatorname{Csp}(\mathsf{C})</span> are the objects of <span class="math inline">\mathsf{C}</span>, and a morphism from <span class="math inline">X</span> to <span class="math inline">Y</span> is a cospan from <span class="math inline">X</span> to <span class="math inline">Y</span>. Composition of two cospans</p>
<div class="tikzcd">
<img src="tikz/58848ad6d113a6f01d790fbe3e5e05f443c64e9b.svg" class="img-fluid">
</div>
<p>is given by the pushout</p>
<div class="tikzcd">
<img src="tikz/fe644e5ad62ced8abb8f944260cd70e4560aa2b0.svg" class="img-fluid">
</div>
</div>
<p>What is the identity in this category? I claim that the identity on <span class="math inline">X</span> is</p>
<div class="tikzcd">
<img src="tikz/0ec64dcf679d03d054ce45da8efa771f3555dbfe.svg" class="img-fluid">
</div>
<p>Let’s prove that this is the case. Suppose that we have another cospan</p>
<div class="tikzcd">
<img src="tikz/0ed268054fb1727ca788d701d87a2e6a2ae94ca8.svg" class="img-fluid">
</div>
<p>Then their composition is</p>
<div class="tikzcd">
<img src="tikz/7aa39fe46c2a270908fadce79104715e52f1a40f.svg" class="img-fluid">
</div>
<p>I want to show that <span class="math inline">A = X +_{X} A</span>, and that the two upper morphisms are <span class="math inline">f</span> and <span class="math inline">1_A</span> respectively.</p>
<p>Immediately here, alarm bells should be going off in your head. Showing that two objects in a category are equal is almost always the wrong thing to do! Instead, one should show that two objects are <em>isomorphic</em>. But in this case, these “objects” are serving the purpose of morphisms, and morphisms need to be equal “on the nose”! So what do we do?</p>
<p>We have to redefine <span class="math inline">\operatorname{Csp}(\mathsf{C})</span>. There are two ways of doing this. One is that we can consider a notion of morphism between morphism, which gets us into bicategories. But we choose to not walk that route today.</p>
<p>The second way is to make a morphism from <span class="math inline">X</span> to <span class="math inline">Y</span> be an <em>equivalence class</em> of cospans.</p>
<div id="def-cospan-equivalent" class="theorem definition">
<p><span class="theorem-title"><strong>Definition 4 </strong></span>The two cospans</p>
<div class="tikzcd">
<img src="tikz/0ed268054fb1727ca788d701d87a2e6a2ae94ca8.svg" class="img-fluid">
</div>
<p>and</p>
<div class="tikzcd">
<img src="tikz/ed5d5a885b232d2e5d20dcee55d27d8c0c73d8a1.svg" class="img-fluid">
</div>
<p>are <strong>equivalent</strong> when there exists an isomorphism <span class="math inline">\phi \colon A \to A'</span> such that</p>
<div class="tikzcd">
<img src="tikz/53aa431823c67ac3e7c6b617fc03abe5d2f1b835.svg" class="img-fluid">
</div>
<p>commutes.</p>
</div>
<p>We then redefine <span class="math inline">\operatorname{Csp}(\mathsf{C})</span>.</p>
<div id="def-cospan-category-for-real" class="theorem definition">
<p><span class="theorem-title"><strong>Definition 5 </strong></span>The category <span class="math inline">\operatorname{Csp}(\mathsf{C})</span> has as objects, objects of <span class="math inline">\mathsf{C}</span>, and as morphisms <em>equivalence classes</em> of cospans.</p>
<p>Given two morphisms <span class="math inline">E_{1} \colon X \to Y</span> and <span class="math inline">E_{2} \colon Y \to Z</span>, we compose them by picking a cospan from <span class="math inline">E_{1}</span>, a cospan from <span class="math inline">E_{2}</span>, taking their pushout, and then taking the equivalence class of all morphisms equivalent to that pushout.</p>
</div>
<p>There’s something very important that we have to check for this to work: we have to check that composing equivalent cospans give equivalent results! Proving this will enable us to flex some of our theoretical muscles for pushouts.</p>
<div id="def-welldefinedness" class="theorem definition">
<p><span class="theorem-title"><strong>Definition 6 </strong></span>Suppose that we have the following commuting diagram:</p>
<div class="tikzcd">
<img src="tikz/fd216c5ab47e30a8caee9955da0b038f4ffd9d31.svg" class="img-fluid">
</div>
<p>where <span class="math inline">\phi</span> and <span class="math inline">\psi</span> are isomorphisms. Then there is an isomorphism <span class="math inline">\phi +_Y \psi \colon A +_Y B \to A' +_Y B'</span> such that the diagram</p>
<div class="tikzcd">
<img src="tikz/a9e45ca4e32ac2b6c973499269f50646341a494c.svg" class="img-fluid">
</div>
<p>commutes.</p>
</div>
<div class="proof">
<p><span class="proof-title"><em>Proof</em>. </span>This is our first big serious proof in category theory, so before we get started, let’s just make sure we understand where we are and where we’re going.</p>
<p>The diagrams above look big and scary, but when we chunk them, they aren’t so bad. We have two pairs of equivalent cospans: two equivalent cospans between <span class="math inline">X</span> and <span class="math inline">Y</span>, and two equivalent cospans between <span class="math inline">Y</span> and <span class="math inline">Z</span>. Then we’ve composed each one, to get the top and bottom of the diagram, and finally the curved arrow is an isomorphism between the composed cospans.</p>
<p>Often in proofs like this, it is hard to know where to start. One good thing to do is to go back to definitions.</p>
<p>Let <span class="math inline">\mathsf{D}</span> be the category that looks like this</p>
<div class="tikzcd">
<img src="tikz/af641fa3823b822163367502216861d27670a463.svg" class="img-fluid">
</div>
<p>Let <span class="math inline">F, F'</span> be functors from <span class="math inline">\mathsf{D}</span> into <span class="math inline">\mathsf{C}</span> that send</p>
<div class="tikzcd">
<img src="tikz/63fb5fd59e05fbbe20abeca3290c0cd360c6964d.svg" class="img-fluid">
</div>
<p>to</p>
<div class="tikzcd">
<img src="tikz/67442965d4b4d6263ec83dc19ed78db133822e2f.svg" class="img-fluid">
</div>
<p>and</p>
<div class="tikzcd">
<img src="tikz/9ddd0bbb3b35b801ec9c7de1dc745af93bb84492.svg" class="img-fluid">
</div>
<p>respectively.</p>
<p>Then recall that the <em>pushout</em> of the diagram <span class="math inline">F</span> is a representing object for the functor</p>
<p><span class="math inline">X \mapsto \operatorname{Hom}_{\mathsf{C}^{\mathsf{D}}}(F, \Delta X)</span></p>
<p>which sends an object <span class="math inline">X</span> to the set of natural transformations from <span class="math inline">F</span> to the constant functor at <span class="math inline">X</span>, i.e.&nbsp;commuting diagrams</p>
<div class="tikzcd">
<img src="tikz/14a8bd3e342a22391c611167cfb7ecd87dacb2aa.svg" class="img-fluid">
</div>
<p>which are the same as commuting squares</p>
<div class="tikzcd">
<img src="tikz/e2401e0c1d95ef90f6cd4417b6d29ded8197967a.svg" class="img-fluid">
</div>
<p>Now, I claim that if we can show that <span class="math inline">F</span> and <span class="math inline">F'</span> are naturally isomorphic functors, then the pushout of <span class="math inline">F</span> and the pushout of <span class="math inline">F'</span> will be isomorphic as well.</p>
<p>This is because if <span class="math inline">F \cong F'</span>, then <span class="math inline">\operatorname{Hom}_{C^{\mathsf{D}}}(F, \Delta-) \cong \operatorname{Hom}_{C^{\mathsf{D}}}(F', \Delta-)</span>, and representing objects of isomorphic functors are isomorphic (that’s Yoneda, baby!).</p>
<p>To show that <span class="math inline">F</span> and <span class="math inline">F'</span> are naturally isomorphic, we must construct a natural isomorphism. This consists of an isomorphism <span class="math inline">F(x) \cong F'(x)</span> for each <span class="math inline">x \in \mathsf{D}</span>, chosen to satisfy the naturality condition. But we are given exactly what we need by our assumption! Namely, we make the following natural isomorphism:</p>
<div class="tikzcd">
<img src="tikz/cb90d7720c691aeddf9b58541e759a88960016c9.svg" class="img-fluid">
</div>
<p>Now, through what some might call “abstract nonsense”, we have summoned an isomorphism from <span class="math inline">A +_{Y} B</span> to <span class="math inline">A' +_{Y} B'</span>: we will call this isomorphism <span class="math inline">\phi +_{Y} \psi</span>.</p>
<p>This is not enough though: we still have to show that the whole diagram commutes! Unfortunately, I can’t think of a slick way to do this quickly, so instead I will summarize the strategy. Basically, you have to trace through the proof that isomorphic functors give isomorphic representing objects, and you will see that the construction of the isomorphism shows that this should commute.</p>
</div>



</main> <!-- /main -->
<script id="quarto-html-after-body" type="application/javascript">
window.document.addEventListener("DOMContentLoaded", function (event) {
  const toggleBodyColorMode = (bsSheetEl) => {
    const mode = bsSheetEl.getAttribute("data-mode");
    const bodyEl = window.document.querySelector("body");
    if (mode === "dark") {
      bodyEl.classList.add("quarto-dark");
      bodyEl.classList.remove("quarto-light");
    } else {
      bodyEl.classList.add("quarto-light");
      bodyEl.classList.remove("quarto-dark");
    }
  }
  const toggleBodyColorPrimary = () => {
    const bsSheetEl = window.document.querySelector("link#quarto-bootstrap");
    if (bsSheetEl) {
      toggleBodyColorMode(bsSheetEl);
    }
  }
  toggleBodyColorPrimary();  
  const icon = "";
  const anchorJS = new window.AnchorJS();
  anchorJS.options = {
    placement: 'right',
    icon: icon
  };
  anchorJS.add('.anchored');
  const isCodeAnnotation = (el) => {
    for (const clz of el.classList) {
      if (clz.startsWith('code-annotation-')) {                     
        return true;
      }
    }
    return false;
  }
  const clipboard = new window.ClipboardJS('.code-copy-button', {
    text: function(trigger) {
      const codeEl = trigger.previousElementSibling.cloneNode(true);
      for (const childEl of codeEl.children) {
        if (isCodeAnnotation(childEl)) {
          childEl.remove();
        }
      }
      return codeEl.innerText;
    }
  });
  clipboard.on('success', function(e) {
    // button target
    const button = e.trigger;
    // don't keep focus
    button.blur();
    // flash "checked"
    button.classList.add('code-copy-button-checked');
    var currentTitle = button.getAttribute("title");
    button.setAttribute("title", "Copied!");
    let tooltip;
    if (window.bootstrap) {
      button.setAttribute("data-bs-toggle", "tooltip");
      button.setAttribute("data-bs-placement", "left");
      button.setAttribute("data-bs-title", "Copied!");
      tooltip = new bootstrap.Tooltip(button, 
        { trigger: "manual", 
          customClass: "code-copy-button-tooltip",
          offset: [0, -8]});
      tooltip.show();    
    }
    setTimeout(function() {
      if (tooltip) {
        tooltip.hide();
        button.removeAttribute("data-bs-title");
        button.removeAttribute("data-bs-toggle");
        button.removeAttribute("data-bs-placement");
      }
      button.setAttribute("title", currentTitle);
      button.classList.remove('code-copy-button-checked');
    }, 1000);
    // clear code selection
    e.clearSelection();
  });
  function tippyHover(el, contentFn) {
    const config = {
      allowHTML: true,
      content: contentFn,
      maxWidth: 500,
      delay: 100,
      arrow: false,
      appendTo: function(el) {
          return el.parentElement;
      },
      interactive: true,
      interactiveBorder: 10,
      theme: 'quarto',
      placement: 'bottom-start'
    };
    window.tippy(el, config); 
  }
  const noterefs = window.document.querySelectorAll('a[role="doc-noteref"]');
  for (var i=0; i<noterefs.length; i++) {
    const ref = noterefs[i];
    tippyHover(ref, function() {
      // use id or data attribute instead here
      let href = ref.getAttribute('data-footnote-href') || ref.getAttribute('href');
      try { href = new URL(href).hash; } catch {}
      const id = href.replace(/^#\/?/, "");
      const note = window.document.getElementById(id);
      return note.innerHTML;
    });
  }
      let selectedAnnoteEl;
      const selectorForAnnotation = ( cell, annotation) => {
        let cellAttr = 'data-code-cell="' + cell + '"';
        let lineAttr = 'data-code-annotation="' +  annotation + '"';
        const selector = 'span[' + cellAttr + '][' + lineAttr + ']';
        return selector;
      }
      const selectCodeLines = (annoteEl) => {
        const doc = window.document;
        const targetCell = annoteEl.getAttribute("data-target-cell");
        const targetAnnotation = annoteEl.getAttribute("data-target-annotation");
        const annoteSpan = window.document.querySelector(selectorForAnnotation(targetCell, targetAnnotation));
        const lines = annoteSpan.getAttribute("data-code-lines").split(",");
        const lineIds = lines.map((line) => {
          return targetCell + "-" + line;
        })
        let top = null;
        let height = null;
        let parent = null;
        if (lineIds.length > 0) {
            //compute the position of the single el (top and bottom and make a div)
            const el = window.document.getElementById(lineIds[0]);
            top = el.offsetTop;
            height = el.offsetHeight;
            parent = el.parentElement.parentElement;
          if (lineIds.length > 1) {
            const lastEl = window.document.getElementById(lineIds[lineIds.length - 1]);
            const bottom = lastEl.offsetTop + lastEl.offsetHeight;
            height = bottom - top;
          }
          if (top !== null && height !== null && parent !== null) {
            // cook up a div (if necessary) and position it 
            let div = window.document.getElementById("code-annotation-line-highlight");
            if (div === null) {
              div = window.document.createElement("div");
              div.setAttribute("id", "code-annotation-line-highlight");
              div.style.position = 'absolute';
              parent.appendChild(div);
            }
            div.style.top = top - 2 + "px";
            div.style.height = height + 4 + "px";
            let gutterDiv = window.document.getElementById("code-annotation-line-highlight-gutter");
            if (gutterDiv === null) {
              gutterDiv = window.document.createElement("div");
              gutterDiv.setAttribute("id", "code-annotation-line-highlight-gutter");
              gutterDiv.style.position = 'absolute';
              const codeCell = window.document.getElementById(targetCell);
              const gutter = codeCell.querySelector('.code-annotation-gutter');
              gutter.appendChild(gutterDiv);
            }
            gutterDiv.style.top = top - 2 + "px";
            gutterDiv.style.height = height + 4 + "px";
          }
          selectedAnnoteEl = annoteEl;
        }
      };
      const unselectCodeLines = () => {
        const elementsIds = ["code-annotation-line-highlight", "code-annotation-line-highlight-gutter"];
        elementsIds.forEach((elId) => {
          const div = window.document.getElementById(elId);
          if (div) {
            div.remove();
          }
        });
        selectedAnnoteEl = undefined;
      };
      // Attach click handler to the DT
      const annoteDls = window.document.querySelectorAll('dt[data-target-cell]');
      for (const annoteDlNode of annoteDls) {
        annoteDlNode.addEventListener('click', (event) => {
          const clickedEl = event.target;
          if (clickedEl !== selectedAnnoteEl) {
            unselectCodeLines();
            const activeEl = window.document.querySelector('dt[data-target-cell].code-annotation-active');
            if (activeEl) {
              activeEl.classList.remove('code-annotation-active');
            }
            selectCodeLines(clickedEl);
            clickedEl.classList.add('code-annotation-active');
          } else {
            // Unselect the line
            unselectCodeLines();
            clickedEl.classList.remove('code-annotation-active');
          }
        });
      }
  const findCites = (el) => {
    const parentEl = el.parentElement;
    if (parentEl) {
      const cites = parentEl.dataset.cites;
      if (cites) {
        return {
          el,
          cites: cites.split(' ')
        };
      } else {
        return findCites(el.parentElement)
      }
    } else {
      return undefined;
    }
  };
  var bibliorefs = window.document.querySelectorAll('a[role="doc-biblioref"]');
  for (var i=0; i<bibliorefs.length; i++) {
    const ref = bibliorefs[i];
    const citeInfo = findCites(ref);
    if (citeInfo) {
      tippyHover(citeInfo.el, function() {
        var popup = window.document.createElement('div');
        citeInfo.cites.forEach(function(cite) {
          var citeDiv = window.document.createElement('div');
          citeDiv.classList.add('hanging-indent');
          citeDiv.classList.add('csl-entry');
          var biblioDiv = window.document.getElementById('ref-' + cite);
          if (biblioDiv) {
            citeDiv.innerHTML = biblioDiv.innerHTML;
          }
          popup.appendChild(citeDiv);
        });
        return popup.innerHTML;
      });
    }
  }
});
</script>
<nav class="page-navigation">
  <div class="nav-page nav-page-previous">
      <a href="./lecture14.html" class="pagination-link">
        <i class="bi bi-arrow-left-short"></i> <span class="nav-page-text">Lecture 14: Relations</span>
      </a>          
  </div>
  <div class="nav-page nav-page-next">
      <a href="./references.html" class="pagination-link">
        <span class="nav-page-text">References</span> <i class="bi bi-arrow-right-short"></i>
      </a>
  </div>
</nav>
</div> <!-- /content -->



</body></html>