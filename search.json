[
  {
    "objectID": "index.html",
    "href": "index.html",
    "title": "Kittenlab lecture notes",
    "section": "",
    "text": "Introduction\nThis is a Quarto book.\nTo learn more about Quarto books visit https://quarto.org/docs/books."
  },
  {
    "objectID": "lecture1.html",
    "href": "lecture1.html",
    "title": "Lecture 1: Formal Math",
    "section": "",
    "text": "Introduction\nThese lectures are meant to go from 0 to category theory as efficiently as possible. This means that we are going to optimize for being precise, for being clear, and for opening up new possibilities for you. We are not going to optimize for being entertaining or engaging; this is not a ‚Äúmonads as burritos‚Äù blog post or a popsci article about category theory. The answer to ‚Äúwhy do we care about this‚Äù is often going to be ‚Äúbecause it‚Äôs important later on‚Äù, and you are just going to have to trust me on that.\nAs we are going from 0, in this first lecture I plan to get you all aquainted with what it even means to ‚Äúdo math‚Äù at the level that category theory lives. This is a different kind of math than what you might have learned about in lower level math courses, and so sorting out from the beginning the mindset that you should have for the rest of the lectures is the most efficient use of this time. Generally, nobody tells you about this distinction and you have to work it out painfully over years of getting bad grades on university math homeworks; we don‚Äôt have time for that.\nHowever, we will have code examples for you to play with, because most of you are programmers and thus making a connection between math and code should speed the learning process.\nFinally, everyone at some point in this lecture will be frustrated by how pedantic I‚Äôm being. Sorry. I‚Äôm erring on the side of pedantry because there‚Äôs a ‚Äúprice is right‚Äù situation here: if I go too slow, we waste a bit of time, but if I go too fast we waste all of the time.\nPure math consists of a series of definitions, propositions, and examples. In this document, we typeset these like\nA definition introduces a new word, and I will always put that new word in bold. In normal speech, words have meanings given by context, by association, and only sometimes by explicit definition. In math, it is not like that. Every technical word has a single definition. That definition may not be written down explicitly; it may be agreed implicitly between mathematicians based on shared experience. However, in theory there is always a precise definition for every mathematical concept. It is expected that all participants in a mathematical conversation could be locked up in a cell, given paper, a pencil and a great deal of time, and then write down a fully rigorous formulation of each of the words they are using. Moreover, each of these formulations for each of the mathematicians might not be exactly the same, but they should be able to be proven equivalent.\nUntil you learn mathematical logic, which we will not cover here, this expectation cannot be realized because you don‚Äôt know a precise definition of ‚Äúfully rigorous‚Äù. The level of rigor that will suffice for now is that you should be able to expand every definition to a level where it can be explained to a smart, patient human who knows no category theory, by going backwards and defining each of the terms used in that definition until you get to very basic concepts, like sets, functions, and equations.\nThe extremely important corollary to all of this is that if you feel like your understanding of a definition does not reach this level, YOU ARE CONFUSED. This is OK. It is good to be confused. It is far better to be confused and not yet wrong than it is to be unconfused and wrong.\nWhat should you do when you are confused? First of all, GO BACKWARDS. Read the previous section of a textbook. If you are still confused, keep going backwards until you hit something that makes sense, and then work your way back up. Secondly, GO SIDEWAYS. Read another textbook that treats the same material in a different way. Then finally, if neither of those work, ASK AN EXPERT, and keep asking until you feel unconfused. The MOST IMPORTANT SKILL in math is to know when you are confused and don‚Äôt continue until you are unconfused! If you continue on, you will get hopelessly confused; if you turn back immediately there is still hope.\nDefinitions are the most important part of higher math. Understanding the definitions is often half the battle, and it is most of the battle for category theory.\nA proposition is an assertion that one logical statement (the conclusion) follows from several logical statements (the premises). Each proposition comes along with a proof. Just like definitions, it is expected that the participants in a mathematical conversation could expand a proof out to a fully rigorous level, even if the given proof is very vague. What you write down as a proof should be seen as a ‚Äúhint‚Äù for the construction of the actual, fully rigorous proof; mathematicians come to cultural agreements for how much of a hint is needed in different circumstances.\nAs a mathematical learner, proofs are your window into the thought processes of subject experts. Thus, they are very good to study and understand. However, they are not as critical to understand as definitions. It is absolutely essential to fully understand definitions, but proofs can be ‚Äúblackboxed‚Äù sometimes, and you can just remember the proposition without understanding fully the proof.\nPropositions are also known as theorems, lemmas, and corollaries. A theorem is an important proposition, a lemma is a small proposition mainly used to prove other propositions, and a corollary is a proposition whose proof is easy because of another proposition, for example a special case. Really, these are just vibes that mathematicians add to propositions.\nFinally, an example is a definition or proposition that falls under one of three categories.\nA pure math document consists of a sequence of definitions, propositions, and examples, punctuated with interleaving prose that attempts to give intuition for what the definitions, propositions, and examples are saying, and why one should care about those definitions, propositions, and examples. Intuition is a very important part of math; it is what allows mathematicians to elaborate definitions, discover proofs, and most importantly, to figure out what is important to study in the first place. However, intuition is no substitute for rigor. Intuition allows you to leap off cliffs; rigor is what allows you to build a bridge underneath you before you hit the ground.\nIn the foundations of math, we also have two more types of statement: axioms and undefined terms. Definitions and propositions should always ‚Äúbottom out‚Äù at axioms and undefined terms. However, most mathematicians do not do this, instead leaving it to the reader to choose a suitable foundations of math in which to fully formalize their theories. Surprisingly, most interesting math can be fully formalized in many foundations, so this normally works out fine.\nFor us, our ‚Äúreality‚Äù will be what happens on the computer. So we will try to ‚Äúbottom out‚Äù on concepts in the computer.\nWe will now demonstrate the previous concepts by studying finite sets. We will not get to category theory today. Instead, we will revisit some things that should be familiar to you and treat them in the style that we will be using for the rest of the lectures.\nFinite sets will be important for most of the applications of category theory that we will learn in the next lectures, and also most of the concepts of category theory are well-illustrated by finite sets. So a firm grasp of finite sets will be an immense aid in the coming weeks.\nWe start with a basic universe of discourse. It is traditional to be minimalistic with this universe of discourse, and say that everything is a set, or everything is a natural number. However, we choose to be untraditional.\nWe might represent this in Julia with the following data structure.\nNote that this is not the only possible representation of a finite set. Definitions in math always can be translated into code in many ways; the choice of a particular way is a delicate balancing act between simplicity, performance, clarity, and completeness.\nAnother possible representation of finite sets is\nThis represents the finite set \\(\\{1,\\ldots,n\\}\\). Here we have traded performance over completeness; we can only represent some finite sets, but we represent those finite sets more efficiently.\nIt is important to note that even if \\(a\\) is listed multiple times in \\(A\\), \\(f(a)\\) only has one value.\nWe might represent a function between ùîΩs, also known as a morphism of finite sets, with the following data structure.\nHowever, not all instances of this data structure represent functions. The following Julia function determines whether a morphism of finite sets is valid.\nFrequently we will write down Julia types representing mathematical concepts where not all values of that type are valid representations of that mathematical concept. This is unavoidable because Julia types do not have the specificity to narrow down the space of values enough. There are languages where the types can narrow down the space of values sufficiently, but none of those languages have well-maintained BLAS/LAPACK bindings.\nFor finite sets implemented by IntùîΩ, we can give a more efficient encoding of morphism.\nwith corresponding validation function\nFrom now on, we will work with only VecùîΩs and ùîΩMors, and leave the implementation of more efficient code to the reader.\nWe now introduce the operation at the core of all category theory: composition!\nWe now come to an issue that is everywhere in category theory: equality. If you have seen any set theory before, you might think that \\(\\{1,2,3,3\\}\\) and \\(\\{3,2,1\\}\\) are ‚Äúthe same‚Äù set. Note however that when I defined finite set, I just said that a finite set was a list of things surrounded by curly braces. Additionally,\nSo it seems like something is wrong with our definition. One way one might try to fix this would be by using Set{Any} instead of Vector{Any}. This certainly makes more of our Julia values equal.\nBut let‚Äôs think about why we typically choose to make \\(\\{1,2,3,3\\}\\) and \\(\\{3,2,1\\}\\) ‚Äúthe same‚Äù set. One good reason is that any morphism out of \\(\\{1,2,3,3\\}\\) can be seen as a morphism out of \\(\\{3,2,1\\}\\), and the same goes for incoming morphisms.\nIf f is a valid ùîΩMor with f.dom == A then f‚Ä≤ = convertAA‚Ä≤(f) is a valid ùîΩMor with f‚Ä≤.dom == A‚Ä≤, and the same the other way around. Moreover, convertA‚Ä≤A(convertAA‚Ä≤(f)) == f and convertAA‚Ä≤(convertA‚Ä≤A(f‚Ä≤)) == f‚Ä≤. We could define similar functions for morphisms into A and A‚Ä≤.\nTherefore, from a ‚Äúmorphism‚Äôs-eye‚Äù perspective, A and A‚Ä≤ behave the exact same way; defining a morphism in or out of A is equivalent to defining a morphism in or out of A‚Ä≤.\nBut if we take this to its logical conclusion, we find that this is true not only of \\(\\{1,2,3,3\\}\\) and of \\(\\{3,2,1\\}\\), but also of \\(\\{1,2,3\\}\\) and \\(\\{\\mathbf{a},\\mathbf{b},\\mathbf{c}\\}\\)! Specifically, we can do the following.\nWe can use f and g to convert freely between morphisms out of B and morphisms out of B‚Ä≤. Thus, B and B‚Ä≤ also are equivalent in some sense. But there are many ways of ‚Äúforming‚Äù this equivalence; we could use f.vals = Dict(1 => :b, 2 => :a, 3 => :c), for instance.\nAll of this motivates the next few definitions.\nYou can remember the reasoning about why we care isomorphism means by thinking ‚Äúisomorphic = same morphisms‚Äù. That is, if we have an isomorphism between \\(A\\) and \\(A^\\prime\\), then there are ‚Äúthe same morphisms‚Äù out of \\(A\\) and out of \\(A\\prime\\).\nHowever, as noted before, there might be several distinct isomorphisms between \\(A\\) and \\(A^\\prime\\). Thus, one must be careful to specify which isomorphism when you are talking about isomorphic finite sets.\nAnyways, this is why it‚Äôs not a big problem to use a vector to represent a finite set. There are only rare cases where you can find a representation of your mathematical objects such that two representations are equal if and only if the mathematical objects are isomorphic. If you are lucky enough to find this, it‚Äôs called a ‚Äúcanonical form‚Äù and it‚Äôs a big deal. As a practical matter, we might use Set instead of Vector because it gets a bit closer to a canonical form, but I wanted to start with Vector to make the point that the representation of your mathematical object on a computer in general will not be canonical.\nWe now prove a theorem about isomorphisms of finite sets.\nWe prove this with a program.\nThe point of this first lecture is to introduce you to finite sets and pure math, not category theory. Therefore, we end with a discussion of a theorem from combinatorics (come back after lecture 2).\nWe can implement the pigeonhole principle in Julia.\nThere isn‚Äôt much else to this part, but hopefully this has served as a more concrete illustration of how finite sets work in Julia."
  },
  {
    "objectID": "lecture1.html#takeaways",
    "href": "lecture1.html#takeaways",
    "title": "Lecture 1: Formal Math",
    "section": "Takeaways",
    "text": "Takeaways\n\nPure math consists of definitions, propositions, and examples.\nThese are specified in enough detail so that participants in a mathematical conversation could independently come up with equivalent elaborations.\nIf you feel you could not do this at any point, then you are in a perfectly normal situation and should not feel ashamed whatsoever. However, continuing on without first going back and understanding what you are confused about is a bad idea."
  },
  {
    "objectID": "lecture1.html#takeaways-1",
    "href": "lecture1.html#takeaways-1",
    "title": "Lecture 1: Formal Math",
    "section": "Takeaways",
    "text": "Takeaways\n\nA finite set is a list of things\nA morphism of finite sets from \\(A\\) to \\(B\\) sends each unique element of \\(A\\) to an element of \\(B\\)\nThere are multiple ways of implementing representations of finite sets and morphisms between them on the computer"
  },
  {
    "objectID": "lecture1.html#takeaways-2",
    "href": "lecture1.html#takeaways-2",
    "title": "Lecture 1: Formal Math",
    "section": "Takeaways",
    "text": "Takeaways\n\nYou can compose morphisms between finite sets\nIsomorphisms tell you which finite sets are equivalent from the point of view of morphisms\nYou can tell which finite sets are isomorphic by looking at their cardinalities"
  },
  {
    "objectID": "lecture1.html#takeaways-3",
    "href": "lecture1.html#takeaways-3",
    "title": "Lecture 1: Formal Math",
    "section": "Takeaways",
    "text": "Takeaways\n\nYou can do basic combinatorics in the framework we have developed in this lecture"
  },
  {
    "objectID": "lecture2.html",
    "href": "lecture2.html",
    "title": "Lecture 2: Category Theory",
    "section": "",
    "text": "Welcome to the second lecture in this series. I‚Äôm not going to repeat the introduction from the first lecture; you should know what to expect now. Specifically, it‚Äôs going to go slowly. We start with (not-necessarily finite) sets.\n\nSets\n\nA set \\(X\\) is a function from Any to Bool, which may or either be written in Julia or defined mathematically. If \\(X(x) = \\mathbf{true}\\), we write \\(x \\in X\\), and if \\(X(x) = \\mathbf{false}\\) we write \\(x \\notin X\\).\n\nNote that when we write down Julia definitions involving sets, we are implicitly assuming that the functions are written in Julia. However, there are some sets that we will use whose functions cannot be written down in Julia, so take the Julia definitions with a grain of salt.\n\nFor any finite set A::ùîΩ, the function inA(x) = x ‚àà A is a set.\n\n\nAny Julia type T defines a set, via the function inT(x) = x isa T.\n\n\nGiven two sets \\(X\\) and \\(Y\\), their intersection \\(X \\cap Y\\) is defined by\n\\[ (X \\cap Y)(x) = X(x) \\wedge Y(x) \\]\nTheir union \\(X \\cup Y\\) is defined by\n\\[ (X \\cup Y)(x) = X(x) \\vee Y(x) \\]\n\n\nintersect(X,Y) = x -> X(x) && Y(x)\nunion(X,Y) = x -> X(x) || Y(x)\n\n\nGiven two sets \\(X\\) and \\(Y\\), their product \\(X \\times Y\\) is the set of tuples \\((x,y)\\) where \\(x \\in X\\) and \\(y \\in Y\\). That is, \\(z \\in X \\times Y\\) if and only if z isa Tuple, length(z) = 2, \\(z[1] \\in X\\) and \\(z[2] \\in Y\\).\n\n\nproduct(X,Y) = z -> (z isa Tuple) &&\n  length(z) == 2 && X(z[1]) && Y(z[2])\n\n\nWe leave it to the reader to give a mathematical definition for sum given the following definition in Julia\n\n\nstruct Left\n  val::Any\nend\n\nstruct Right\n  val::Any\nend\n\nsum(X,Y) = x ->\n  if x isa Left\n    X(x.val)\n  elseif x isa Right\n    Y(x.val)\n  else\n    false\n  end\n\n\nGiven two sets \\(A\\) and \\(B\\), the set \\(A \\to B\\) consists of all Julia callables \\(f\\) such that \\(f(a) \\in B\\) for all \\(a \\in A\\).\n\nNote that even if A and B are Julia functions, there is no way to check in Julia that a given f is an element of \\(A \\to B\\) because this would involve iterating through possibly infinitely many elements of \\(A\\). Again, languages where this is not the case don‚Äôt have good ODE solvers.\nBefore we move on to categories, we briefly discuss some things that are not sets. There are some ‚Äúcollections of stuff‚Äù that are not sets by the definition we gave above. For instance, there is no ‚Äúset of all sets‚Äù, because not all sets are expressed by computable functions. Nevertheless, we will sometimes make reference to these collections that are ‚Äútoo large‚Äù to be called sets, and we will call them ‚Äúclasses‚Äù.\n\n\nCategories\nThe moment we‚Äôve all be waiting for.\n\nA small category \\(C\\) consists of\n\na set \\(C_0\\) of objects\nfor every \\(x,y \\in C_0\\), a set \\(\\mathrm{Hom}_C(x,y)\\) of morphisms from \\(x\\) to \\(y\\)\nfor every \\(x,y,z \\in C_0\\), a composition function \\(\\circ \\colon \\mathrm{Hom}_C(y,z) \\times \\mathrm{Hom}_(x,y) \\to \\mathrm{Hom}(x,z)\\)\nfor every \\(x \\in C_0\\), an identity morphism \\(1_x \\in \\mathrm{Hom}_C(x,x)\\)\n\nsuch that\n\nfor all \\(x,y,z,w \\in C_0\\), \\(f \\in \\mathrm{Hom}_C(x,y)\\), \\(g \\in \\mathrm{Hom}_C(y,z)\\), \\(h \\in \\mathrm{Hom}_C(z,w)\\), \\[ h \\circ (g \\circ f) = (h \\circ g) \\circ f \\]\nfor all \\(x,y \\in C_0\\), \\(f \\in \\mathrm{Hom}_C(x,y)\\), \\[ 1_y \\circ f = f = f \\circ 1_x \\]\n\nThese two laws are called the associativity law and unitality law respectively.\n\n\nThere is a category where the objects are finite sets and the morphisms are morphisms of finite sets, as defined in the previous lecture."
  }
]