[
  {
    "objectID": "index.html",
    "href": "index.html",
    "title": "Kittenlab lecture notes",
    "section": "",
    "text": "Introduction\nThis is a Quarto book.\nTo learn more about Quarto books visit https://quarto.org/docs/books."
  },
  {
    "objectID": "lecture1.html",
    "href": "lecture1.html",
    "title": "Lecture 1: Formal Math",
    "section": "",
    "text": "Introduction\nThese lectures are meant to go from 0 to category theory as efficiently as possible. This means that we are going to optimize for being precise, for being clear, and for opening up new possibilities for you. We are not going to optimize for being entertaining or engaging; this is not a ‚Äúmonads as burritos‚Äù blog post or a popsci article about category theory. The answer to ‚Äúwhy do we care about this‚Äù is often going to be ‚Äúbecause it‚Äôs important later on‚Äù, and you are just going to have to trust me on that.\nAs we are going from 0, in this first lecture I plan to get you all aquainted with what it even means to ‚Äúdo math‚Äù at the level that category theory lives. This is a different kind of math than what you might have learned about in lower level math courses, and so sorting out from the beginning the mindset that you should have for the rest of the lectures is the most efficient use of this time. Generally, nobody tells you about this distinction and you have to work it out painfully over years of getting bad grades on university math homeworks; we don‚Äôt have time for that.\nHowever, we will have code examples for you to play with, because most of you are programmers and thus making a connection between math and code should speed the learning process.\nFinally, everyone at some point in this lecture will be frustrated by how pedantic I‚Äôm being. Sorry. I‚Äôm erring on the side of pedantry because there‚Äôs a ‚Äúprice is right‚Äù situation here: if I go too slow, we waste a bit of time, but if I go too fast we waste all of the time.\nPure math consists of a series of definitions, propositions, and examples. In this document, we typeset these like\nA definition introduces a new word, and I will always put that new word in bold. In normal speech, words have meanings given by context, by association, and only sometimes by explicit definition. In math, it is not like that. Every technical word has a single definition. That definition may not be written down explicitly; it may be agreed implicitly between mathematicians based on shared experience. However, in theory there is always a precise definition for every mathematical concept. It is expected that all participants in a mathematical conversation could be locked up in a cell, given paper, a pencil and a great deal of time, and then write down a fully rigorous formulation of each of the words they are using. Moreover, each of these formulations for each of the mathematicians might not be exactly the same, but they should be able to be proven equivalent.\nUntil you learn mathematical logic, which we will not cover here, this expectation cannot be realized because you don‚Äôt know a precise definition of ‚Äúfully rigorous‚Äù. The level of rigor that will suffice for now is that you should be able to expand every definition to a level where it can be explained to a smart, patient human who knows no category theory, by going backwards and defining each of the terms used in that definition until you get to very basic concepts, like sets, functions, and equations.\nThe extremely important corollary to all of this is that if you feel like your understanding of a definition does not reach this level, YOU ARE CONFUSED. This is OK. It is good to be confused. It is far better to be confused and not yet wrong than it is to be unconfused and wrong.\nWhat should you do when you are confused? First of all, GO BACKWARDS. Read the previous section of a textbook. If you are still confused, keep going backwards until you hit something that makes sense, and then work your way back up. Secondly, GO SIDEWAYS. Read another textbook that treats the same material in a different way. Then finally, if neither of those work, ASK AN EXPERT, and keep asking until you feel unconfused. The MOST IMPORTANT SKILL in math is to know when you are confused and don‚Äôt continue until you are unconfused! If you continue on, you will get hopelessly confused; if you turn back immediately there is still hope.\nDefinitions are the most important part of higher math. Understanding the definitions is often half the battle, and it is most of the battle for category theory.\nA proposition is an assertion that one logical statement (the conclusion) follows from several logical statements (the premises). Each proposition comes along with a proof. Just like definitions, it is expected that the participants in a mathematical conversation could expand a proof out to a fully rigorous level, even if the given proof is very vague. What you write down as a proof should be seen as a ‚Äúhint‚Äù for the construction of the actual, fully rigorous proof; mathematicians come to cultural agreements for how much of a hint is needed in different circumstances.\nAs a mathematical learner, proofs are your window into the thought processes of subject experts. Thus, they are very good to study and understand. However, they are not as critical to understand as definitions. It is absolutely essential to fully understand definitions, but proofs can be ‚Äúblackboxed‚Äù sometimes, and you can just remember the proposition without understanding fully the proof.\nPropositions are also known as theorems, lemmas, and corollaries. A theorem is an important proposition, a lemma is a small proposition mainly used to prove other propositions, and a corollary is a proposition whose proof is easy because of another proposition, for example a special case. Really, these are just vibes that mathematicians add to propositions.\nFinally, an example is a definition or proposition that falls under one of three categories.\nA pure math document consists of a sequence of definitions, propositions, and examples, punctuated with interleaving prose that attempts to give intuition for what the definitions, propositions, and examples are saying, and why one should care about those definitions, propositions, and examples. Intuition is a very important part of math; it is what allows mathematicians to elaborate definitions, discover proofs, and most importantly, to figure out what is important to study in the first place. However, intuition is no substitute for rigor. Intuition allows you to leap off cliffs; rigor is what allows you to build a bridge underneath you before you hit the ground.\nIn the foundations of math, we also have two more types of statement: axioms and undefined terms. Definitions and propositions should always ‚Äúbottom out‚Äù at axioms and undefined terms. However, most mathematicians do not do this, instead leaving it to the reader to choose a suitable foundations of math in which to fully formalize their theories. Surprisingly, most interesting math can be fully formalized in many foundations, so this normally works out fine.\nFor us, our ‚Äúreality‚Äù will be what happens on the computer. So we will try to ‚Äúbottom out‚Äù on concepts in the computer.\nWe will now demonstrate the previous concepts by studying finite sets. We will not get to category theory today. Instead, we will revisit some things that should be familiar to you and treat them in the style that we will be using for the rest of the lectures.\nFinite sets will be important for most of the applications of category theory that we will learn in the next lectures, and also most of the concepts of category theory are well-illustrated by finite sets. So a firm grasp of finite sets will be an immense aid in the coming weeks.\nWe start with a basic universe of discourse. It is traditional to be minimalistic with this universe of discourse, and say that everything is a set, or everything is a natural number. However, we choose to be untraditional.\nWe might represent this in Julia with the following data structure.\nabstract type ùîΩ end\n\nstruct VecùîΩ &lt;: ùîΩ\n  elems::Vector{Any}\nend\n\nBase.:(‚àà)(a, A::VecùîΩ) = a ‚àà A.elems\n\nBase.iterate(A::VecùîΩ) = iterate(A.elems)\nBase.iterate(A::VecùîΩ, k) = iterate(A.elems, k)\nA = VecùîΩ([:carrots, :peas])\nB = VecùîΩ([3, 7, 8])\nNote that this is not the only possible representation of a finite set. Definitions in math always can be translated into code in many ways; the choice of a particular way is a delicate balancing act between simplicity, performance, clarity, and completeness.\nAnother possible representation of finite sets is\nstruct IntùîΩ &lt;: ùîΩ\n  n::Int\nend\n\nBase.:(‚àà)(a, A::IntùîΩ) = 1 &lt;= a &lt;= A.n\n\nBase.iterate(A::IntùîΩ) = iterate(1:A.n)\nBase.iterate(A::IntùîΩ, k) = iterate(1:A.n, k)\nThis represents the finite set \\{1,\\ldots,n\\}. Here we have traded performance over completeness; we can only represent some finite sets, but we represent those finite sets more efficiently.\nIt is important to note that even if a is listed multiple times in A, f(a) only has one value.\nWe might represent a function between ùîΩs, also known as a morphism of finite sets, with the following data structure.\nstruct ùîΩMor\n  dom::ùîΩ\n  codom::ùîΩ\n  vals::Dict{Any,Any}\nend\n\n(f::ùîΩMor)(x) = f.vals[x]\nf = ùîΩMor(A, B, Dict(:carrots =&gt; 3, :peas =&gt; 3))\nHowever, not all instances of this data structure represent functions. The following Julia function determines whether a morphism of finite sets is valid.\nisvalid(f::ùîΩMor) =\n  all(x ‚àà keys(f.vals) && f(x) ‚àà f.codom for x in f.dom)\n[\n  isvalid(f), \n  isvalid(ùîΩMor(A, B, Dict(:peas =&gt; 3))),\n  isvalid(ùîΩMor(A, B, Dict(:peas =&gt; 5, :carrots =&gt; 3)))\n]\n\n3-element Vector{Bool}:\n 1\n 0\n 0\nFrequently we will write down Julia types representing mathematical concepts where not all values of that type are valid representations of that mathematical concept. This is unavoidable because Julia types do not have the specificity to narrow down the space of values enough. There are languages where the types can narrow down the space of values sufficiently, but none of those languages have well-maintained BLAS/LAPACK bindings.\nFor finite sets implemented by IntùîΩ, we can give a more efficient encoding of morphism.\nstruct IntùîΩMor\n  dom::IntùîΩ\n  codom::IntùîΩ\n  vals::Vector{Int}\nend\n\n(f::IntùîΩMor)(i) = f.vals[i]\nwith corresponding validation function\nisvalid(f::IntùîΩMor) = length(f.vals) == f.dom.n &&\n  all(f(x) ‚àà f.codom for x in f.dom)\nisvalid(IntùîΩMor(IntùîΩ(3), IntùîΩ(2), [1,2,2]))\n\ntrue\nFrom now on, we will work with only VecùîΩs and ùîΩMors, and leave the implementation of more efficient code to the reader."
  },
  {
    "objectID": "lecture1.html#takeaways",
    "href": "lecture1.html#takeaways",
    "title": "Lecture 1: Formal Math",
    "section": "Takeaways",
    "text": "Takeaways\n\nPure math consists of definitions, propositions, and examples.\nThese are specified in enough detail so that participants in a mathematical conversation could independently come up with equivalent elaborations.\nIf you feel you could not do this at any point, then you are in a perfectly normal situation and should not feel ashamed whatsoever. However, continuing on without first going back and understanding what you are confused about is a bad idea."
  },
  {
    "objectID": "lecture1.html#takeaways-1",
    "href": "lecture1.html#takeaways-1",
    "title": "Lecture 1: Formal Math",
    "section": "Takeaways",
    "text": "Takeaways\n\nA finite set is a list of things\nA morphism of finite sets from A to B sends each unique element of A to an element of B\nThere are multiple ways of implementing representations of finite sets and morphisms between them on the computer"
  },
  {
    "objectID": "lecture2.html",
    "href": "lecture2.html",
    "title": "Lecture 2: The Category Theory of Finite Sets",
    "section": "",
    "text": "Composition and Isomorphisms\nWe now introduce the operation at the core of all category theory: composition!\nWe now come to an issue that is everywhere in category theory: equality. If you have seen any set theory before, you might think that \\{1,2,3,3\\} and \\{3,2,1\\} are ‚Äúthe same‚Äù set. Note however that when I defined finite set, I just said that a finite set was a list of things surrounded by curly braces.\nSo it seems like something is wrong with our definition.\nBut let‚Äôs think about why we typically choose to make \\{1,2,3,3\\} and \\{3,2,1\\} ‚Äúthe same‚Äù set. One good reason is that any morphism out of \\{1,2,3,3\\} can be seen as a morphism out of \\{3,2,1\\}, and the same goes for incoming morphisms.\nTherefore, from a ‚Äúmorphism‚Äôs-eye‚Äù perspective, \\{1,2,3,3\\} and \\{3,2,1\\} behave the exact same way; defining a morphism out of one is the same as defining a morphism out of the other.\nBut if we take this to its logical conclusion, we find that this is true not only of \\{1,2,3,3\\} and of \\{3,2,1\\}, but also of \\{1,2,3\\} and \\{\\mathbf{a},\\mathbf{b},\\mathbf{c}\\}!\nTo see this, let B = \\{1,2,3\\}, B^\\prime = \\{\\mathbf{a}, \\mathbf{b}, \\mathbf{c}\\}, and define f \\colon B \\to B^\\prime and g \\colon B^\\prime \\to B by\nf(x) = \\begin{cases}\n  \\mathbf{a} & \\text{if $x = 1$} \\\\\n  \\mathbf{b} & \\text{if $x = 2$} \\\\\n  \\mathbf{c} & \\text{if $x = 3$}\n\\end{cases}\ng(y) = \\begin{cases}\n  1 & \\text{if $y = \\mathbf{a}$} \\\\\n  2 & \\text{if $y = \\mathbf{b}$} \\\\\n  3 & \\text{if $y = \\mathbf{c}$}\n\\end{cases}\nThen given h \\colon B \\to C, we can produce h^\\prime \\colon B^\\prime \\to C via h^\\prime = h \\circ g, and vice versa. Moreover, when we start out with a function out of B, compose it with g to make a function out of B^\\prime and then compose it with f to make a function out of B, we get the same function back.\nAll of this motivates the next few definitions.\nYou can remember the reasoning for why the name ‚Äúisomorphic‚Äù by thinking ‚Äúisomorphic = same morphisms‚Äù. That is, if we have an isomorphism between A and A^\\prime, then there are ‚Äúthe same morphisms‚Äù out of A and out of A\\prime.\nHowever, as noted before, there might be several distinct isomorphisms between A and A^\\prime. Thus, one must be careful to specify which isomorphism when you are talking about isomorphic finite sets.\nAnyways, this is why it‚Äôs not a terrible problem to use a vector to represent a finite set. There are only rare cases where you can find a representation of your mathematical objects such that two representations are equal if and only if the mathematical objects are isomorphic. If you are lucky enough to find this, it‚Äôs called a ‚Äúcanonical form‚Äù and it‚Äôs a big deal. As a practical matter, we might use Set instead of Vector because it gets a bit closer to a canonical form, but I wanted to start with Vector to make the point that the representation of your mathematical object on a computer in general will not be canonical.\nWe now discuss some more properties of finite sets and their maps.\nThis is a good opportunity to discuss something very critical in math: ordering of quantifiers. Quantifiers are phrases like ‚Äúfor every ‚Ä¶‚Äù or ‚Äúthere exists ‚Ä¶‚Äù. In the previous definition, if we had instead said ‚Äúthere exists an a \\in A such that for every b \\in B, f(a) = b‚Äù, this could only be true if B had only a single element! The fact that the ‚Äúthere exists‚Äù comes after the ‚Äúfor every‚Äù allows us to choose a different a for each b.\nWe wrap up this section with a way of telling when there exists any isomorphisms between two finite sets.\nThe point of this first lecture is to introduce you to finite sets and pure math, not category theory. Therefore, we end with a discussion of a theorem from combinatorics."
  },
  {
    "objectID": "lecture2.html#takeaways",
    "href": "lecture2.html#takeaways",
    "title": "Lecture 2: The Category Theory of Finite Sets",
    "section": "Takeaways",
    "text": "Takeaways\n\nYou can compose morphisms between finite sets\nIsomorphisms tell you which finite sets are equivalent from the point of view of morphisms"
  },
  {
    "objectID": "lecture2.html#takeaways-1",
    "href": "lecture2.html#takeaways-1",
    "title": "Lecture 2: The Category Theory of Finite Sets",
    "section": "Takeaways",
    "text": "Takeaways\n\nThere are two special classes of functions: injections and surjections\nIf something is an injection and a surjection, it is an isomorphism\nYou can tell which finite sets are isomorphic by looking at their cardinalities"
  },
  {
    "objectID": "lecture2.html#takeaways-2",
    "href": "lecture2.html#takeaways-2",
    "title": "Lecture 2: The Category Theory of Finite Sets",
    "section": "Takeaways",
    "text": "Takeaways\n\nYou can do basic combinatorics in the framework we have developed in this lecture"
  },
  {
    "objectID": "lecture3.html",
    "href": "lecture3.html",
    "title": "Lecture 3: Category Theory",
    "section": "",
    "text": "Julia from last lecture\n\n\nabstract type ùîΩ end\n\nstruct VecùîΩ &lt;: ùîΩ\n  elems::Vector{Any}\nend\n\nBase.:(‚àà)(a, A::VecùîΩ) = a ‚àà A.elems\n\nBase.iterate(A::VecùîΩ) = iterate(A.elems)\nBase.iterate(A::VecùîΩ, k) = iterate(A.elems, k)\nBase.length(A::VecùîΩ) = length(A.elems)\n\nstruct IntùîΩ &lt;: ùîΩ\n  n::Int\nend\n\nBase.:(‚àà)(a, A::IntùîΩ) = 1 &lt;= a &lt;= A.n\n\nBase.iterate(A::IntùîΩ) = iterate(1:A.n)\nBase.iterate(A::IntùîΩ, k) = iterate(1:A.n, k)\n\nstruct ùîΩMor\n  dom::ùîΩ\n  codom::ùîΩ\n  vals::Dict{Any,Any}\nend\n\n(f::ùîΩMor)(x) = f.vals[x]\n\nstruct IntùîΩMor\n  dom::IntùîΩ\n  codom::IntùîΩ\n  vals::Vector{Int}\nend\n\n(f::IntùîΩMor)(i) = f.vals[i]\n\n\n\nSets\nToday we will be moving on from finite sets to talk about sets which are possibly infinite. Infinite sets are a controversial topic; they don‚Äôt exist as tangibly as finite sets, and generally are much trickier to compute with. For a mathematician, this is not a problem; they write down formulas for infinite sets in precisely the same way they wrote down formulas for finite sets.\nThe crucial difference between finite sets and infinite sets is that any ‚Äúfor all‚Äù statement on an infinite set is not checkable by listing out every element of the set and checking that a property holds of each of them. Relatedly, any ‚Äúexists‚Äù statement is likewise not checkable. This seems kind of obvious, but it means that naive extensions of algorithms from the case of finite sets to the case of infinite sets often fails.\nThus, on a computer infinite sets have a very different feel than finite sets.\nIn traditional foundations, everything is built out of sets. But, as we said in the previous lecture, this is unnecessarily strict. We are instead taking Julia to be our foundation, so that we will have primitive things that are not themselves sets. This is a much saner foundation, because while it might be technically possible to build, say, a real number out of sets, nobody really wants to do that.\n\nA set X consists of a function from Any to Bool, which may or either be written in Julia or defined mathematically. If X(x) = \\mathbf{true}, we write x \\in X, and if X(x) = \\mathbf{false} we write x \\notin X.\n\nNote that when we write down Julia definitions involving sets, we are implicitly assuming that the functions are written in Julia. However, there are some sets that we will use whose functions cannot be written down in Julia, so take the Julia definitions with a grain of salt. If the function defining a set can be written in Julia, we say that set is computable, and otherwise the set is uncomputable.\nObviously, we can only model the computable sets in Julia, but the uncomputable sets are still useful for talking about Julia.\n\nabstract type ComputableSet end\n\n# We expect any subtype of ComputableSet to have in defined on it.\nBase.in(x, s::ComputableSet) = error(\"no specific definition found\")\n\n\nFor any finite set A, let \\chi_{A} be defined by \\chi_{A}(x) = \\mathbf{true} if x is listed in A and \\mathbf{false} otherwise. Then \\chi_{A} is a set.\n\n\nAny Julia type T defines a set, via the function which checks whether a Julia value has that type.\n\n\nstruct FiniteSet &lt;: ComputableSet\n  A::ùîΩ\nend\n\nBase.in(x, œá::FiniteSet) = x ‚àà œá.A\n\nstruct TypeSet &lt;: ComputableSet\n  T::Type\nend\n\nBase.in(x, œá::TypeSet) = x isa œá.T\n\n\nGiven two sets A and B, the set A \\to B consists of all Julia callables f such that f(a) \\in B for all a \\in A. Note that\n\nNote that even if A and B are computable sets, there is no way to check in Julia that a given f is an element of A \\to B because this would involve iterating through possibly infinitely many elements of A. Again, languages where this is not the case don‚Äôt have good ODE solvers.\n\nGiven two sets X and Y, their intersection X \\cap Y is defined by\n (X \\cap Y)(x) = X(x) \\wedge Y(x) \nTheir union X \\cup Y is defined by\n (X \\cup Y)(x) = X(x) \\vee Y(x) \n\n\nstruct IntersectionSet\n  X::ComputableSet\n  Y::ComputableSet\nend\n\nBase.in(x, œá::IntersectionSet) = x ‚àà œá.X && x ‚àà œá.Y\n\nstruct UnionSet\n  X::ComputableSet\n  Y::ComputableSet\nend\n\nBase.in(x, œá::UnionSet) = x ‚àà œá.X || x ‚àà œá.Y\n\n\nGiven two sets X and Y, their product X \\times Y is the set of tuples (x,y) where x \\in X and y \\in Y. That is, z \\in X \\times Y if and only if z isa Tuple, length(z) = 2, z[1] \\in X and z[2] \\in Y.\n\n\nproduct(X,Y) = z -&gt; (z isa Tuple) &&\n  length(z) == 2 && X(z[1]) && Y(z[2])\n\n\nWe leave it to the reader to give a mathematical definition for sum given the following definition in Julia\n\n\nstruct Left\n  val::Any\nend\n\nstruct Right\n  val::Any\nend\n\nsum(X,Y) = x -&gt;\n  if x isa Left\n    X(x.val)\n  elseif x isa Right\n    Y(x.val)\n  else\n    false\n  end\n\nWe will now move on to categories. But I would like to make one brief point first, which is that there is no set of all sets. This is because not all sets correspond to Julia values, as we consider uncomputable sets to be sets. But there is a set of all computable sets.\n\n\nCategories\nThe moment we‚Äôve all be waiting for.\n\nA small category C consists of\n\na set C_0 of objects\nfor every x,y \\in C_0, a set \\mathrm{Hom}_C(x,y) of morphisms from x to y\nfor every x,y,z \\in C_0, a composition function \\circ \\colon \\mathrm{Hom}_C(y,z) \\times \\mathrm{Hom}_(x,y) \\to \\mathrm{Hom}(x,z)\nfor every x \\in C_0, an identity morphism 1_x \\in \\mathrm{Hom}_C(x,x)\n\nsuch that\n\nfor all x,y,z,w \\in C_0, f \\in \\mathrm{Hom}_C(x,y), g \\in \\mathrm{Hom}_C(y,z), h \\in \\mathrm{Hom}_C(z,w),  h \\circ (g \\circ f) = (h \\circ g) \\circ f \nfor all x,y \\in C_0, f \\in \\mathrm{Hom}_C(x,y),  1_y \\circ f = f = f \\circ 1_x \n\nThese two laws are called the associativity law and unitality law respectively.\n\n(Julia to be livecoded)\n\nThere is a category \\mathsf{Fin} where the objects are finite sets and the morphisms are morphisms of finite sets, as defined in the previous lecture.\n\n(Julia to be livecoded)\n\nThere is a category where the objects are natural numbers and a morphism from n to m is a n \\times m matrix. Composition of a n \\times m matrix and an m \\times r matrix is done by matrix multiplication.\n\n(Julia to be livecoded)\n\nA graph consists of a finite set of vertices, a finite set of edges, and a source and target map from vertices to edges. Given any graph, there is a ‚Äúfree category‚Äù on that graph, where the objects are vertices and the morphisms are paths.\n\n(Julia to be livecoded)"
  },
  {
    "objectID": "lecture4.html#review-in-kittenlab-syntax",
    "href": "lecture4.html#review-in-kittenlab-syntax",
    "title": "Lecture 4: Functors",
    "section": "Review in Kittenlab syntax",
    "text": "Review in Kittenlab syntax\nIn this lecture, we are finally going to start using the Kittenlab.jl library. We weren‚Äôt using Kittenlab up until now so that I could show you a variety of design tradeoffs, and so that you were learning concepts rather than a specific instantiation of those concepts, but now it becomes worth it to start building up a coherent library instead of starting from scratch every time.\nWe start by giving the Julia definition of category that we will be using now.\n\nimport Pkg; Pkg.activate(\".\")\ninclude(\"../src/Categories.jl\")\nusing .Categories\n\nThis declares an abstract type for category\nabstract type Category{Ob, Hom} end\nalong with the following methods that should be implemented on any subtype of that abstract type.\n# Note: this is not executed; this is just to show expected type signatures\ndom(c::Category{Ob, Hom}, f::Hom)::Ob\ncodom(c::Category{Ob, Hom}, f::Hom)::Ob\ncompose(c::Category{Ob, Hom}, f::Hom, g::Hom)::Hom\nid(c::Category{Ob, Hom}, x::Ob)::Hom\nIn Kittenlab, we have chosen a ‚Äúmiddle path‚Äù between having everything be fully dynamic and trying to put as much as possible into the type system. We use the Julia type system to guide our implementations, to provide documentation, and to resolve dispatch, but we do not rely on it for correctness.\nIf C is a subtype of Category{Ob,Hom}, then we expect that the set of objects for any element of C to be a subset of Ob.\nMoreover, we expect the hom-set from x :: Ob to y :: Ob to be some subset of the elements f :: Hom with dom(c, f) == x and codom(c, f) == y.\nThis ‚Äúmiddle path‚Äù is fairly convenient, because often there is a good choice of the types Ob and Hom that makes the category fairly ergonomic to use, in that most or all of the elements of Ob are actually objects of the category, and the same for Hom. Additionally, having more specific types will allow Julia to produce more efficient code.\nWe use slightly different definitions for the category of finite sets, following these principles.\n\ninclude(\"../src/FinSets.jl\")\nusing .FinSets\n\nNamely, we declare\nconst FinSet = AbstractSet\n\nstruct FinFunction{S,T}\n  dom::FinSet{S}\n  codom::FinSet{T}\n  values::AbstractDict{S,T}\nend\nWe simplified our design hierarchy in one way (removing the abstract types), and complicated it in another way (adding type parameters); this is a more pragmatic and less flexible approach.\nWe now declare a category of finsets and finfunctions to go along with this:\nstruct FinSetC &lt;: Category{FinSet, FinFunction}\nend\n\nCategories.dom(::FinSetC, f::FinFunction) = f.dom\n\nCategories.codom(::FinSetC, f::FinFunction) = f.codom\n\nfunction Categories.compose(\n  ::FinSetC,\n  f::FinFunction{S,T}, g::FinFunction{T,R}\n) where {S,T,R}\n  @assert f.codom == g.dom\n  FinFunction(f.dom, g.codom, Dict(x =&gt; g(f(x)) for x in f.dom))\nend\n\nfunction Categories.id(::FinSetC, X::FinSet{S}) where {S}\n  FinFunction{S,S}(X,X,Dict(x =&gt; x for x in X))\nend\nHopefully, at this point the new conventions that we are using should make sense, so we are going to move on to functors!"
  },
  {
    "objectID": "lecture4.html#functors",
    "href": "lecture4.html#functors",
    "title": "Lecture 4: Functors",
    "section": "Functors",
    "text": "Functors\nCategory theory is all about studying the objects of a category by studying the morphisms between them. So consequently, the study of functors (which are the morphisms between categories) is critical to the studying of categories!\n\nLet \\mathsf{C} and \\mathsf{D} be categories. A functor F from \\mathsf{C} to \\mathsf{D}, often written F \\colon \\mathsf{C} \\to \\mathsf{D}, consists of:\n\nA function F_0 \\colon \\mathsf{C}_0 \\to \\mathsf{D}_0. If x \\in \\mathsf{C}_0, we often write F_0(x) as F(x).\nFor every x,y \\in \\mathsf{C}_0, a function F_{x,y} \\colon \\mathrm{Hom}_{\\mathsf{C}}(x,y) \\to \\mathrm{Hom}_{\\mathsf{D}}(F(x),F(y)). If f \\in \\mathrm{Hom}_{\\mathsf{C}}(x,y), we often write F_{x,y}(f) as F(f).\n\nsuch that the following two laws hold:\n\nFor all x \\in \\mathsf{C}_0, 1_{F(x)} = F(1_x)\nFor all x,y,z \\in \\mathsf{C}_0, f \\colon x \\to y, g \\colon y \\to z, F(g \\circ f) = F(g) \\circ F(f).\n\n\nWe implement this with the following Julia.\n\ninclude(\"../src/Functors.jl\")\nusing .Functors\n\nThe declaration of functor is the following.\nabstract type Functor{C&lt;:Category, D&lt;:Category} end\n\nfunction ob_map(F::Functor{C,D}, x::ObC)::ObD where\n    {ObC, ObD, C&lt;:Category{ObC}, D&lt;:Category{ObD}}\n  error(\"unimplemented\")\nend\n\nfunction hom_map(F::Functor{C,D}, f::HomC)::HomD where\n    {ObC, HomC, ObD, HomD, C&lt;:Category{ObC, HomC}, D&lt;:Category{ObD, HomD}}\n  error(\"unimplemented\")\nend\n \n# KittenC is the category of Julia-implemented categories and functors\n\nstruct KittenC &lt;: Category{Category, Functor}\nend\n\nfunction Categories.dom(::KittenC, F::Functor{C,D})::C where {C,D}\n  error(\"unimplemented\")\nend\n\nfunction Categories.codom(::KittenC, F::Functor{C,D})::D where {C,D}\n  error(\"unimplemented\")\nend\nThere are some critical subtleties in this declaration.\nFirst of all, functor is an abstract type parameterized by the types of its domain and codomain categories. Crucially, it is not parameterized by the domain and codomain categories! In the case that these types are singletons, this is an academic distinction. But later on, we will have structs that are subtypes of Category that are not singletons, where there is dynamic data in the category, and then dom and codom will be meaningful. The reason we have the types of the categories in the abstract type for functor is that we can then extract the types of the objects and morphisms for each category.\nSecondly, we have declared a category KittenC of categories and functors. Technically speaking, this is the category of ‚Äúcategories and functors that are implemented in Julia‚Äù; we reserve the category \\mathsf{Cat} for the category of all (small) categories. But this category is not complete yet: we need to be able to compose functors and take identity functors!\nWe first handle this mathematically.\n\nGiven three categories \\mathsf{C}, \\mathsf{D} and \\mathsf{E}, along with two functors F \\colon \\mathsf{C} \\to \\mathsf{D} and G \\colon \\mathsf{D} \\to \\mathsf{E}, there is a functor G \\circ F \\colon \\mathsf{C} \\to \\mathsf{E} defined in the following way.\n\nFor x \\in \\mathsf{C}_0, (G \\circ F)(x) = G(F(x))\nFor x,y \\in \\mathsf{C}_0, f \\colon x \\to y, (G \\circ F)(f) = G(F(f))\n\nWe now show that G \\circ F preserves composition and identities. Suppose that x \\in \\mathsf{C}_0. Then\n(G \\circ F)(1_x) = G(F(1_x)) = G(1_{F(x)}) = 1_{G(F(x))} = 1_{(G \\circ F)(x)}\nMoreover, if x,y,z \\in \\mathsf{C}_0, and r \\colon x \\to y and s \\colon y \\to z, then\n(G \\circ F)(s \\circ r) = G(F(s \\circ r)) = G(F(s) \\circ F(r)) = G(F(s)) \\circ G(F(r)) = (G \\circ F)(s) \\circ (G \\circ F)(r)\nWe are done.\n\n\nGiven any category \\mathsf{C}, there is a functor 1_{\\mathsf{C}} \\colon \\mathsf{C} \\to \\mathsf{C} defined in the following way.\n\nFor x \\in \\mathsf{C}_0, 1_{\\mathsf{C}}(x) = x\nFor x,y \\in \\mathsf{C}_0, f \\colon x \\to y, 1_{\\mathsf{C}}(f) = f\n\nWe leave it to the reader to show that this preserves identities and compositions. This is really easy if you can just state what you have to prove, but it might be tricky to state what you have to prove! So that would be a good exercise.\n\nIn Julia, we represent this all with the following data structures.\nstruct ComposedFunctor{C&lt;:Category,D&lt;:Category,E&lt;:Category} &lt;: Functor{C,E}\n  F::Functor{C,D}\n  G::Functor{D,E}\nend\n\nob_map(FG::ComposedFunctor, x) = ob_map(FG.G, ob_map(FG.F, x))\nhom_map(FG::ComposedFunctor, f) = hom_map(FG.G, hom_map(FG.F, f))\n\nCategories.dom(c::KittenC, FG::ComposedFunctor) = dom(c, FG.F)\nCategories.codom(c::KittenC, FG::ComposedFunctor) = codom(c, FG.G)\n\nfunction Categories.compose(\n  c::KittenC,\n  F::Functor{C,D}, G::Functor{D,E}\n) where {C,D,E}\n  @assert codom(c, F) == dom(c, G)\n  ComposedFunctor{C,D,E}(F,G)\nend\n\nstruct IdFunctor{C&lt;:Category}\n  c::C\nend\n\nob_map(I::IdFunctor, x) = x\nhom_map(I::IdFunctor, f) = f\n\nCategories.dom(::KittenC, F::IdFunctor) = F.c\nCategories.codom(::KittenC, F::IdFunctor) = F.c\n\nCategories.id(::KittenC, c::Category) = IdFunctor(c)"
  },
  {
    "objectID": "lecture4.html#examples-of-functors",
    "href": "lecture4.html#examples-of-functors",
    "title": "Lecture 4: Functors",
    "section": "Examples of Functors",
    "text": "Examples of Functors\nThis is the livecoding section! We are going to implement a functor between two categories. Unfortunately, this functor won‚Äôt be terribly interesting, because we haven‚Äôt met too many categories yet! But soon we will meet more categories, and we will be able to talk about many more functors.\nRecall from last lecture the category of matrices, \\mathsf{Mat}, where the objects are natural numbers and a morphism from n to m is a n \\times m matrix. Composition is matrix multiplication!\nThere is a category \\mathsf{Fin} where the objects are natural numbers and a morphism from n to m is a function from \\{1,\\ldots,n\\} to \\{1,\\ldots,m\\}.\nWe make a functor F from \\mathsf{Fin} to \\mathsf{Mat} that is the identity on objects, and sends a function f \\colon \\{1,\\ldots,n\\} \\to \\{1,\\ldots,m\\} to the n \\times m matrix that has a 1 at index (i, f(i)) for each i \\in \\{1,\\ldots,n\\}, and 0s elsewhere.\nWe must show that F preserves composition and identites.\nWe start with identities. The identity function 1_n \\colon \\{1,\\ldots,n\\} \\to \\{1,\\ldots,n\\} turns into the matrix with a 1 at index (i,i) for every i, and 0 elsewhere, which is the identity matrix.\nNow, fix n,m,\\ell, let f \\colon \\{1,\\ldots,n\\} \\to \\{1,\\ldots,m\\} and g \\colon \\{1,\\ldots,m\\} \\to \\{1,\\ldots,\\ell\\}, and let A = F(f) and B = F(g). Then fix i,k and consider the expression for matrix multiplication.\n (AB)_{ik} = \\sum_{j=1}^{m} A_{ij} B_{jk} \nNote that A_{ij} = 1 only when f(i) = j, and B_{jk} = 1 only when g(j) = k. So the only way that both of them are non-zero for the same j is when j = f(i) and k = g(j), or in other words k = (g \\circ f)(i). We are done."
  },
  {
    "objectID": "lecture5.html#preorders",
    "href": "lecture5.html#preorders",
    "title": "Lecture 5: A Variety of Categories and Functors",
    "section": "Preorders",
    "text": "Preorders\n\nA preorder consists of\n\nA set X\nA function \\leq \\colon X \\times X \\to \\{\\top, \\bot\\} (which is how we write true and false in math)\n\nsuch that\n\nFor all x \\in X, x \\leq x\nFor all x,y,z \\in X, if x \\leq y and y \\leq z, then x \\leq z.\n\n\n\nabstract type Preorder{T} end\n\n# leq(p::Preorder{T}, x::T, y::T)::Bool\n\n\nLet A be a finite set. A subset of A is a finite set containing only elements of A. Equivalently, a subset of A is a function A \\to \\{\\top, \\bot\\}.\nThe set of subsets of A is a preorder, where U \\leq V if every element of U is an element of V.\n\n\nfunction subsetof(U::FinSet{T}, A::FinSet{T}) where {T}\n  all(x ‚àà A for x in U)\nend\n\nstruct SubsetPreorder{T} &lt;: Preorder{FinSet{T}}\n  A::FinSet{T}\nend\n\nfunction leq(p::SubsetPreorder{T}, U::FinSet{T}, V::FinSet{T}) where {T}\n  @assert subsetof(U,p.A)\n  @assert subsetof(V,p.A)\n  subsetof(U,V)\nend\n\n\nThe real numbers, \\mathbb{R}, are a partially ordered set, using the standard ordering.\n\n\nstruct RealPreorder &lt;: Preorder{Float64}\nend\n\nleq(::RealPreorder, x::Float64, y::Float64) = x &lt;= y\n\n\nGiven any preorder (X,\\leq), there is a category with objects X and\n\nPrecisely one morphism from x to y if x \\leq y\nNo morphisms from x to y if x \\nleq y (if x is not less than y).\n\n\nIn fact, we can take this as an alternative definition of preorder: a preorder is a category where there is either one or zero morphisms between any two objects. The idea is that a morphism from x to y ‚Äúwitnesses‚Äù the fact that x \\leq y.\nWe express this with Julia.\n\nstruct PreorderMorphism{T,P&lt;:Preorder{T}}\n  p::P\n  dom::T\n  codom::T\n  function PreorderMorphism(p::Preorder{T}, dom::T, codom::T) where {T}\n    # We can only create this morphism if dom ‚â§ codom\n    @assert leq(p, dom, codom)\n    new{T,typeof(p)}(p, dom, codom)\n  end\nend\n\nstruct PreorderAsCat{T,P&lt;:Preorder{T}} &lt;: Category{T,PreorderMorphism{T,P}}\n  p::P\nend\n\nCategories.dom(::PreorderAsCat{T,P}, f::PreorderMorphism{T,P}) where {T,P} = f.dom\nCategories.codom(::PreorderAsCat{T,P}, f::PreorderMorphism{T,P}) where {T,P} = f.codom\n\nCategories.id(c::PreorderAsCat{T,P}, x::T) where {T,P} = PreorderMorphism(c.p, x, x)\nCategories.compose(\n  c::PreorderAsCat{T,P},\n  f::PreorderMorphism{T,P},\n  g::PreorderMorphism{T,P}\n) where {T,P} = PreorderMorphism(c.p, f.dom, g.codom)\n\nLet us now determine what a functor between two preorders would be, if we understand those preorders as categories.\n\nA functor between preorders X and Y simply consists of a function F \\colon X \\to Y such that if x \\leq x' for x,x' \\in X, then F(x) \\leq F(x').\n\n\nProof. If there is a morphism f from x to y, then there must exist a morphism F(f) from f(x) to f(y). Moreover, F can send morphisms to only one place, so it must preserve composites and identities.\n\nWe call a functor between preorders an order-preserving map.\n\nThere is a category \\mathsf{Preorder} of where the objects are preorders and the morphisms are order-preserving maps.\n\nWe said that we can view preorders as categories. Let‚Äôs make this statement precise.\n\nIf \\mathsf{C} is a category, then a subcategory \\mathsf{D} of \\mathsf{C} consists of a subset \\mathsf{D}_{0} \\subset \\mathsf{C}_{0} of objects, and for each x,y \\in \\mathsf{D}_{0}, a subset \\mathrm{Hom}_{\\mathsf{D}}(x,y) \\subset \\mathrm{Hom}_{\\mathsf{C}}(x,y) of morphisms, such that\n\nAll identities are in \\mathsf{D}\nThe composite of morphisms in \\mathsf{D} is again in \\mathsf{D}\n\nIf \\mathsf{D}_{0} = \\mathsf{C}_{0}, we call \\mathsf{D} wide, and if \\mathrm{Hom}_{D}(x,y) = \\mathrm{Hom}_{C}(x,y) for all x,y \\in \\mathsf{D}_{0}, we call \\mathsf{D} full. The only wide, full subcategory is \\mathsf{C} itself.\n\nWe now state the following proposition\n\n\\mathsf{Preorder} is a full subcategory of \\mathsf{Cat}.\n\nNow is when something very subtle comes into play. We have two different definitions of preorder, which are in some sense equivalent, but the way we have stated definitions, one of these definitions would make the previous proposition true, and another of those definitions would make the previous proposition false. Specifically, if we say that a preorder is a category with the property that each hom-set is a singleton or empty, then the set of preorders is literally a subset of the set of (small) categories. However, if we say that a preorder is a set with a function to Bool, then this is not true! Concretely, it is not true that Preorder &lt;: Category, it‚Äôs just that we can construct a category out of a preorder!\nIt is for this reason in category theory that we take a slightly generalized notion of ‚Äúsubobject‚Äù. Instead of using subset, where the elements of set A have to be contained in set B, we just require there to be an injection from A to B! So we say that a subcategory of \\mathsf{C} is just another category \\mathsf{D} that has an injective functor into \\mathsf{C}.\nThis follows from a more general principle that we should not distinguish between isomorphic objects. I.e., if we have an injective functor into \\mathsf{C}, then \\mathsf{D} is isomorphic to the image of that functor, which is a literal subset of \\mathsf{C}.\nNow that we have made this pedantic and subtle point, we will follow convention in category to ignore it, and say things like \\mathsf{Preorder} is a full subcategory of \\mathsf{Cat} without caring about the precise definition of preorder we have chosen.\nWith this out of the way, we now talk about a menagerie of functors. In category theory, often functors are described by what they do on objects, and their action on morphisms is inferred. This makes a good exercise for the reader; see if you can tell what the action on morphisms of each of the following functors is.\n\nThere is a functor \\mathsf{Preorder} \\to \\mathsf{Cat} that simply sends a preorder to that preorder viewed as a category, as we discussed before.\nThere is a functor \\mathsf{Cat} which sends a category \\mathsf{C} to the preorder with the objects of \\mathsf{C}, and x \\leq y if and only if \\mathrm{Hom}_{\\mathsf{C}}(x,y) is non-empty.\nThere is a functor \\mathsf{Preorder} \\to \\mathsf{Set} which simply sends a preorder to its underlying set.\nThere is a functor \\mathsf{Set} \\to \\mathsf{Preorder} which sends a set X to the preorder with underlying set X where x \\leq y if and only if x = y. Such a preorder is known as a discrete preorder.\nThere is a functor \\mathsf{Set} \\to \\mathsf{Preorder} which sends a set X to the preorder with underlying set X where x \\leq y always. Such a preorder is known as a codiscrete preorder.\n\nTo sum up, preorders are a special case of categories, where there is at most one morphism between any two objects. We now move on to another special case of categories."
  },
  {
    "objectID": "lecture5.html#monoids",
    "href": "lecture5.html#monoids",
    "title": "Lecture 5: A Variety of Categories and Functors",
    "section": "Monoids",
    "text": "Monoids\nPreorders are an ‚Äúextreme‚Äù example of categories, where there are lots of objects, but very few morphisms. The other extreme is monoids, where there is only one object, but plenty of morphisms. We start with the classical definition of morphism.\n\nA monoid is a set M along with a binary operation \\ast \\colon M \\times M \\to M and an element e \\in M such that:\n\nFor all a,b,c \\in M, (a \\ast b) \\ast c = a \\ast (b \\ast c)\nFor all a \\in M, a \\ast e = a = e \\ast a\n\nWe call e the unit or identity element of the monoid, and \\ast the multiplication.\n\n\nabstract type Monoid{T} end\n\n# mul(m::Monoid{T}, x::T, y::T)::T\n# ident(m::Monoid{T})::T\n\n\nLet A be an alphabet, and let A^{\\ast} be the set of strings on that alphabet. For instance, if A = \\{a,b,c\\}, then A^{\\ast} = \\{[],[a],[b],[c],[aa],[ab],[ac],[ba],\\ldots\\}. Then if we define \\ast to be ‚Äúconcatenation‚Äù, i.e.¬†[ab] \\ast [cba] = [abcba], and if we define e = [], (A^{\\ast},\\ast,[]) is a monoid.\n\n\nstruct ConcatMonoid{T} &lt;: Monoid{Vector{T}}\n  alphabet::Set{T}\nend\n\nfunction mul(m::ConcatMonoid{T}, xs::Vector{T}, ys::Vector{T}) where {T}\n  @assert all(x ‚àà m.alphabet for x in xs)\n  @assert all(y ‚àà m.alphabet for y in xs)\n  [xs; ys]\nend\nident(::ConcatMonoid{T}) where {T} = T[]\n\n\nAny of \\mathbb{N},\\mathbb{Z},\\mathbb{Q},\\mathbb{R},\\mathbb{C} with + or \\cdot is a monoid.\n\n\nThe set of n \\times n matrices with either matrix multiplication, element-wise multiplication, or element-wise addition is a monoid.\n\n\nThe set of subsets of some fixed set A with either intersection or union is a monoid. The unit of intersection is A, and the unit of union is \\emptyset.\n\n\nA monoid is precisely the same thing as a category with only a single object.\n\n\nProof. Suppose that \\mathsf{C} is a category with one object x. Then \\mathsf{Hom}_{\\mathsf{C}}(x,x) is a monoid with multiplication \\circ and unit 1_x. Conversely, if M is a monoid, we can construct a category with one object x, and \\mathsf{Hom}_{\\mathsf{C}}(x,x) = M, with \\circ = \\ast and 1_x = e.\n\nMoreover, a functor between two monoids viewed as categories is a simply a function F \\colon M \\to N such that F(a \\ast b) = F(a) \\ast F(b), as the single object of the monoid has only one place to go!\nLet \\mathsf{Mon} be the category of monoids. Then there are a bunch of functors between \\mathsf{Mon} and our old familiar categories.\n\nThere is a functor \\mathsf{Mon} \\to \\mathsf{Cat} which sends a monoid to that monoid viewed as a category.\nThere is a functor \\mathsf{Mon} \\to \\mathsf{Set} which sends a monoid to its underlying set.\nThere is a functor \\mathsf{Set} \\to \\mathsf{Mon} which sends a set A to the monoid A^{\\ast} of strings on the alphabet A."
  },
  {
    "objectID": "lecture6.html#graphs",
    "href": "lecture6.html#graphs",
    "title": "Lecture 6: Path categories and functors as data structures",
    "section": "Graphs",
    "text": "Graphs\n\nA graph G consists of the following.\n\nA finite set G(V) of vertices\nA finite set G(E) of edges\nA function G(\\mathrm{src}) \\colon G(E) \\to G(V) called the source map\nA function G(\\mathrm{tgt}) \\colon G(E) \\to G(V) called the target map\n\n\nYou can think about this like a ‚Äúdatabase‚Äù with two tables, one table for edges and one table for vertices. The vertex table has only a primary key column, and the edge table has two foreign key columns in addition to a primary key column.\n\n\n\n\n\nA graph as a database\n\n\n\n\n\nArad to Bucharest\n\n\nFigure¬†1: Two illustrations of graphs. The first is a simple graph, translated into two ‚Äúdatabase tables‚Äù on the right as well. The second is a classic graph from computer science: major towns and cities in Romania. This graph is often used for search problems; finding the shortest path from Arad to Bucharest and for some reason is one of my favorite graphs.\n\n\nNotice that we allow multiple edges between a single pair of vertices, and also edges from a vertex to itself.\nIn Julia, we can represent this in the following way.\nstruct Graph\n  vertices::FinSet{Int}\n  edges::FinSet{Int}\n  src::FinFunction{Int,Int}\n  tgt::FinFunction{Int,Int}\nend\nNote that graphs seem somewhat similar to categories; vertices are analogous to objects and edges are analogous to morphisms. The important difference is that categories have composition and identities, and graphs don‚Äôt. There is, however, a way of building a category out of a graph, and that is the subject of the next section."
  },
  {
    "objectID": "lecture6.html#path-categories-and-functors-out-of-them",
    "href": "lecture6.html#path-categories-and-functors-out-of-them",
    "title": "Lecture 6: Path categories and functors as data structures",
    "section": "Path categories and functors out of them",
    "text": "Path categories and functors out of them\n\nIf G is a graph, then a path in G is a list e_{1},\\ldots,e_{n} of edges, such that G(\\mathrm{tgt})(e_{i}) = G(\\mathrm{src})(e_{i+1}) for i=1,\\ldots,n-1. We say that the path goes from G(\\mathrm{src})(e_{1}) to G(\\mathrm{tgt})(e_{n}).\n\n\nWe can make a path from Arad to Bucharest by going\nArad -&gt; Sibiu -&gt; Fagaras -&gt; Bucharest\n\n\nIf G is a graph, then given a path e_{1},\\ldots,e_{n} from a vertex a to a vertex b, and a path e_{1}^{\\prime},\\ldots,e_{m}^{\\prime} from b to another vertex c, we can construct a path e_{1},\\ldots,e_{n},e_{1}^{\\prime},\\ldots,e_{m}^{\\prime} from a to b.\n\nWhen you hear the word ‚Äúcompose‚Äù your eyes should light up and think ‚ÄúOh, is this a category?‚Äù And in this case, it is!\n\nFor any graph G, there is a category \\mathrm{Path}(G), where the objects are vertices in G and a morphism from a vertex a to a vertex b is a path from a to b in G. Composition is as it was in the proposition above, i.e.¬†list concatenation, and the identity on a vertex is simply the empty list.\n\nWhenever you see something that constructs something from another thing, you should think ‚Äúis this a functor‚Äù? And it turns out that \\mathrm{Path} is in fact a functor from the category of graphs to the category of categories. However, in order to write this down properly, we have to define the category of graphs, and we aren‚Äôt quite ready to do that yet (we will do it by the end of this lecture, though).\nThe category \\mathrm{Path}(G) has a special property. Namely, in order to define a functor F from \\mathrm{Path}(G) to a category \\mathsf{C}, all you have to do is pick an object F(v) \\mathsf{C} for every vertex v \\in G(V), and then pick a morphism F(e) \\colon F(G(\\mathrm{src})(e)) \\to F(G(\\mathrm{tgt})(e)) for every edge e \\in G(E).\nThen where do you send a path e_{1},\\ldots,e_{n}? Well, you just send it to the composite morphism F(e_{n}) \\circ \\cdots \\circ F(e_{1})! It turns out that any choice of the F(e) works for this; you get preservation of composition ‚Äúfor free‚Äù!\nSo it‚Äôs particularly easy to define a functor coming out of \\mathrm{Path}(G), and it‚Äôs also particularly easy to store such a functor: we just store an object for every vertex of G and a morphism for every edge.\nWe call a functor from \\mathrm{Path}(G) to \\mathsf{Set} an acset, pronounced to rhyme with ‚Äúhatchet‚Äù. Other terminology you might see (and the etymology for acset) is C-set or copresheaf. However, this can be confusing because sometimes the ‚ÄúC‚Äù in C-set refers to \\mathrm{Path}(G), but sometimes we just use C-set as a word. I like to use ‚Äúacset on schema C‚Äù instead of C-set, because then I can just say ‚Äúacset‚Äù without having to define C first. And copresheaf is just unnecessarily fancy. We say ‚Äúschema‚Äù here, because you can think of \\mathsf{C} = \\mathrm{Path}(G) as a ‚Äúdatabase schema‚Äù; we‚Äôll see more about this later.\nStrictly speaking, there‚Äôs more to an acset than what we just presented; the ‚Äúa‚Äù in acset stands for ‚Äúattributed‚Äù. But we will cover this later; functors from \\mathrm{Path}(G) to \\mathsf{Set} are a special case of acsets.\nWe will now look at some examples!"
  },
  {
    "objectID": "lecture6.html#graphs-1",
    "href": "lecture6.html#graphs-1",
    "title": "Lecture 6: Path categories and functors as data structures",
    "section": "Graphs",
    "text": "Graphs\nFirst of all, we can go meta and define graphs themselves this way!\nConsider the following graph G.\n\n\n\nGraph schema\n\n\nWe let \\mathsf{Gr} = \\mathrm{Path}(G). Then an acset on \\mathsf{Gr} is a graph. Using graphs to define graphs is pretty trippy, but fortunately we can ‚Äúclose the loop‚Äù because our original definition of graph didn‚Äôt rely on any of this notation. Notice that we have been using the notation for a functor out of \\mathsf{Gr} all along however!"
  },
  {
    "objectID": "lecture6.html#petri-nets",
    "href": "lecture6.html#petri-nets",
    "title": "Lecture 6: Path categories and functors as data structures",
    "section": "Petri nets",
    "text": "Petri nets\nConsider the following graph G.\n\n\n\nPetri net schema\n\n\nWe let \\mathsf{Petri} = \\mathrm{Path}(G). Then an acset on \\mathsf{Petri} is a petri net.\nExamples of Petri nets:\n\n\n\nSIR model\n\n\n\n\n\nLotka-Volterra model"
  },
  {
    "objectID": "lecture6.html#wiring-diagrams",
    "href": "lecture6.html#wiring-diagrams",
    "title": "Lecture 6: Path categories and functors as data structures",
    "section": "Wiring diagrams",
    "text": "Wiring diagrams\nConsider the following graph G.\n\n\n\nDirected port graph schema\n\n\nWe let \\mathsf{DPG} = \\mathrm{Path}(G). Then an acset on \\mathsf{DPG} is a directed port graph.\n\n\n\nDirected port graph\n\n\nWiring diagrams are slightly more complicated, because they also allow incoming and outgoing wires. Wiring diagrams and directed port graphs can be used to model processes."
  },
  {
    "objectID": "lecture6.html#acsets-in-julia",
    "href": "lecture6.html#acsets-in-julia",
    "title": "Lecture 6: Path categories and functors as data structures",
    "section": "ACSets in Julia",
    "text": "ACSets in Julia\n(this part will be livecoded)"
  },
  {
    "objectID": "lecture6.html#sneak-peak-natural-transformations",
    "href": "lecture6.html#sneak-peak-natural-transformations",
    "title": "Lecture 6: Path categories and functors as data structures",
    "section": "Sneak peak: natural transformations",
    "text": "Sneak peak: natural transformations\nWe said before that there is a category of graphs. In this part, we will give a definition of a graph homomorphism that will make this precise. It turns out that this comes from a general definition of natural transformation, which can be defined at the level of functors and categories! However, we will only give a hint at what this is, and leave a full exploration of natural transformations to the next lecture.\n\nA graph homomorphism \\alpha from a graph G to a graph H consists of two maps\n\n\\alpha_{V} \\colon G(V) \\to H(V)\n\\alpha_{E} \\colon G(E) \\to H(E)\n\nsuch that \\alpha_{V} \\circ G(\\mathrm{src}) = H(\\mathrm{src}) \\circ \\alpha_{E} and \\alpha_{V} \\circ G(\\mathrm{tgt}) = H(\\mathrm{tgt}) \\circ \\alpha_{E}.\nThis means that the graph homomorphism has to ‚Äúpreserve sources and targets‚Äù. Just like a functor has to send a morphism from A to B to a morphism from F(A) to F(B), a graph homomorphism has to send an edge from a to b to an edge from \\alpha_V(a) to \\alpha_{V}(b).\nThese conditions can be expressed equivalently as commutative diagrams. Basically, an commutative diagram is a way of writing an equation between composites of morphisms in a category. The equation is that when you compose the morphisms along any path in the diagram, you get the same result.\n\n\n\n\n\n\nIn a future lecture, we will see that these are specific instances of the so-called ‚Äúnaturality squares‚Äù for natural transformations.\n\n\n\n\nThree coloring graph\n\n\n\nA three-coloring of a graph G is a graph homomorphism from G into the graph above. It assigns each vertex of the graph to a color. Notice in a three-coloring, any two vertices connected by an edge must be assigned different colors, because there are no self-edges in the above graph."
  },
  {
    "objectID": "lecture7.html#recap",
    "href": "lecture7.html#recap",
    "title": "Lecture 7: Natural Transformations",
    "section": "Recap",
    "text": "Recap\nBefore we plunge into natural transformations, let‚Äôs briefly review the first six lectures, because it has been a while.\n\nIn lecture 1, we learned about what it means to do formal math, and we we did finite sets in Julia.\nIn lecture 2, we learned about morphisms between finite sets, including composition, surjections, injections, and bijections. We then learned about the idea of cardinality; how two finite sets can be isomorphic but not equal.\nIn lecture 3, we learned how finite sets and functions between them were a special case of a more general concept: a category. In order to do this, we had to first think about what it means to represent an infinite set in Julia, as a function from Any to Bool.\nIn lecture 4, we learned about functors between categories. We implemented a general pattern for functors in Julia, and then implemented a specific functor from the category of finite sets to the category of matrices.\nIn lecture 5, we learned about special cases of categories: partially ordered sets (each partially ordered set is a category, and the collection of all partially ordered sets with order-preserving maps is also a category) and monoids (each monoid is a category, and the collection of all monoids is also a category). Associated with these examples we also have a variety of functors; order-preserving maps are functors, monoid homomorphisms are functors, and we have a bunch of different functors between the categories of monoids, sets, and partial orders.\nFinally, in lecture 6 we learned about C-sets. We first learned about finitely-presented categories, i.e.¬†categories generated by a graph. We then showed that we could think about functors out of these path graph categories as databases, and then we implemented on the fly a version of databases based on this model. We finished by talking about graph homomorphisms.\n\nIn this lecture, we are going to pick up where we left off last time with graph homomorphisms, and talk about general natural transformations."
  },
  {
    "objectID": "lecture7.html#natural-transformations",
    "href": "lecture7.html#natural-transformations",
    "title": "Lecture 7: Natural Transformations",
    "section": "Natural transformations",
    "text": "Natural transformations\nI said before that category theory is unique among mathematics because it is its own metatheory; the collection of all categories forms a category, but the collection of all rings does not form a ring, nor does the collection of all PDEs form a PDE. However, I wasn‚Äôt quite telling the truth, because there is actually more structure to the collection of all categories than just a category.\nWe can not only consider morphisms between categories (i.e.¬†functors), but also morphisms between the functors themselves. We call these natural transformations. More generally, ‚Äúmorphisms that go between morphisms‚Äù are also called 2-morphisms, and we call ordinary morphisms 1-morphisms to contrast.\nThe standard picture for natural transformations is\n\n\n\n\n\nFigure¬†2: The natural transformation \\alpha is meant to look like it ‚Äúgoes between‚Äù F and G\n\n\nHowever, I‚Äôve always thought that this obscured an essential asymmetry to natural transformations, because there is a sense where natural transformations really ‚Äúlive in‚Äù \\mathsf{D}, not in the abstract space between \\mathsf{C} and \\mathsf{D}.\nA more informative picture is this:\n\n\n\n\n\nFigure¬†3: The natural transformation really ‚Äúlives in‚Äù \\mathsf{D}.\n\n\nLooking at that picture already gives you half of the definition of a natural transformation, so we might as well go all the way and give the whole definition.\n\nLet \\mathsf{C} and \\mathsf{D} be categories, and F,G \\colon \\mathsf{C} \\to \\mathsf{D} be functors between them. Then a natural transformation \\alpha \\colon F \\Rightarrow G consists of a morphism \\alpha_{c} \\colon F(c) \\to G(c) for every object c \\in \\mathsf{C}, such the following holds, which is called the naturality condition.\nFor all c,c^{\\prime} \\in \\mathsf{C} and all f \\colon c \\to c^{\\prime}, the bottom square in Figure¬†4 commutes. That is, G(f) \\circ \\alpha_{c} = \\alpha_{c^{\\prime}} \\circ F(f), or in other words, you can follow any path and you get the same result.\n\n\n\n\n\n\nFigure¬†4: The naturality condition\n\n\nThis may seem like a big scary diagram, but I want to convince you that this condition is in fact very‚Ä¶ natural.\nRecall that a graph is a functor into \\mathsf{Set} from the category \\mathsf{Gr} which has two objects V and E, and two non-identity morphisms \\mathrm{src},\\mathrm{tgt} \\colon E \\to V.\nSuppose that G_{1} and G_{2} are graphs, and \\alpha is a natural transformation between them. Then \\alpha consists of two maps: a mapping of edges \\alpha_{E} \\colon G_{1}(E) \\to G_{2}(E) and a mapping of vertices \\alpha_{V} \\colon G_{1}(V) \\to G_{2}(V). The naturality condition for \\mathrm{src} can be written as in Figure¬†5.\n\n\n\n\n\nFigure¬†5: The naturality condition for \\mathrm{src}.\n\n\nWhat does this mean? Well, if we follow the arrows in one way, this says that if we start with an edge in G_{1}(E), map it over to G_{2}(E) following the homomorphism, and then take its source, we get the same thing as if we started by taking its source and then mapped the source over.\nSo the naturality condition is precisely that sources and targets of edges are preserved.\nIf we do Petri nets next, the naturality condition just states that the sources and targets of arcs are preserved.\nThe plan for the live section of this lecture is to implement natural transformations in Julia building off of the implementation of C-sets that we had last time. But first, let‚Äôs give some examples of natural transformations between functors that are not C-sets.\n\nSuppose that f, g \\colon \\mathbb{R} \\to \\mathbb{R} are order-preserving functions, i.e.¬†endofunctors on the poset \\mathbb{R} considered as a category. Then a natural transformation \\alpha \\colon f \\to g would be a morphism f(x) \\to g(x) for every x. As there is at most one morphism f(x) \\to g(x), and it exists only if f(x) \\leq g(x), there is at most one natural transformation f \\Rightarrow g, and it exists only if f(x) \\leq g(x) for all x. Thus, the collection of order-preserving maps \\mathbb{R} \\to \\mathbb{R} is itself a poset.\n\n\nSuppose that G and H are groups, and f,g are functors from G to H when viewed as one-element categories. Then a natural transformation from f to g is a choice of h \\in H such that f(x) h = h g(x) for all x \\in G. Or in other words, f(x) = h g(x) h^{-1}. If H is abelian (meaning that the multiplication is commutative), then this can only happen if f(x) = g(x). However, if H is non-commutative, then this ‚Äúconjugation‚Äù can be non-trivial.\nFor instance, suppose that H is the group of 2x2 real matrices, and G is the group of real numbers. Let f \\colon G \\to H send \\theta \\in \\mathbb{R} to a rotation by \\theta, and g \\colon G \\to H send \\theta to a rotation by -\\theta. Then if h \\in H is the mirror flip around the y axis, f(\\theta) = h g(\\theta) h^{-1}. I encourage the interested reader to work this out by taking points on the unit circle, and rotating and flipping them in sequence.\n\n\nRecall in lecture 5 we defined several functors between \\mathsf{Mon} and \\mathsf{Set}. One of these functors, which we will now call F, sent a set X to the monoid X^{\\ast} of strings on the alphabet X (which you can also think of as lists with elements taken from X). Another functor, which we will now call U, sent a monoid M to its underlying set.\nWe can compose these to get a functor UF \\colon \\mathsf{Set} \\to \\mathsf{Set}. We then define a natural transformation \\eta \\colon 1_{\\mathsf{Set}} \\to UF, where 1_{\\mathsf{Set}} is the identity functor on \\mathsf{Set}. For a set X, \\eta_{X} sends an element x \\in X = 1_{\\mathsf{Set}}(X) to the singleton list [x] \\in X^{\\ast}.\nWe show naturality by recalling what F and U do on morphisms. Essentially, UF takes a morphism f \\colon X \\to Y and ‚Äúmaps it‚Äù over a list [x_{1},\\ldots,x_{n}] to produce [f(x_{1}), \\ldots, f(x_{n})]. So naturality of \\eta is simply saying that taking the singleton of f(x) and mapping f over [x] give the same result.\n\n(live section now)\nRemember, the jupyter notebooks for the live section can be found in the github repository for these lecture notes: Kittenlab.jl."
  },
  {
    "objectID": "lecture8.html#representable-functors",
    "href": "lecture8.html#representable-functors",
    "title": "Lecture 8: Universal Mapping Properties",
    "section": "Representable Functors",
    "text": "Representable Functors\nWe now have all the players in category theory: categories, functors, and natural transformations. But we need something to make them dance together; this thing is called universal mapping properties.\nUniversal mapping properties are the soul of category theory. The idea is that we characterize an object in a category by looking at all the morphisms in or out of that object. There are two ways to do this: look at the morphisms in, and look at the morphisms out. We‚Äôll start with morphisms out.\nFor any object x in a category \\mathsf{C}, there is a functor\n \\operatorname{Hom}_{\\mathsf{C}}(x, -) \\colon \\mathsf{C}\\to \\mathsf{Set}\ncalled the covariant representable functor on x.1\n\\operatorname{Hom}_{\\mathsf{C}}(x, -) sends y \\in \\mathsf{C} to the set \\operatorname{Hom}_{\\mathsf{C}}(x,y) of morphisms from x to y, and given a morphisms g \\colon y \\to z, the function\n \\operatorname{Hom}_{\\mathsf{C}}(x,g) \\colon \\operatorname{Hom}_{\\mathsf{C}}(x,y) \\to \\operatorname{Hom}_{\\mathsf{C}}(x,z) \nis given by composition, i.e.\n \\operatorname{Hom}_{\\mathsf{C}}(x,g)(f \\in \\operatorname{Hom}_{\\mathsf{C}}(x,y)) = g \\circ f \\in \\operatorname{Hom}_{\\mathsf{C}}(x,z) \n\nLet \\mathsf{C}= \\mathsf{Gr}, the schema for graphs. Then \\operatorname{Hom}_{\\mathsf{Gr}}(V,-) is the graph with one vertex \\operatorname{id}_V \\in \\operatorname{Hom}_{\\mathsf{Gr}}(V,V) and no edges:\n\n\n\nThe representable on V\n\n\nSimilarly, \\operatorname{Hom}_\\mathsf{Gr}(E,-) is the graph with one edge \\operatorname{id}_E \\in \\operatorname{Hom}_{\\mathsf{Gr}}(E,E) and two vertices \\operatorname{src}, \\operatorname{tgt}\\in \\operatorname{Hom}_{\\mathsf{Gr}}(E,V).\n\n\n\nThe representable on E\n\n\n\n\n\\operatorname{Hom}_{\\mathsf{Set}}(2,-) is the functor on \\mathsf{Set} that sends a set X to the set \\{f \\colon 2 \\to X\\} = X^{2}  Given a function f \\colon X \\to Y, \\operatorname{Hom}_{\\mathsf{Set}}(2,f) is the function that sends a tuple (x_{1},x_{2}) \\in X^2 to the tuple (f(x_{1}), f(x_{2})) \\in Y^2.\n\n\nFor n \\in \\mathbb{N}, let P_n be the path graph of length n. Then for a graph G, \\operatorname{Hom}_{\\mathsf{Set}^{\\mathsf{Gr}}}(P_{n}, G) is the set of length-n paths in G. Thus, we can think of the representable \\operatorname{Hom}_{\\mathsf{Set}^{\\mathsf{Gr}}}(P_{n}, -) as a functor which sends a graph to the set of length-n paths in that graph. Notice that as a special case if n = 1, then this simply sends a graph to the set of edges in that graph. This is sneak peak at the Yoneda lemma (but we won‚Äôt get there today).\nIn catlab, we have a very powerful homomorphism search, which can actually compute the set Hom_{\\mathsf{Set}^{\\mathsf{C}}}(G,H) for any finite \\mathsf{C}. There are all sorts of uses for this, but one is simply finding length-n paths in a graph!"
  },
  {
    "objectID": "lecture8.html#representatives-of-functors",
    "href": "lecture8.html#representatives-of-functors",
    "title": "Lecture 8: Universal Mapping Properties",
    "section": "Representatives of functors",
    "text": "Representatives of functors\nNow, there is a natural question to ask: can we go the other way? I.e., given a functor F \\colon \\mathsf{C}\\to \\mathsf{Set}, is there an object c \\in \\mathsf{C} such that F \\cong \\operatorname{Hom}_\\mathsf{C}(c,-), where \\cong means natural isomorphism.\nThis is certainly not always the case, because there are graphs other than the single vertex graph and the single edge graph.\nBut when it is the case, it turns out that this c is unique up to isomorphism! That is, if \\operatorname{Hom}_\\mathsf{C}(c, -) \\cong \\operatorname{Hom}_\\mathsf{C}(c', -), then c \\cong c'! We won‚Äôt prove this today, but we will use it.\nSo this gives us a very powerful tool for constructing objects in a category; we can look for representatives of functors into \\mathsf{Set}, and if they exist, they must be unique! Let‚Äôs do an example.\n\nLet X and Y be sets. Then consider the functor F \\colon \\mathsf{Set}\\to \\mathsf{Set} defined by\n F(Z) = \\operatorname{Hom}(X,Z) \\times \\operatorname{Hom}(Y,Z) \nThe disjoint union X+Y of X and Y represents this functor. That is, there is a natural isomorphism\n \\operatorname{Hom}(X,-) \\times \\operatorname{Hom}(Y,-) \\cong \\operatorname{Hom}(X+Y,-) \nWe can implement this isomorphism in Julia.\n\nimport Pkg; Pkg.activate(\".\")\ninclude(\"../src/Kittenlab.jl\")\nusing .Kittenlab.FinSets\nusing .Kittenlab.Categories\n\nstruct Right{T}\n  val::T\nend\n\nstruct Left{T}\n  val::T\nend\n\ndisjoint_union(X::FinSet{S}, Y::FinSet{T}) where {S,T} =\n  Set{Union{Left{S}, Right{T}}}([Left.(X)..., Right.(Y)...])\n\n\ndisjoint_union(Set([1,2,3]), Set([1,2,3]))\n\nSet{Union{Left{Int64}, Right{Int64}}} with 6 elements:\n  Right{Int64}(3)\n  Right{Int64}(1)\n  Left{Int64}(3)\n  Right{Int64}(2)\n  Left{Int64}(2)\n  Left{Int64}(1)\n\n\n\n# Hom(X,-) x Hom(Y,-) -&gt; Hom(X+Y,-)\ncopair(f::FinFunction{X,Z}, g::FinFunction{Y,Z}) where {X,Y,Z} =\n  FinFunction{Union{Left{X}, Right{Y}},Z}(\n    disjoint_union(dom(FinSetC(), f), dom(FinSetC(), g)),\n    codom(FinSetC(), g),\n    Dict(\n      vcat(\n        [Left(x) =&gt; f(x) for x in dom(FinSetC(), f)],\n        [Right(x) =&gt; g(x) for x in dom(FinSetC(), g)],\n      )\n    )\n  )\n\n# Hom(X+Y,-) -&gt; Hom(X,-) x Hom(Y,-)\nunpack(xs::FinSet{X}, ys::FinSet{Y},\n       f::FinFunction{Union{Left{X}, Right{Y}}, Z}) where {X,Y,Z} =\n    (\n      FinFunction{X,Z}(\n        xs, codom(FinSetC(), f),\n        Dict(x =&gt; f(Left(x)) for x in xs)\n      ),\n      FinFunction{Y,Z}(\n        ys, codom(FinSetC(), f),\n        Dict(y =&gt; f(Right(y)) for y in ys)\n      )\n    )\n\nxs = Set([1,2,3])\nys = Set([1,2,3])\nzs = Set([:a,:b])\n\nf = FinFunction(xs, zs, Dict([1 =&gt; :a, 2 =&gt; :b, 3 =&gt; :b]))\ng = FinFunction(ys, zs, Dict([1 =&gt; :b, 2 =&gt; :b, 3 =&gt; :a]))\n\n(f‚Ä≤, g‚Ä≤) = unpack(xs, ys, copair(f, g))\n(f == f‚Ä≤, g == g‚Ä≤)\n\n(true, true)\n\n\n\nHowever, there‚Äôs no reason why we should only consider such a construction for \\mathsf{Set}.\n\nIn a general category \\mathsf{C}, a representing object of \\operatorname{Hom}(x,-) \\times \\operatorname{Hom}(y,-) is called the coproduct of x and y, and we write it as x + y. A category is said to have coproducts if there exists a coproduct for every pair x,y \\in \\mathsf{C}.\n\nRecall that representing objects are unique up to isomorphism, so the coproduct of two objects is unique up to isomorphism, which justifies our use of the word ‚Äúthe‚Äù.\n\nThe category of graphs has coproducts. The coproduct of two graphs G and H has\n\n\\begin{align*}\n  (G + H)(V) &= G(V) + H(V) \\\\\n  (G + H)(E) &= G(E) + H(E) \\\\\n\\end{align*}\n\n\nIn fact, all categories of \\mathsf{C}-sets have coproducts, given in a similar manner.\nThat about wraps up the material for this lecture, but before we close, I want to present the ‚Äúmore traditional way‚Äù of talking about coproducts.\nFollowing the isomorphism\n \\operatorname{Hom}(X+Y, -) \\cong \\operatorname{Hom}(X, -) \\times Hom(Y, -) \nwith \\operatorname{id}_{X+Y} \\in \\operatorname{Hom}(X+Y, X+Y), we get two maps\n \\iota_{X} \\in \\operatorname{Hom}(X, X+Y), \\iota_{Y} \\in Hom(Y, X+Y) \nWe say that X+Y is the universal object with these mappings, which means that for any other\n\n\n\nthere is a unique map \\langle f, g \\rangle \\colon X+Y \\to Z such that the following commutes.\n\n\n\nWe leave it to the reader to show that this is an equivalent definition of coproduct!"
  },
  {
    "objectID": "lecture8.html#footnotes",
    "href": "lecture8.html#footnotes",
    "title": "Lecture 8: Universal Mapping Properties",
    "section": "",
    "text": "There are also contravariant representable functors, but we won‚Äôt be getting to them until the next lecture.‚Ü©Ô∏é"
  },
  {
    "objectID": "lecture9.html#colimits-as-gluing",
    "href": "lecture9.html#colimits-as-gluing",
    "title": "Lecture 9: Colimits",
    "section": "Colimits as gluing",
    "text": "Colimits as gluing\nThe core idea behind colimits is that we take a bunch of objects in a category, take their ‚Äúdisjoint union‚Äù (i.e., their n-ary coproduct), and then ‚Äúglue‚Äù parts of those objects together.\nSo before we get into the category theory, let‚Äôs talk about exactly what that means.\nWe want to be able to ‚Äúdeclare by fiat‚Äù that two elements of a set are actually the same element. How can we record this declaration mathematically?\nWe start out with a set X. We then make a relation on X, i.e.¬†R \\subset X \\times X, where (x,x') \\in X if we are ‚Äúdeclaring‚Äù that x should be equal to x'.\nThis relation should satisfy three properties.\n\n(x,x) \\in R for all x\nIf (x,y) \\in R, then (y, x) \\in R\nIf (x,y) \\in R and (y,z) \\in R, then (x,z) \\in R\n\nOne way of saying this succinctly is that (X,R) is a preorder where all morphisms are invertible. This is called an equivalence relation.\nWe can then take the set of ‚Äúconnected components‚Äù, which we call X/R. An element of X/R is a subset U of X such that for all x,y \\in U, (x,y) \\in R, and if x \\in U and (x,y) \\in R, then y \\in U.\nThere is a very efficient data structure for storing an equivalence relation on the set \\{1,\\ldots,n\\}, called a union find.\nWe‚Äôre going to start with a more naive data structure, and then improve it to a union find.\nThe idea is that we choose a representative for each equivalence class, and we store the mapping from number to representative in an array. Two elements are in the same equivalence class if and only if their representatives are the same.\nWe start out with the equivalence classes \\{\\{1\\},\\ldots,\\{n\\}\\}, and thus each element is assigned itself as a representative.\nstruct RepStore\n  representative::Vector{Int}\n  function RepStore(n::Int)\n    new(Vector{Int}(1:n))\n  end\nend\n\nequivalent(uf::RepStore, i::Int, j::Int) = uf.representative[i] == uf.representative[j]\nWe now want to be able to ‚Äúdeclare by fiat‚Äù that two elements are equal. Naively, an algorithm for this would look something like the following.\nfunction union!(uf::RepStore, i::Int, j::Int)\n  irep, jrep = uf.representative[i], uf.representative[j]\n  for k in 1:length(uf.representative)\n    if uf.representative[k] == jrep\n      uf.representative[k] = irep\n    end\n  end\nend\nThis sets anything that previously had the same representative as j to now have the same representative as i.\nBut we can do better than this. Ideally, we would just write\nfunction union!(uf::RepStore, i::Int, j::Int)\n  irep, jrep = uf.representative[i], uf.representative[j]\n  uf.representative[jrep] = irep\nend\nThis doesn‚Äôt quite work. In order to make it work, we use a different strategy for storing the representatives.\nstruct UnionFind\n  parent::Vector{Int}\n  function UnionFind(n::Int)\n    new(Vector{Int}(1:n))\n  end\nend\n\nfunction find_root(uf::UnionFind, i::Int)\n  parent = uf.parent[i]\n  if parent == i\n    i\n  else\n    find_root(uf, parent)\n  end\nend\n\nfunction union!(uf::UnionFind, i::Int, j::Int)\n  iroot, jroot = find_root(uf, i), find_root(uf, j)\n  uf.parent[jroot] = iroot\nend\nThis implicitly stores the representative for each equivalence class via a chain of links. One way of thinking about this is that we are storing a forest of nodes, and we can check if two nodes are in the same tree by following the links up to the root and checking if the root is the same for each.\nThere are then several optimizations that we can make then in order to make this run even faster, which we won‚Äôt get into now, but once we have done that find_root and union! both run in essentially constant time.\nSo this gives us a good way of ‚Äúdeclaring by fiat‚Äù that two elements of a set are equal: we just run merge! on them.\nLet‚Äôs now use this to make an implementation of the categorical operation of pushout."
  },
  {
    "objectID": "lecture9.html#pushouts",
    "href": "lecture9.html#pushouts",
    "title": "Lecture 9: Colimits",
    "section": "Pushouts",
    "text": "Pushouts\nA pushout is a type of colimit, and understanding how pushouts work will generalize well to understanding of general colimits.\n\nSuppose we have the following diagram in a category \\mathsf{C}\n\n\n\nThen the pushout of this diagram is given by another object X +_{Z} Y \\in \\mathsf{C} along with maps \\iota_{X}, \\iota_{Y} and \\iota_{Z} that make the following commute\n\n\n\nsuch that for any W with \\iota_{X}', \\iota_{Y}' \\iota_{Z}' similar, there exists a unique map p_{W} \\colon X +_{Z} Y \\to W such that the following commutes.\n\n\n\n(there should also be \\iota_{Z} and \\iota_{Z}', but it‚Äôs hard to fit them in that diagram).\n\nThe way we think about this is that X +_{Z} Y is the coproduct of X and Y, but with the image of Z in X ‚Äúequalized by fiat‚Äù with the image of Z in Y.\n\nIn \\mathsf{Set}, the pushout of the diagram\n\n\n\nis X + Y/\\sim, where \\sim is the equivalence relation generated by f(z) \\sim g(z) for all z \\in Z.\nWe compute this with\nfunction pushout(f::FinFunction, g::FinFunction)\n  @assert dom(f) == dom(g)\n  n = length(codom(f))\n  m = length(codom(g))\n  po = UnionFind(n + m)\n  for z in dom(f)\n    union!(po, f(z), n + g(z))\n  end\n  roots = unique!([find_root(res, i) for i in 1:length(po)])\n  (Set(roots),\n   Dict(i =&gt; find_root(res, f(i)) for i in 1:n),\n   Dict(i =&gt; find_root(res, g(i) + n) for i in 1:m),\n   )\nend\nWhy is this a pushout? Well, given another set W with maps in from X, Y and Z that commute, we can figure out where to send each equivalence class in X+Y/\\sim, because by the commutation property, all elements of each equivalence class have to go to the same element of W.\n\nWe can do the exact same thing for graphs. We can take two graphs, take their coproduct, and then ‚Äúglue‚Äù some of their edges and vertices together, according to maps out of a third graph.\nNow, recall in the last lecture that we characterized coproducts as representatives of certain functors. We can do the exact same thing here, but we have to describe the functor that it‚Äôs representing in a special way.\nLet \\mathsf{D} be the category presented by the graph\n\n\n\nThen the ‚Äúsetup‚Äù for a pushout is a functor F \\colon \\mathsf{D} \\to \\mathsf{C}.\n\nThe pushout of F \\colon \\mathsf{D} \\to \\mathsf{C} is a representing object for \\operatorname{Hom}_{\\mathsf{C}^{\\mathsf{D}}}(F, \\Delta(-)), where \\Delta \\colon \\mathsf{C}\\to \\mathsf{C}^{\\mathsf{D}} sends an object X to the constant functor at X.\n\n\nProof. An element of \\operatorname{Hom}_{\\mathsf{C}^{\\mathsf{D}}}(F, \\Delta(W)) is a natural transformation \\alpha from F to \\Delta(W). Remember, a natural transformation consists of a morphism in \\mathsf{C} for every object in \\mathsf{D}, so in this case we have three morphisms. Then the naturality condition implies that the diagram\n\n\n\ncommutes.\nA representative of \\operatorname{Hom}_{\\mathsf{C}^{\\mathsf{D}}}(F, \\Delta(-)) is an object \\varprojlim F \\in \\mathsf{C} such that \\operatorname{Hom}_{\\mathsf{C}}(\\varprojlim F, W) \\cong \\operatorname{Hom}_{\\mathsf{C}^{\\mathsf{D}}}(F, \\Delta(W)). We can show that such an object satisfies the earlier definition of pushout by passing in the identity on \\varprojlim F into the right hand side, to get a map \\operatorname{Hom}_{\\mathsf{C}^{\\mathsf{D}}}(F, \\Delta(\\varprojlim F)) that gives the diagram in the definition. And then the naturality of the isomorphism gives us the factorization property. The converse can be proved similarly.\n\nThis gives us a hint on how to do general colimits.\n\nGiven two categories \\mathsf{D} and \\mathsf{C}, and a functor F \\colon \\mathsf{D} \\to \\mathsf{C}, the colimit \\varprojlim F is the representing object for \\operatorname{Hom}_{\\mathsf{C}^{\\mathsf{D}}}(F, \\Delta(-)) (if such an object exists).\n\n\nIf \\mathsf{D} is the discrete category with two objects, then we just get coproducts again. More generally, we can do n-ary coproducts by making \\mathsf{D} the discrete category with n objects.\n\n\nIf \\mathsf{D} is the empty category, what do we get? Well \\operatorname{Hom}_{\\mathsf{C}^{\\mathsf{D}}}(F, \\Delta(-)) is always a singleton, if F is the unique functor from \\mathsf{D} to \\mathsf{C}. So we are looking for an object X \\in C such that \\operatorname{Hom}(X,Y) is a singleton for all Y.\nIn \\mathsf{Set}, this is the empty set. More generally, this is called an initial object.\n\n\nIf \\mathsf{D} is a category that looks like this:\n\n\n\nthen the colimit of a functor F \\colon \\mathsf{D} \\to \\mathsf{C} is called a coequalizer.\nCategory theory is the subject where the examples have examples: let‚Äôs give an example of a coequalizer. Suppose that \\mathsf{C} is the category of abelian groups, and we have the diagram\n\n\n\nwhere H is a subgroup of G, f is the inclusion, and 0 is the constant map at the identity. Then the coequalizer of that diagram is G/H, the quotient group. This is the group that results from ‚Äúdeclaring by fiat‚Äù every element of H to be 0.\n\nColimits are a rich subject which we will no doubt return to over and over again, but that will be it for today!"
  },
  {
    "objectID": "lecture10.html#representable-functors",
    "href": "lecture10.html#representable-functors",
    "title": "Lecture 10: Representables revisited",
    "section": "Representable functors",
    "text": "Representable functors\nThe core of category theory is the idea that ‚Äúeverything you know‚Äù about an object is encapsulated by looking at the morphisms out of (or into) that object.\nThis intuition is captured in the formalism of representable functors, which we have talked about before but hasn‚Äôt seemed to ‚Äútake‚Äù.\nBefore we (re)define representable functors, we‚Äôre going to talk a little bit about the ‚Äútype‚Äù of a representable functor.\nWe want to look at the morphisms out of an object. How can we express that information? One way would be to just have a set. But that doesn‚Äôt tell us very much; that doesn‚Äôt give us ‚Äúhandles‚Äù that we can use to process the information.\nWe can organize a little bit by splitting that set by codomain. Namely, for each object Y \\in \\mathsf{C}, we have a set of morphisms with codomain Y. So this looks like a function F \\colon \\mathsf{C}\\to \\mathsf{Set}. But when we have a morphism from Y to Z, and a morphism into Y, then we can make a morphism into Z. Thus, for every f \\colon Y \\to Z, there is a function F(f) \\colon F(Y) \\to F(Z). In other words, F is a functor from \\mathsf{C}\\to \\mathsf{Set}, or a \\mathsf{C}-set, if you will.\nSo the ‚Äúshape‚Äù of the information about all of the morphisms out of an object in \\mathsf{C} is a \\mathsf{C}-set.\n\nTake the category \\mathsf{Petri} presented by the following diagram\n\n\n\nThen let F be the \\mathsf{Petri}-set of morphisms out of S. F(S) = \\{ \\operatorname{id}_{S} \\}, and F(x) = \\emptyset for x \\in \\{S,I,O\\}. Interpreted as a Petri net, F is the single-species Petri net.\nNow let F be the \\mathsf{Petri}-set of morphisms out of I. Then F(S) = \\{ \\mathrm{is} \\}, F(T) = \\{\\mathrm{it}\\}, F(I) = \\{ \\operatorname{id}_{I} \\}. Interpreted as a Petri net, F has a single species, a single transition, and one arc going from the species to the transition.\n\nWe summarize what we‚Äôve talked about so far in the following proposition.\n\nGiven a category \\mathsf{C} and an object X \\in \\mathsf{C}, there is a \\mathsf{C}-set y_{\\mathsf{C}}(X) \\colon \\mathsf{C}\\to \\mathsf{Set}, such that y_{\\mathsf{C}}(X)(Y) = \\operatorname{Hom}_{\\mathsf{C}}(X,Y).\n\nWe call y_{\\mathsf{C}}(X) the ‚Äúrepresentable functor at X‚Äù. We‚Äôre now going to talk about how to compute these representable functors in a special case."
  },
  {
    "objectID": "lecture10.html#computing-representables-with-dynamic-programming",
    "href": "lecture10.html#computing-representables-with-dynamic-programming",
    "title": "Lecture 10: Representables revisited",
    "section": "Computing representables with dynamic programming",
    "text": "Computing representables with dynamic programming\nSuppose that \\mathsf{C} is the path graph category for a graph G, so that an object of \\mathsf{C} is a vertex of G, and a morphism of \\mathsf{C} is a path in G.\nOur goal is to be able to fix a \\in \\mathsf{C}, and then compute \\operatorname{Hom}_{\\mathsf{C}}(a,b) for every b. Of course, if there are loops in G, then \\operatorname{Hom}_{\\mathsf{C}}(a,b) could be infinite, so we‚Äôre going to assume that G is a directed acyclic graph.\nThis is going to be kind of like Dijkstra‚Äôs algorithm, which computes the shortest path between different vertices, except instead of computing the shortest path, we‚Äôre going to compute the set of all paths. But we‚Äôre going to use a similar trick of expanding the problem to be computing all the paths between all pairs of vertices.\nFor this problem, we‚Äôre going to use Catlab, because Catlab has some nice features for printing out graphs that I don‚Äôt want to recreate.\n\nusing Pkg; Pkg.activate(\".\")\nusing Catlab\nusing Catlab.Graphs\n\ng = path_graph(Graph, 10)  \n\n\nGraph with elements V = 1:10, E = 1:9\n\n\n\n\nE\nsrc\ntgt\n\n\n\n\n1\n1\n2\n\n\n2\n2\n3\n\n\n3\n3\n4\n\n\n4\n4\n5\n\n\n5\n5\n6\n\n\n6\n6\n7\n\n\n7\n7\n8\n\n\n8\n8\n9\n\n\n9\n9\n10\n\n\n\n\n\n\n\n\nusing Catlab.Graphics\n\nto_graphviz(g)\n\n\n\n\nWe will represent a path in a graph as a vector of edge ids.\n\nconst Path = Vector{Int}\n\nThen we will write a function\nfunction compute_paths(g::Graph)::Matrix{Set{Path}}\n  ...\nend\nwhich returns an n \\times n matrix P, where n is the number of vertices in the graph, P_{v,w} is the set of paths from v to w.\n\nfunction compute_paths(g::Graph)\n  n = nv(g) # the number of vertices in g\n  P = [Set{Path}() for _ in 1:n, _ in 1:n]\n  \n  # add all of the identity paths\n  for v in vertices(g)\n    push!(P[v,v], Int[])\n  end\n  # at each iteration, we find the paths of length k\n  # the longest paths are length n\n  for k in 1:n\n    for e in edges(g)\n      s,t = src(g,e), tgt(g,e)\n      for v in vertices(g)\n        for p in P[v,s]\n          if length(p) == k - 1\n            push!(P[v,t], [p; e])\n          end\n        end\n      end\n    end\n  end\n\n  P\nend\n\ncompute_paths(g)\n\n10√ó10 Matrix{Set{Vector{Int64}}}:\n Set([[]])  Set([[1]])  Set([[1, 2]])  ‚Ä¶  Set([[1, 2, 3, 4, 5, 6, 7, 8, 9]])\n Set()      Set([[]])   Set([[2]])        Set([[2, 3, 4, 5, 6, 7, 8, 9]])\n Set()      Set()       Set([[]])         Set([[3, 4, 5, 6, 7, 8, 9]])\n Set()      Set()       Set()             Set([[4, 5, 6, 7, 8, 9]])\n Set()      Set()       Set()             Set([[5, 6, 7, 8, 9]])\n Set()      Set()       Set()          ‚Ä¶  Set([[6, 7, 8, 9]])\n Set()      Set()       Set()             Set([[7, 8, 9]])\n Set()      Set()       Set()             Set([[8, 9]])\n Set()      Set()       Set()             Set([[9]])\n Set()      Set()       Set()             Set([[]])\n\n\nNow, let‚Äôs think about what this is saying mathematically. Let G be the path graph with 10 vertices, and let \\mathsf{C} be the path category on G. \\mathsf{C} has objects 1,\\ldots,10, one morphism from i to j if i \\leq j, and zero morphisms if i &gt; j. Thus the representable y_{\\mathsf{C}}(i) is given by\n y_{\\mathsf{C}}(i)(j) = \\begin{cases}\n                  1 & \\text{if $i \\leq j$} \\\\\n                  \\emptyset & \\text{otherwise}\n                \\end{cases}\n\nNote that it‚Äôs possible to have a function from \\emptyset to 1, but not the other way around. So if there‚Äôs a morphism from x to y, and F(x) is non-empty, then F(y) has to also be non-empty.\nThis also implies that there can‚Äôt be an isomorphism between y_{\\mathsf{C}}(i) and y_{\\mathsf{C}}(j) for i \\neq j, because if i &lt; j then y_{\\mathsf{C}}(i)(i) is non-empty but y_{\\mathsf{C}}(j)(i) is empty.\nThis is a specific instance of the general phenomenon that looking at all of the morphisms out of an object characterizes that object."
  },
  {
    "objectID": "lecture10.html#characterizing-objects-using-c-sets",
    "href": "lecture10.html#characterizing-objects-using-c-sets",
    "title": "Lecture 10: Representables revisited",
    "section": "Characterizing objects using C-sets",
    "text": "Characterizing objects using C-sets\nPreviously, we have gone from objects of \\mathsf{C} to \\mathsf{C}-sets, taking x \\in \\mathsf{C} to y_\\mathsf{C}(x). But we can also ask the question, given an arbitrary F \\colon \\mathsf{C}\\to \\mathsf{Set}, is there an x \\in \\mathsf{C} such that y_\\mathsf{C}(x) \\cong F? We ask this question by saying ‚Äúdoes F have a representative?‚Äù\n\nSuppose you come back from a party, and you had a really good time talking to someone but you can‚Äôt remember their name. But you do remember the conversations that the person had with the other people at the party. So you call up a friend, and you ask ‚Äúwho was that person who was had 3 conversations with Alice, 2 conversations with Bob, and didn‚Äôt talk to Eve at all?‚Äù Your friend might say ‚Äúoh, that was Roberta‚Äù, or might say ‚Äúyou must have been drunk; nobody had that sequence of conversations.‚Äù\nOf course, there might be several people of that description, and no two people are really ‚Äúisomorphic‚Äù, but the basic idea is still there. You can generally identify someone by how they relate to other people. Finding a representing object for a \\mathsf{C}-set is conceptually the same process; the \\mathsf{C}-set is the description of how the object relates to other objects.\n\n\nConsider the functor U from \\mathsf{Vect} to \\mathsf{Set} which sends a vector space V to its underlying set, and a linear map f \\colon V \\to W to its underlying function. Think for a second, is there a representing object for this functor?\nYes: one representing object for this functor is the vector space \\mathbb{R}. What does this mean precisely? This means that there is an natural isomorphism between the functors y_{\\mathsf{Vect}}(\\mathbb{R}) and U. That is, for every vector space V, there is an isomorphism between the set y_{\\mathsf{Vect}}(\\mathbb{R})(V) = \\operatorname{Hom}_{\\mathsf{Vect}}(\\mathbb{R},V) and the set V.\nWe construct this isomorphism in the following way. Given a linear map f \\colon \\mathbb{R}\\to V, there is a corresponding element f(1) \\in V, and given an element v \\in V, there is a unique linear map f \\colon \\mathbb{R}\\to V such that f(1) = v. Let \\alpha_{V} \\colon y_{\\mathsf{Vect}}(\\mathbb{R})(V) \\to U(V) and \\alpha_{V}^{-1} \\colon U(V) \\to y_{\\mathsf{Vect}}(\\mathbb{R})(V) be these maps.\nWe then need to also check the naturality toblerone for \\alpha. We won‚Äôt do this every time, but it‚Äôs good practice.\nLet V and W be vector spaces, and let g \\colon U \\to V be a map between them. Then the bottom of the naturality toblerone for g is\n\n\n\nRemember that the action of y_{\\mathsf{Vect}}(\\mathbb{R}) on morphisms is composition. So if we start out with f \\colon \\mathbb{R}\\to V, and take the left-bottom route, we first get g \\circ f \\in y_{\\mathsf{Vect}}(\\mathbb{R})(W), and then get (g \\circ f)(1) \\in U(W). If we take the top-right route, we first get f(1) \\in U(V), and then get g(f(1)) \\in U(W)). As (g \\circ f)(1) = g(f(1)), the square commutes! So \\alpha is a natural transformation. We can similarly prove that \\alpha^{-1} is a natural transformation, and it is clear that \\alpha and \\alpha^{-1} are inverses, so U and y_{\\mathsf{Vect}}(\\mathbb{R}) are naturally isomorphic, as required.\n\n\nConsider the functor F from \\mathsf{Vect} to \\mathsf{Set} which sends every vector space to the singleton set 1. Is there a representing object for this functor?\nYes, the representing object for this functor is the vector space \\mathbb{R}^{0}, because there is precisely one linear map \\mathbb{R}^{0} \\to V for any vector space V.\n\n\nConsider the poset (\\mathbb{Q}_{\\geq 0}, \\leq) as a category. Then define F \\colon \\mathbb{Q}_{\\geq 0} \\to \\mathsf{Set} by\n\nF(x) = \\begin{cases}\n         1 & \\text{if $2 \\leq x^{2}$} \\\\\n         \\emptyset & \\text{otherwise}\n       \\end{cases}\n\nYou can check that if x \\leq x', then F(x') = \\emptyset if and only if F(x) = \\emptyset, so we can make F into a functor by supplying the unique functions \\emptyset \\to 1 and 1 \\to 1 for F(x) \\to F(x'); we never have to make a function 1 \\to \\emptyset, which would be impossible.\nA representative for F would be a rational number q \\geq 0 such that 2 \\leq x^{2} if and only if q \\leq x. One canditate for this would be \\sqrt{2}, but \\sqrt{2} isn‚Äôt rational! It turns out that no such q exists, so there is no representative for F!\nHowever, if we consider a similar situation with the poset (\\mathbb{R}_{\\geq 0}, \\leq) instead, then F would be representable!\nSo we see that representability has many surprising and non-trivial applications."
  },
  {
    "objectID": "lecture11.html#coproducts-of-types-in-julia",
    "href": "lecture11.html#coproducts-of-types-in-julia",
    "title": "Lecture 11: Adding and squishing",
    "section": "Coproducts of types in Julia",
    "text": "Coproducts of types in Julia\nLet‚Äôs start with an example.\nCoproducts in ‚Äúa category of types‚Äù correspond to sum types, or tagged unions. In Julia:\n\nstruct Left{T}\n  val::T\nend\n\nstruct Right{T}\n  val::T\nend\n\nconst Coproduct{S,T} = Union{Left{S}, Right{T}}\n\nNow, suppose we want to write a function foo out of Coproduct{Int,String} into Int that takes Left(x) to x^2 and Right(x) to length(x). We can use Julia‚Äôs dispatch system to help us here:\n\nfoo(l::Left{Int}) = l.val^2\nfoo(r::Right{String}) = length(r.val)\n\n(foo(Left(4)), foo(Right(\"hello\")))\n\n(16, 5)\n\n\nHow did we write this function? Well, we wrote two functions, one out of Int and one out of String.\nIn general, a function from Coproduct{S,T} to A is given by a function from S to A and a function from T to A.\nThe description of coproducts as the representatives of a certain \\mathsf{C}-set expresses this property exactly.\nNamely, if we work in \\mathsf{Jul}, the category of Julia types and functions between them, then the functor F \\colon \\mathsf{Jul}\\to \\mathsf{Set} which sends A to the set of pairs of functions S -&gt; A and T -&gt; A is represented by the type Coproduct{S,T}.\nNote that we could have use types other than Coproduct{S,T} and gotten the same property; for instance we could have used\nstruct TaggedUnion{S,T}\n  tag::Bool\n  val::Union{S,T}\n  function TaggedUnion{S,T}(tag::Bool, x::S) where {S,T}\n    @assert tag == true\n    new(tag, x)\n  end\n  function TaggedUnion{S,T}(tag::Bool, y::T) where {S,T}\n    @assert tag == false\n    new(tag, y)\n  end\nend\nDifferent choices of representing object can have different performance characteristics, but their ‚Äúexternal interface‚Äù is precisely the same: a map out of the coproduct is equivalent to a map out of each of the two summands."
  },
  {
    "objectID": "lecture11.html#angles-and-squishing",
    "href": "lecture11.html#angles-and-squishing",
    "title": "Lecture 11: Adding and squishing",
    "section": "Angles and squishing",
    "text": "Angles and squishing\nVery often in programming, we talk about angles. We represent an angle by a real number, measured in radians or degrees. But there‚Äôs a problem: \\theta and \\theta + 2\\pi represent the same angle! That is, if we rotate something in real life by \\theta or if we rotate it by \\theta + 2\\pi, we get the same result at the end (assuming that it can rotate freely, and isn‚Äôt winding up a spring or something).\nOne solution for this is to only work with angles in the range [0,2\\pi). But this is not ideal for some scenarios; for instance if we are working with a pendulum where the resting angle is 0, then it is more convenient to have angles in the range [-\\pi,\\pi), because the pendulum might swing forwards or backwards.\nWhy can we do this; why are [0,2\\pi) and [-\\pi,\\pi) equally good representations for angles? Can we find a characterization of the properties that [0,2\\pi) and [-\\pi,\\pi) have?\nWell, let‚Äôs go back to thinking about angles as real numbers. A ‚Äúwell-behaved‚Äù program which takes an angle \\theta as an input should return the same value on \\theta and \\theta + 2\\pi. So now we can characterize the functions out of \\mathbb{R} that are well behaved as a functor F from \\mathsf{Set} to \\mathsf{Set}. This functor sends a set X to the set of functions f \\colon \\mathbb{R}\\to X such that f(\\theta) = f(\\theta + 2\\pi) for all \\theta \\in \\mathbb{R}, which we call the set of functions with period 2\\pi.\nF(X) = \\{ f \\colon \\mathbb{R}\\to X \\mid \\text{$f$ has period $2\\pi$} \\}\nThe action of F on morphisms g \\colon X \\to Y is given by\nF(g)(f \\colon \\mathbb{R}\\to X) = g \\circ f \\colon \\mathbb{R}\\to Y\nOne can check that if f has period 2\\pi then g \\circ f also does.\nThen [0,2\\pi) and [-\\pi,\\pi) are both representatives for F. More specifically, we can construct isomorphisms between y_{\\mathsf{Set}}([0,2\\pi)) and F, and also between y_{\\mathsf{Set}}([-\\pi,\\pi)) and F. This is because a function out of [0,2\\pi) can be extended to a function out of \\mathbb{R} with period 2\\pi, a function out of \\mathbb{R} with period 2\\pi can be restricted to [0,2\\pi), and going back and forth gets to to the same place. The same holds for functions out of [-\\pi,\\pi).\nWe can now do this more abstractly.\nConsider two functions 1_\\mathbb{R}, p \\colon \\mathbb{R}\\to \\mathbb{R}. 1_\\mathbb{R} is the identity, so 1_\\mathbb{R}(\\theta) = \\theta, and then p(\\theta) = \\theta + 2\\pi. A function f \\colon \\mathbb{R}\\to X has period 2\\pi if and only if f \\circ 1_{\\mathbb{R}} = f \\circ p. Thus, we could equivalently characterize F by\n F(X) = \\{ f \\colon \\mathbb{R}\\to X \\mid f \\circ 1_{\\mathbb{R}} = f \\circ p \\} \nThe advantage of this description is that it relies purely on categorical structure, i.e.¬†composition of morphisms. This leads to the following definition.\n\nLet \\mathsf{C} be a category, and A,B be objects in \\mathsf{C}. Then the coequalizer of a pair of morphisms p,q \\colon A \\to B is a representing object for\n F(X) = \\{ f \\colon B \\to X \\mid f \\circ p = f \\circ q \\} \n\nIf coproducts allow you to ‚Äúadd‚Äù together objects in a category, coequalizers allow you to ‚Äúsquish down‚Äù objects in a category, like how we squished \\{\\ldots, \\theta - 2\\pi, \\theta, \\theta + 2\\pi, \\ldots\\} to a single point because they all represent the same angle.\nIt‚Äôs kind of inconvenient that whenever we have a representative of a functor, we have to lug around a whole natural isomorphism. It turns out that for coequalizers, we can get by with much less data.\n\nIf C is the coequalizer of p,q \\colon A \\to B, then there is a map e \\colon B \\to C such that for any map f \\colon B \\to X with f \\circ p = f \\circ q, there is a unique map \\tilde{f} \\colon C \\to X such that\n\n\n\ncommutes.\nMoreover, any such map e gives rise to an isomorphism between the functor\n F(X) = \\{ f \\colon B \\to X \\mid f \\circ p = f \\circ q \\} \nand y_{\\mathsf{C}}(C).\nWe call e the coequalizing morphism.\n\n\nProof. The basic idea is that the map e \\colon B \\to C corresponds to the identity 1_C \\in y_\\mathsf{C}(C)(C) when we take the isomorphism F(C) \\cong y_{\\mathsf{C}}(C)(C).\nWe will return to this in more detail in a future lecture.\n\nSo when we give an instance of a coequalizer, we just have to give an object and coequalizing morphism, which is often more convenient than writing out the whole natural isomorphism.\nReturning back to angles, there‚Äôs a third representative for the coequalizer of 1_\\mathbb{R} and p: the circle S^1 defined by\n S^{1} = \\{z \\in \\mathbb{C} \\mid |z| = 1 \\} \nThis is ‚Äúnicer‚Äù because there‚Äôs no ‚Äújump‚Äù, i.e.¬†when we move off the right side of the interval [0,2\\pi), we jump back to the left side, but in the circle we just smoothly move around. The coequalizing morphism is the map e \\colon \\mathbb{R}\\to S^{1}, given by \\theta \\mapsto e^{i\\theta}.\nAs sets, there‚Äôs no difference between [0,2\\pi) and S^{1}. However, if we instead consider the category of \\mathsf{Top} of topological spaces and continuous maps between them (continuous roughly means ‚Äúno jumps‚Äù), then S^{1} and [0,2\\pi) are not the same!\nSpecifically, the map \\mathbb{R}\\to [0,2\\pi) is not continuous, because we have the ‚Äújump‚Äù from 2\\pi-\\epsilon to 0. However, the map \\mathbb{R}\\to S^{1} is. So the coequalizer of 1_\\mathbb{R} and p in \\mathsf{Top} is S^{1}, not [0,2\\pi)."
  },
  {
    "objectID": "lecture11.html#examples-to-think-about-if-we-have-time",
    "href": "lecture11.html#examples-to-think-about-if-we-have-time",
    "title": "Lecture 11: Adding and squishing",
    "section": "Examples to think about if we have time",
    "text": "Examples to think about if we have time\n\nIn \\mathsf{Mat}, the category where the objects are natural numbers and the morphisms are matrices, consider the following setup, where M is an arbitrary matrix and 0 is the zero matrix.\n\n\n\nRecall that the rank of M is the dimension of the range of M, and let k be the rank. Then the coequalizer of this diagram is m - k, with the following coequalizing matrix m \\to (m - k).\nLet v_{1},\\ldots,v_{k} be an orthonormal basis for the range of M. Then extend this to an orthonormal basis v_{1},\\ldots,v_{m} for all of \\mathbb{R}^{m}. Then define a matrix E \\colon m \\to (m-k) by using the row vectors v_{k+1},\\ldots,v_{m}.\nBy orthogonality, E(\\alpha_{1} v_{1} + \\cdots + \\alpha_{k} v_{k}) = 0. Thus, EM = 0 = E0. Moreover, any other matrix E' \\colon m \\to l such that E'M = 0 factors through E.\nIf we have time, we will prove this and also livecode a Julia implementation using the LinearAlgebra library to find orthonormal bases."
  },
  {
    "objectID": "lecture12.html",
    "href": "lecture12.html",
    "title": "Lecture 12: That‚Äôs Yoneda, Babe",
    "section": "",
    "text": "$$ \n\n\n$$\n\nEver since we learned about natural transformations, I‚Äôve been saying that I‚Äôm going to talk about the Yoneda lemma. And finally now we are going to do it.\nWhat is the Yoneda lemma? I think of the Yoneda lemma as a ‚Äúvibe check‚Äù for category theory. We say all the time that in category theory ‚Äúall that matters‚Äù is the morphisms out of or into an object; the Yoneda lemma formalizes this.\nThe Yoneda lemma also underscores the usefulness of representable functors.\nWe start to understand the Yoneda lemma via the following seemingly trivial statement:\n\nFor any set A, there is an isomorphism between elements a \\in A and functions f \\colon 1 \\to A. We can write this as\n A \\cong \\operatorname{Hom}_{\\mathsf{Set}}(1, A) \n\nIf we think about \\mathsf{Set} in Julia, a function 1 \\to A is a single-element vector, with that single element being an element of A. The isomorphism is then\nf(a::A) = [a]\nf_inverse(v::Vector{A}) = v[1]\nThis is even more obvious if you write it as the algebra 1 equality A^{1} \\cong A.\nThe Yoneda lemma extends this triviality beyond sets to \\mathsf{C}-sets.\nWe can start to get an intuition for the Yoneda lemma by looking at graphs. Given a graph G \\colon \\mathsf{Gr}\\to \\mathsf{Set}, we can get the set of vertices of that graph by applying G to V \\in \\mathsf{Gr} to get G(V) \\in \\mathsf{Set}. However, we can also get the set of vertices by looking at all of the morphisms into G from the single-vertex graph y_{V} (recall that the single-vertex graph is the representable on V).\n\n\n\nPicking out a single vertex with a morphism\n\n\nIt is not hard to see that there is a bijection between:\n\nthe set of morphisms from y_{V} to G\nG(V)\n\nfor the same reason that for any set there is a bijection between functions 1 \\to A and elements of A. Namely, given a morphism \\alpha \\colon y_{V} \\to G, we get an element y_{V}(\\operatorname{id}_V) \\in G(V). And given an element v \\in G(V), there is a morphism v^\\ast \\colon y_V \\to G given by \\operatorname{id}_V \\mapsto v.\nWe write this consisely as\n G(V) \\cong \\operatorname{Hom}_{\\mathsf{Set}^\\mathsf{Gr}}(y_{V}, G) \nWe can do the exact same thing for edges! The edges of G are in bijection with morphisms out of y_{E}, where y_{E} is the graph with a single edge and two vertices.\n\n\n\nPicking out a single edge with a morphism\n\n\nGiven an element e \\in G(E), there is a unique morphism e^{\\ast} \\colon y_{E} \\to G given by\n \\operatorname{id}_E \\mapsto e   \\operatorname{src}\\mapsto G(\\operatorname{src})(e)   \\operatorname{tgt}\\mapsto G(\\operatorname{tgt})(e) \nMoreover, given any morphism \\alpha \\colon y_{E} \\to G, there is an element of \\alpha_{E}(\\operatorname{id}_{E}) \\in G(E).\nWe write this as\n G(E) \\cong \\operatorname{Hom}_{\\mathsf{Set}^{\\mathsf{Gr}}}(y_{E}, G) \nNote that this crucially depends on the naturality of the morphism f \\colon y_{E} \\to G. If we had an unnatural morphism, then we wouldn‚Äôt necessarily have commutation of the square\n\n\n\nso the vertices in G that the endpoints of \\operatorname{id}_{E} are sent to would not be determined by where \\operatorname{id}_{E} was sent.\nNow that we‚Äôve seen two instances of this pattern, you can probably guess what it looks like in general.\n\n(Yoneda). Given a category \\mathsf{C} and a functor F \\colon \\mathsf{C}\\to \\mathsf{Set}, for every object X \\in \\mathsf{C} there is an isomorphism\n F(X) \\cong \\operatorname{Hom}_{\\mathsf{Set}^{\\mathsf{C}}}(y_{X}, F) \n\n\nProof. We will give a map in each direction, then show they are inverse.\nStarting from x \\in F(X), we construct x^{\\ast} \\colon y_{X} \\to F by the mapping\n f \\in y_{X}(Y) = \\operatorname{Hom}_{\\mathsf{C}}(X,Y) \\mapsto F(f)(x) \nIn the other direction, starting from \\alpha \\colon y_{X} \\to F, we get \\alpha_{X}(\\operatorname{id}_{X}) \\in F(X).\nNow, given x \\in F(X),\n x^{\\ast}_{X}(\\operatorname{id}_X) = F(\\operatorname{id}_X)(x) = x \nThere is one more thing to show. Starting with \\alpha \\colon y_{X} \\to F, consider the naturality square for f \\in y_{X}(Y).\n\n\n\nLet‚Äôs follow the path of \\operatorname{id}_{X} \\in y_{X}(X). Following the lower path, we get\n (\\alpha_{Y} \\circ y_{X}(f))(\\operatorname{id}_{X}) = \\alpha_{Y}(y_{X}(f)(\\operatorname{id}_{X})) = \\alpha_{Y}(\\operatorname{id}_{X} \\circ f) = \\alpha_{Y}(f) \nFollowing the upper path, we get\n (F(f) \\circ \\alpha_X)(\\operatorname{id}_X) = F(f)(\\alpha_X(\\operatorname{id}_X)) \nTherefore,\n \\alpha_Y(f) = F(f)(\\alpha_X(\\operatorname{id}_X)) \nThis says precisely that where f goes is wholly determined by where \\operatorname{id}_{X} goes, just like where \\operatorname{src} and \\operatorname{tgt} went was wholly determined by where \\operatorname{id}_{E} went! And more specifically,\n(\\alpha_{X}(\\operatorname{id}_{X}))^{\\ast} = \\alpha\nThus, we have our desired bijection\n F(X) \\cong \\operatorname{Hom}_{\\mathsf{Set}^{\\mathsf{C}}}(y_{X}, F) \n\nThe feeling that this seems like total abstract nonsense is a valid feeling at this point. It‚Äôs very much a tautology in the same way that A \\cong A^{1} is, except it‚Äôs confusing because there‚Äôs more stuff going on (incidentally, can you now see how A \\cong A^{1} is a corollary of the Yoneda lemma?)\nBut this actually turns out to be an extremely useful device. One application is something that I‚Äôve been using a lot; the fact that y_{X} \\cong y_{Y} if and only if X \\cong Y. In fact, we can show something stronger.\n\nGiven X,Y \\in \\mathsf{C}, there is a bijection \\operatorname{Hom}_{\\mathsf{C}}(Y,X) \\cong \\operatorname{Hom}_{\\mathsf{Set}^{\\mathsf{C}}}(y_{X}, y_{Y}).\n\nWith the Yoneda lemma, this is a very fast proof!\n\nProof.  \\operatorname{Hom}_{\\mathsf{C}}(X,Y) \\cong y_{X}(Y) \\cong \\operatorname{Hom}_{\\mathsf{Set}^{\\mathsf{C}}}(y_{Y}, y_{X}) \n\nAs an application of this, \\operatorname{Hom}_{\\mathsf{Gr}}(E,V) \\cong \\operatorname{Hom}_{\\mathsf{Set}^{\\mathsf{Gr}}}(y_{V}, y_{E}). You can see this because there are two morphisms E \\to V, and then two morphisms from y_{V} to y_{E}.\nThe point is that any isomorphism in \\operatorname{Hom}_{\\mathsf{Set}^{\\mathsf{C}}}(y_{Y}, y_{X}) must also show up as an isomorphism in \\operatorname{Hom}_{\\mathsf{C}}(X,Y).\nTo state this more formally, we can talk about y as a functor from \\mathsf{C} to \\mathsf{Set}^{\\mathsf{C}}. However, because of the flipping around of \\operatorname{Hom}_{\\mathsf{C}}(Y,X) \\cong \\operatorname{Hom}_{\\mathsf{Set}^{\\mathsf{C}}}(y_{X}, y_{Y}), this actually should be a contravariant functor, and we haven‚Äôt gotten to discussing duality yet. So we will leave off here for now!"
  },
  {
    "objectID": "lecture13.html#products",
    "href": "lecture13.html#products",
    "title": "Lecture 13: Products and typed products",
    "section": "Products",
    "text": "Products\nIn previous lectures, we covered colimits, which allowed you to take disjoint unions and to glue things together. In this lecture, we are going to cover limits, which allow you to make tuple types and to filter.\nLet‚Äôs start with an example.\nSuppose we are working in the category \\mathsf{FinSet}, and we implement it with\n\nstruct FinSet\n  n::Int\nend\n\nstruct FinFunction\n  dom::FinSet\n  codom::FinSet\n  values::Vector{Int}\nend\n\nGiven two finite sets A and B, we want to make a finite set A \\times B, such that an element of A \\times B consists precisely of an element of A along with an element of B. Well, the elements of any finite set in our representation are just natural numbers. So how do we make a natural number represent two natural numbers? This is the same problem encountered when trying to store a matrix in linear memory, and we will use a similar solution.\nNamely, if A = \\{1, \\ldots, n\\} and B = \\{1, \\ldots, m\\}, then we can make A \\times B = \\{1, \\ldots, mn\\}. Then for k \\in A \\times B, we get its two components as \\mathrm{div}(k, m) + 1 \\in A and \\mathrm{rem}(k, m) + 1 \\in B. Conversely, given i \\in A, j \\in B, we get (i - 1) m + j \\in A \\times B.\nWe formalize this construction using the idea of a product. Just like we characterized coproducts using maps out of them, we characterize products using maps in to them.\nIn order to do this properly, we need to talk about duals. But it will be easier to motivate duals once we have products, so let‚Äôs talk about products first.\n\nLet \\mathsf{C} be a category, and let A,B be objects of \\mathsf{C}. The product of A,B (if it exists) is then any object A \\times B along with morphisms \\pi_1 \\colon A \\times B \\to A, \\pi_2 \\colon A \\times B \\to B, such that for any object C with morphisms f \\colon C \\to A, g \\colon C \\to B, there is a unique map \\langle f, g \\rangle \\colon C \\to A \\times B such that the diagram below commutes.\n(fill in diagram)\nIf products exist for all pairs of objects, then we say that \\mathsf{C} has products.\n\n\nThe ‚Äúcategory‚Äù of Julia types and functions between them has products. The product of types A and B is Tuple{A,B}, whose elements are of the form (a,b) for a::A, b::B.\n\n\nThe category of graphs has products. The product of two graphs G and H has\n (G \\times H)(V) = G(V) \\times H(V)   (G \\times H)(E) = G(E) \\times H(E)   (G \\times H)(\\operatorname{src})((e_1, e_2)) = (G(\\operatorname{src})(e_1), H(\\operatorname{src})(e_2))   (G \\times H)(\\operatorname{tgt})((e_1, e_2)) = (G(\\operatorname{tgt})(e_1), H(\\operatorname{tgt})(e_2)) \n\n\n(product of interval graphs)\n(product of path graphs on interval)\n\n\nThe poset of subsets of a given set has products. The product of two subsets is their intersection."
  },
  {
    "objectID": "lecture13.html#typed-objects",
    "href": "lecture13.html#typed-objects",
    "title": "Lecture 13: Products and typed products",
    "section": "Typed objects",
    "text": "Typed objects\nWe‚Äôre now going to consider products in a special type of category.\n\nLet T be a set. A typed set with types in T is a set A along with a map t \\colon A \\to T. If (A,t), (A', t') are typed sets, then a morphism between them is a function f \\colon A \\to A' such that for all a \\in A, t(a) = t'(f(a)).\nOr in other words, the following commutes\n\n\n\n\n\nLet T = \\{a,b,c\\}. Then ‚Ä¶\n\n\nGiven a category \\mathsf{C} and an object T \\in \\mathsf{C}, let \\mathsf{C}/T be the category where the objects are pairs (A, t \\colon A \\to T) and the morphisms are commuting triangles\n\n\n\n\n\nRegNets as typed graphs\n\n\nTyped Petri nets"
  },
  {
    "objectID": "lecture13.html#typed-products",
    "href": "lecture13.html#typed-products",
    "title": "Lecture 13: Products and typed products",
    "section": "Typed products",
    "text": "Typed products\n\nLet‚Äôs work out what the product in \\mathsf{FinSet}/T is.\n\nFormal definition of typed product/pullback"
  },
  {
    "objectID": "lecture14.html#subsets-as-constraints",
    "href": "lecture14.html#subsets-as-constraints",
    "title": "Lecture 14: Relations",
    "section": "Subsets as constraints",
    "text": "Subsets as constraints\n\nWe start this book at the very beginning, by asking ourselves the question, What is a dynamical system\nDisregarding for a moment the dynamical aspects‚Äîforgetting about time‚Äîwe are immediately led to ponder the more basic issue, What is a mathematical model? What does it tell us? What is its mathematical nature? Mind you, we are not asking a philosophical question: we will not engage in an erudite discourse about the relation between reality and its mathematical description. Neither are we going to elucidate the methodology involved in actually deriving, setting up, postulating mathematical models. What we are asking is the simple question, When we accept a mathematical expression, a formula, as an adequate description of a phenomenon, what mathematical structure have we obtained?\nWe view a mathematical model as an exclusion law. A mathematical model expresses the opinion that some things can happen, are possible, while others cannot, are declared impossible. Thus Kepler claims that planetary orbits that do not satisfy his three famous laws are impossible. In particular, he judges nonelliptical orbits as unphysical. The second law of thermodynamics limits the transformation of heat into mechanical work. Certain combinations of heat, work, and temperature histories are declared to be impossible. Economic production functions tell us that certain amounts of raw materials, capital, and labor are needed in order to manufacture a finished product: it prohibits the creation of finished products unless the required resources are available.\nWe formalize these ideas by stating that a mathematical model selects a certain subset from a universum of possibilities. This subset consists of the occurrences that the model allows, that it declares possible. We call the subset in question the behavior of the mathematical model.\n‚Äî Jan Willem Polderman and Jan C. Willems, Introduction to Mathematical Systemcs Theory: A Behavioral Approach, 1998\n\nIn this lecture, we are going to learn some category theory for thinking about constraints.\nWe start at the beginning; what is a subset?\nWe can think about subsets of a set X categorically in two ways.\n\nA subset is a function \\chi \\colon X \\to \\{\\mathtt{true}, \\mathtt{false}\\} (we will henceforth refer to \\{\\mathtt{true}, \\mathtt{false}\\} with \\mathbb{B} for ‚ÄúBoolean‚Äù). \\chi is called a ‚Äúcharacteristic function‚Äù.\nA subset is another set U along with an injection \\iota_U \\colon U \\hookrightarrow X. We can think of this like an ‚ÄúX-typed set‚Äù, but with the restriction that there can be at most one element of each type.\n\nGiven a set U with an injection \\iota_U \\colon U \\hookrightarrow X, we can construct a characteristic function \\chi_U \\colon X \\to \\mathbb{B} via\n\n\\chi_U(x) = \\begin{cases}\n  \\mathtt{true} & \\text{if there exists $u \\in U$ with $\\iota_U(u) = x$} \\\\\n  \\mathtt{false} & \\text{otherwise}\n\\end{cases}\n\nLikewise, given a function \\chi \\colon X \\to \\mathbb{B}, we can construct\n |\\chi| = \\{ x \\in X | \\chi(x) = \\mathtt{true} \\} \nwith the natural inclusion |\\chi| \\hookrightarrow X.\nIf we start with a characteristic function, form its corresponding inclusion, and then take the characteristic function of that, we get back to where we started.\nHowever, if we start with the injection \\{a,b\\} \\hookrightarrow \\{1,2,3\\} with a \\mapsto 1, b \\mapsto 2, take its characteristic function, and then form its corresponding inclusion, we get \\{1,2\\} \\hookrightarrow \\{1,2,3\\}. This is isomorphic, but not equal.\nWhen we talk about subsets, we shouldn‚Äôt really care about \\{a,b\\} \\hookrightarrow \\{1,2,3\\} vs.¬†\\{1,2\\} \\hookrightarrow \\{1,2,3\\}. Thus, the characteristic function point of view is sometimes more useful because it gives us a canonical way of talking about a certain subset.\nThe advantage of the injection point of view is that we can talk about monomorphisms in any category, and thus talk about subobjects in any category, but a good analogue of \\mathbb{B} doesn‚Äôt exist in any category. Categories that have an analogue of \\mathbb{B} (along with some other properties) are called toposes or topoi (this is where the name Topos Institute comes from).\nFor now, we are going to just work with sets, and just work with the characteristic function point of view. But you should think about how you might generalize what we are doing to general subobjects.\n\nDefinition 1 Given a set X, there is a poset \\mathcal{P}(X) where the objects are maps \\chi \\colon X \\to \\mathbb{B}, and \\chi \\leq \\chi' if whenever \\chi(x) = \\mathtt{true} then \\chi'(x) = \\mathtt{true}.\n\n\nExample 1 We can think of a mathematical equation as specifying a subset. For instance, the equation\n y \\geq x^2 \nspecifies a subset of \\mathbb{R}^2 that looks like Figure¬†1.\nThis corresponds to the function\n\n\\chi(x,y) = \\begin{cases}\n  \\mathtt{true} & \\text{if $y \\geq x^2$} \\\\\n  \\mathtt{false} & \\text{otherwise}\n\\end{cases}\n\n\n\n\n\nFigure¬†1: A subset of \\mathbb{R}^2\n\n\n\nDefinition 2 If P is some statement, then we define [P] to be \\mathtt{true} if P is true, and \\mathtt{false} otherwise. So we can define the \\chi from Example¬†1 via\n \\chi(x,y) = [y \\geq x^2] \nThis is known as an ‚ÄúIverson bracket‚Äù.\n\n\nExample 2 ¬†\n\nconst FinSubset = BitVector\n\n# {1, 3} ‚äÜ {1, 2, 3}\nA = FinSubset([true, false, true])\n# {2, 3} ‚äÜ {1, 2, 3}\nB = FinSubset([false, true, true])\n(A,B)\n\n(Bool[1, 0, 1], Bool[0, 1, 1])"
  },
  {
    "objectID": "lecture14.html#operations-on-subsets",
    "href": "lecture14.html#operations-on-subsets",
    "title": "Lecture 14: Relations",
    "section": "Operations on subsets",
    "text": "Operations on subsets\n\nIntersection\nWhat happens if we have two equations? For instance, what if we have y \\geq x^2 and y \\leq 4 - x^2? Well, then we take the intersection of the two corresponding subsets (recall that the intersection is the categorical product).\n\nDefinition 3 Given two subsets \\chi_1, \\chi_2 \\colon X \\to \\mathbb{B}, their intersection is given by\n(\\chi_1 \\cap \\chi_2)(x) = \\chi_1(x) \\wedge \\chi_2(x)\nwhere \\wedge \\colon \\mathbb{B} \\times \\mathbb{B} \\to \\mathbb{B} is the AND operation.\n\nWe can do this in Julia by broadcasting the && operator.\n\nA .&& B\n\n3-element BitVector:\n 0\n 0\n 1\n\n\n\n\nPullback\nFunctions can act on subsets in a number of ways. Suppose that we have a function f \\colon X \\to Y, and a subset \\chi \\colon Y \\to \\mathbb{B}. Then we can simply compose to get a subset \\chi \\circ f \\colon X \\to \\mathbb{B}.\n\nDefinition 4 Given a function f \\colon X \\to Y and a subset \\chi \\colon Y \\to \\mathbb{B}, the pullback f^\\ast(\\chi) is defined to be \\chi \\circ f.\n\nThis is called ‚Äúpulling back‚Äù because in the subobject picture this corresponds to a categorical pullback operation. Sometimes this is also called the preimage.\n\nfunction preimage(f::FinFunction, U::FinSubset)\n  FinSubset([U[y] for y in f.values])\nend\n\nX, Y = FinSet(3), FinSet(3)\nf = FinFunction(X, Y, [2, 1, 1])\npreimage(f, A)\n\n3-element BitVector:\n 0\n 1\n 1\n\n\n\nExample 3 Consider the function f \\colon \\mathbb{R} \\to \\mathbb{R}^2 defined by f(x) = (x,x). Then if we pull back the \\chi in Example¬†1, we get the subset\n(f^\\ast(\\chi))(x) = \\chi(f(x)) = [x \\geq x^2] = [0 \\leq x \\leq 1]\n\n\nExample 4 Consider the function f \\colon \\mathbb{R}^3 \\to \\mathbb{R}^2 defined by f(x,y,z) = (x,z). Then pulling back \\chi from Example¬†1 gives us the subset\n(f^\\ast(\\chi))(x,y,z) = [z \\geq x^2]\nNote that this subset does not depend on y, because changing the value of y doesn‚Äôt affect the value of f(x,y,z).\n\nThe operation of pullback is nice from a categorical standpoint because it preserves the ordering of subsets.\n\nProposition 1 Suppose f \\colon X \\to Y is a function, and \\chi, \\chi' \\in \\mathcal{P}(Y) with \\chi \\subseteq \\chi'. Then f^\\ast(\\chi) \\subseteq f^\\ast(\\chi').\n\nProof. Let x \\in X, and suppose that f^\\ast(\\chi)(x) = \\mathtt{true}. Then \\chi(f(x)) = \\mathtt{true}. By \\chi \\subseteq \\chi', \\chi'(f(x)) = \\mathtt{true}. Thus, f^\\ast(\\chi')(x) = \\mathtt{true}.\n\n\nThis makes \\mathcal{P} into a contravariant functor from \\mathsf{Set} to \\mathsf{Pos}. This means that a morphism f \\colon X \\to Y turns into a order-preserving map f^\\ast \\colon \\mathcal{P}(Y) \\to \\mathcal{P}(X); the directionality gets flipped.\n\n\nDirect image\nIt turns out that we can also travel in the other direction.\n\nDefinition 5 Given a function f \\colon X \\to Y and a subset \\chi \\in \\mathcal{P}(X), there is a subset f_\\ast(\\chi) \\in \\mathcal{P}(Y) defined by\n f_\\ast(\\chi)(y) = [\\exists x \\in X, \\chi(x) \\wedge f(x) = y] \nThe subset f_\\ast(\\chi) is called the direct image of \\chi under f.\n\nThis also preserves the ordering of subsets, so with this, we get a another functor, this time covariant (i.e., normal), from \\mathsf{Set} \\to \\mathsf{Pos}.\nWe can implement this in Julia as well.\n\nfunction direct_image(f::FinFunction, U::FinSubset)\n  V = FinSubset(zeros(Bool, f.codom.n))\n  for i in 1:f.dom.n\n    if U[i]\n      V[f.values[i]] = true\n    end\n  end\n  V\nend"
  },
  {
    "objectID": "lecture14.html#relations",
    "href": "lecture14.html#relations",
    "title": "Lecture 14: Relations",
    "section": "Relations",
    "text": "Relations\nOne way of thinking about Example¬†1 is that we are expressing a relation between x \\in \\mathbb{R} and y \\in \\mathbb{R}.\n\nDefinition 6 A relation between a set X and a set Y is a subset R \\subset X \\times Y.\n\nWe could implement this in Julia using the notion of product that we had in the previous lecture. But the more convenient thing to do is to use BitMatrix.\n\nconst FinRelation = BitMatrix\n\nR = FinRelation([i &lt; j for i in 1:4, j in 1:4])\n\n4√ó4 BitMatrix:\n 0  1  1  1\n 0  0  1  1\n 0  0  0  1\n 0  0  0  0\n\n\nWe can think of this as a ‚Äújoint constraint‚Äù. If you know that (x,y) \\in R and you know the value of x, then you know something about the value of y, and vice versa. A special case of this is when knowing the value of x tells you exactly what y is; this is the next example.\n\nExample 5 Given a function f \\colon X \\to Y, we can make a relation \\mathrm{graph}(f) \\subset X \\times Y via\n \\chi_{\\mathrm{graph}(f)}(x,y) = [f(x) = y] \n\nThis gives rise to the natural question: given a relation R \\subset X \\times Y (which lets you know something about y if you know something about x) and a relation S \\subset Y \\times Z (which lets you know something about z if you know something about y) can we compose them in some way? The answer, unsurprisingly, is yes.\n\nDefinition 7 Given a relation R \\subset X \\times Y and a relation S \\subset Y \\times Z, we can form a relation\n S \\circ R \\subset X \\times Z\nvia the characteristic function\n \\chi_{S \\circ R}(x,z) = [\\exists y \\in Y, \\chi_R(x,y) \\wedge \\chi_S(y,z)] \n\nWe can implement this with something that looks suspiciously like matrix multiplication\n\nfunction compose(R::FinRelation, S::FinRelation)\n  n,m1,m2,l = (size(R)..., size(S)...)\n  @assert m1 == m2\n  m = m1\n  FinRelation([\n    any(R[i,j] && S[j,k] for j in 1:m)\n    for i in 1:n, k in 1:l\n  ])\nend\n\ncompose(R, R)\n\n4√ó4 BitMatrix:\n 0  0  1  1\n 0  0  0  1\n 0  0  0  0\n 0  0  0  0\n\n\nIf we replaced the any with a sum and the && with a *, this would be matrix multiplication.\nOf course, this forms a category.\n\nDefinition 8 There is a category \\mathsf{Rel} where:\n\nthe objects are sets\na morphism from X to Y is a relation R \\subset X \\times Y\ncomposition is as defined in Definition¬†7\nthe identity on X is the relation 1_X defined by  \\chi_{1_X}(x,x') = [x = x'] \n\n\nAs we said in the beginning, relations are very important for understanding the behavior of systems. We‚Äôve only scratched the surface of the category theory of relations, but this is important ground work for what is to come.\n\nExercise 1 Redo this whole lecture using the subobject point of view instead of the characteristic function part of view."
  },
  {
    "objectID": "lecture15.html",
    "href": "lecture15.html",
    "title": "Lecture 15: Cospans",
    "section": "",
    "text": "$$ \n\n\n$$\n\nIn the previous lecture, we learned about the category of relations, and we thought about subsets as a way of modeling the semantics of a system; a system consists of a universum and a behavior set. We are now going to start to think about syntax for systems.\nOur goal for the next couple lectures is to learn how to compose open graphs. Along the way, we will end up learning category theory tools for doing a variety of other things, but open graphs are the end goal.\n\nDefinition 1 An open graph is a graph G along with an input set I and an output set O and maps i \\colon I \\to G(V), o \\colon O \\to G(V).\n\n\n\n\nAn Open Graph\n\n\nWe want to make a category where the objects are finite sets and the morphisms are open graphs between the finite sets.\nWe are going to build up the technology for this category in parts. The first step is defining what a cospan category is. The second step is going to generalize this.\nOne way of a thinking about a relation R \\subset X \\times Y is that it is a span\n\n\n\nThere is a general principle that ‚Äúsyntax and semantics are dual‚Äù, which we won‚Äôt go into too far today, but it shows up in the fact that we are going to think about cospans today, as given in the next definition.\n\nDefinition 2 A cospan in a category \\mathsf{C} from an object X \\in \\mathsf{C} to an object Y \\in \\mathsf{C} is a diagram of the form\n\n\n\n\n\n\n\n\n\n\n\nCospan style\n\n\n\n\n\n\n\nUndirected wiring diagram style\n\n\n\n\nFigure¬†1: Two styles of drawing an undirected wiring diagram\n\n\n\nExample 1 We can visualize a cospan in \\mathsf{FinSet} in two different ways, as shown in Figure¬†1.\n\n\nDefinition 3 Let \\mathsf{C} be a category that has pushouts. Then define the category \\operatorname{Csp}(\\mathsf{C}) in the following way. The objects of \\operatorname{Csp}(\\mathsf{C}) are the objects of \\mathsf{C}, and a morphism from X to Y is a cospan from X to Y. Composition of two cospans\n\n\n\nis given by the pushout\n\n\n\n\nWhat is the identity in this category? I claim that the identity on X is\n\n\n\nLet‚Äôs prove that this is the case. Suppose that we have another cospan\n\n\n\nThen their composition is\n\n\n\nI want to show that A = X +_{X} A, and that the two upper morphisms are f and 1_A respectively.\nImmediately here, alarm bells should be going off in your head. Showing that two objects in a category are equal is almost always the wrong thing to do! Instead, one should show that two objects are isomorphic. But in this case, these ‚Äúobjects‚Äù are serving the purpose of morphisms, and morphisms need to be equal ‚Äúon the nose‚Äù! So what do we do?\nWe have to redefine \\operatorname{Csp}(\\mathsf{C}). There are two ways of doing this. One is that we can consider a notion of morphism between morphism, which gets us into bicategories. But we choose to not walk that route today.\nThe second way is to make a morphism from X to Y be an equivalence class of cospans.\n\nDefinition 4 The two cospans\n\n\n\nand\n\n\n\nare equivalent when there exists an isomorphism \\phi \\colon A \\to A' such that\n\n\n\ncommutes.\n\nWe then redefine \\operatorname{Csp}(\\mathsf{C}).\n\nDefinition 5 The category \\operatorname{Csp}(\\mathsf{C}) has as objects, objects of \\mathsf{C}, and as morphisms equivalence classes of cospans.\nGiven two morphisms E_{1} \\colon X \\to Y and E_{2} \\colon Y \\to Z, we compose them by picking a cospan from E_{1}, a cospan from E_{2}, taking their pushout, and then taking the equivalence class of all morphisms equivalent to that pushout.\n\nThere‚Äôs something very important that we have to check for this to work: we have to check that composing equivalent cospans give equivalent results! Proving this will enable us to flex some of our theoretical muscles for pushouts.\n\nDefinition 6 Suppose that we have the following commuting diagram:\n\n\n\nwhere \\phi and \\psi are isomorphisms. Then there is an isomorphism \\phi +_Y \\psi \\colon A +_Y B \\to A' +_Y B' such that the diagram\n\n\n\ncommutes.\n\n\nProof. This is our first big serious proof in category theory, so before we get started, let‚Äôs just make sure we understand where we are and where we‚Äôre going.\nThe diagrams above look big and scary, but when we chunk them, they aren‚Äôt so bad. We have two pairs of equivalent cospans: two equivalent cospans between X and Y, and two equivalent cospans between Y and Z. Then we‚Äôve composed each one, to get the top and bottom of the diagram, and finally the curved arrow is an isomorphism between the composed cospans.\nOften in proofs like this, it is hard to know where to start. One good thing to do is to go back to definitions.\nLet \\mathsf{D} be the category that looks like this\n\n\n\nLet F, F' be functors from \\mathsf{D} into \\mathsf{C} that send\n\n\n\nto\n\n\n\nand\n\n\n\nrespectively.\nThen recall that the pushout of the diagram F is a representing object for the functor\nX \\mapsto \\operatorname{Hom}_{\\mathsf{C}^{\\mathsf{D}}}(F, \\Delta X)\nwhich sends an object X to the set of natural transformations from F to the constant functor at X, i.e.¬†commuting diagrams\n\n\n\nwhich are the same as commuting squares\n\n\n\nNow, I claim that if we can show that F and F' are naturally isomorphic functors, then the pushout of F and the pushout of F' will be isomorphic as well.\nThis is because if F \\cong F', then \\operatorname{Hom}_{C^{\\mathsf{D}}}(F, \\Delta-) \\cong \\operatorname{Hom}_{C^{\\mathsf{D}}}(F', \\Delta-), and representing objects of isomorphic functors are isomorphic (that‚Äôs Yoneda, baby!).\nTo show that F and F' are naturally isomorphic, we must construct a natural isomorphism. This consists of an isomorphism F(x) \\cong F'(x) for each x \\in \\mathsf{D}, chosen to satisfy the naturality condition. But we are given exactly what we need by our assumption! Namely, we make the following natural isomorphism:\n\n\n\nNow, through what some might call ‚Äúabstract nonsense‚Äù, we have summoned an isomorphism from A +_{Y} B to A' +_{Y} B': we will call this isomorphism \\phi +_{Y} \\psi.\nThis is not enough though: we still have to show that the whole diagram commutes! Unfortunately, I can‚Äôt think of a slick way to do this quickly, so instead I will summarize the strategy. Basically, you have to trace through the proof that isomorphic functors give isomorphic representing objects, and you will see that the construction of the isomorphism shows that this should commute."
  }
]