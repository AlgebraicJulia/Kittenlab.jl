[
  {
    "objectID": "index.html",
    "href": "index.html",
    "title": "Kittenlab lecture notes",
    "section": "",
    "text": "Introduction\nThis is a Quarto book.\nTo learn more about Quarto books visit https://quarto.org/docs/books."
  },
  {
    "objectID": "lecture1.html",
    "href": "lecture1.html",
    "title": "Lecture 1: Formal Math",
    "section": "",
    "text": "Introduction\nThese lectures are meant to go from 0 to category theory as efficiently as possible. This means that we are going to optimize for being precise, for being clear, and for opening up new possibilities for you. We are not going to optimize for being entertaining or engaging; this is not a ‚Äúmonads as burritos‚Äù blog post or a popsci article about category theory. The answer to ‚Äúwhy do we care about this‚Äù is often going to be ‚Äúbecause it‚Äôs important later on‚Äù, and you are just going to have to trust me on that.\nAs we are going from 0, in this first lecture I plan to get you all aquainted with what it even means to ‚Äúdo math‚Äù at the level that category theory lives. This is a different kind of math than what you might have learned about in lower level math courses, and so sorting out from the beginning the mindset that you should have for the rest of the lectures is the most efficient use of this time. Generally, nobody tells you about this distinction and you have to work it out painfully over years of getting bad grades on university math homeworks; we don‚Äôt have time for that.\nHowever, we will have code examples for you to play with, because most of you are programmers and thus making a connection between math and code should speed the learning process.\nFinally, everyone at some point in this lecture will be frustrated by how pedantic I‚Äôm being. Sorry. I‚Äôm erring on the side of pedantry because there‚Äôs a ‚Äúprice is right‚Äù situation here: if I go too slow, we waste a bit of time, but if I go too fast we waste all of the time.\nPure math consists of a series of definitions, propositions, and examples. In this document, we typeset these like\nA definition introduces a new word, and I will always put that new word in bold. In normal speech, words have meanings given by context, by association, and only sometimes by explicit definition. In math, it is not like that. Every technical word has a single definition. That definition may not be written down explicitly; it may be agreed implicitly between mathematicians based on shared experience. However, in theory there is always a precise definition for every mathematical concept. It is expected that all participants in a mathematical conversation could be locked up in a cell, given paper, a pencil and a great deal of time, and then write down a fully rigorous formulation of each of the words they are using. Moreover, each of these formulations for each of the mathematicians might not be exactly the same, but they should be able to be proven equivalent.\nUntil you learn mathematical logic, which we will not cover here, this expectation cannot be realized because you don‚Äôt know a precise definition of ‚Äúfully rigorous‚Äù. The level of rigor that will suffice for now is that you should be able to expand every definition to a level where it can be explained to a smart, patient human who knows no category theory, by going backwards and defining each of the terms used in that definition until you get to very basic concepts, like sets, functions, and equations.\nThe extremely important corollary to all of this is that if you feel like your understanding of a definition does not reach this level, YOU ARE CONFUSED. This is OK. It is good to be confused. It is far better to be confused and not yet wrong than it is to be unconfused and wrong.\nWhat should you do when you are confused? First of all, GO BACKWARDS. Read the previous section of a textbook. If you are still confused, keep going backwards until you hit something that makes sense, and then work your way back up. Secondly, GO SIDEWAYS. Read another textbook that treats the same material in a different way. Then finally, if neither of those work, ASK AN EXPERT, and keep asking until you feel unconfused. The MOST IMPORTANT SKILL in math is to know when you are confused and don‚Äôt continue until you are unconfused! If you continue on, you will get hopelessly confused; if you turn back immediately there is still hope.\nDefinitions are the most important part of higher math. Understanding the definitions is often half the battle, and it is most of the battle for category theory.\nA proposition is an assertion that one logical statement (the conclusion) follows from several logical statements (the premises). Each proposition comes along with a proof. Just like definitions, it is expected that the participants in a mathematical conversation could expand a proof out to a fully rigorous level, even if the given proof is very vague. What you write down as a proof should be seen as a ‚Äúhint‚Äù for the construction of the actual, fully rigorous proof; mathematicians come to cultural agreements for how much of a hint is needed in different circumstances.\nAs a mathematical learner, proofs are your window into the thought processes of subject experts. Thus, they are very good to study and understand. However, they are not as critical to understand as definitions. It is absolutely essential to fully understand definitions, but proofs can be ‚Äúblackboxed‚Äù sometimes, and you can just remember the proposition without understanding fully the proof.\nPropositions are also known as theorems, lemmas, and corollaries. A theorem is an important proposition, a lemma is a small proposition mainly used to prove other propositions, and a corollary is a proposition whose proof is easy because of another proposition, for example a special case. Really, these are just vibes that mathematicians add to propositions.\nFinally, an example is a definition or proposition that falls under one of three categories.\nA pure math document consists of a sequence of definitions, propositions, and examples, punctuated with interleaving prose that attempts to give intuition for what the definitions, propositions, and examples are saying, and why one should care about those definitions, propositions, and examples. Intuition is a very important part of math; it is what allows mathematicians to elaborate definitions, discover proofs, and most importantly, to figure out what is important to study in the first place. However, intuition is no substitute for rigor. Intuition allows you to leap off cliffs; rigor is what allows you to build a bridge underneath you before you hit the ground.\nIn the foundations of math, we also have two more types of statement: axioms and undefined terms. Definitions and propositions should always ‚Äúbottom out‚Äù at axioms and undefined terms. However, most mathematicians do not do this, instead leaving it to the reader to choose a suitable foundations of math in which to fully formalize their theories. Surprisingly, most interesting math can be fully formalized in many foundations, so this normally works out fine.\nFor us, our ‚Äúreality‚Äù will be what happens on the computer. So we will try to ‚Äúbottom out‚Äù on concepts in the computer.\nWe will now demonstrate the previous concepts by studying finite sets. We will not get to category theory today. Instead, we will revisit some things that should be familiar to you and treat them in the style that we will be using for the rest of the lectures.\nFinite sets will be important for most of the applications of category theory that we will learn in the next lectures, and also most of the concepts of category theory are well-illustrated by finite sets. So a firm grasp of finite sets will be an immense aid in the coming weeks.\nWe start with a basic universe of discourse. It is traditional to be minimalistic with this universe of discourse, and say that everything is a set, or everything is a natural number. However, we choose to be untraditional.\nWe might represent this in Julia with the following data structure.\nNote that this is not the only possible representation of a finite set. Definitions in math always can be translated into code in many ways; the choice of a particular way is a delicate balancing act between simplicity, performance, clarity, and completeness.\nAnother possible representation of finite sets is\nThis represents the finite set \\(\\{1,\\ldots,n\\}\\). Here we have traded performance over completeness; we can only represent some finite sets, but we represent those finite sets more efficiently.\nIt is important to note that even if \\(a\\) is listed multiple times in \\(A\\), \\(f(a)\\) only has one value.\nWe might represent a function between ùîΩs, also known as a morphism of finite sets, with the following data structure.\nHowever, not all instances of this data structure represent functions. The following Julia function determines whether a morphism of finite sets is valid.\nFrequently we will write down Julia types representing mathematical concepts where not all values of that type are valid representations of that mathematical concept. This is unavoidable because Julia types do not have the specificity to narrow down the space of values enough. There are languages where the types can narrow down the space of values sufficiently, but none of those languages have well-maintained BLAS/LAPACK bindings.\nFor finite sets implemented by IntùîΩ, we can give a more efficient encoding of morphism.\nwith corresponding validation function\nFrom now on, we will work with only VecùîΩs and ùîΩMors, and leave the implementation of more efficient code to the reader."
  },
  {
    "objectID": "lecture1.html#takeaways",
    "href": "lecture1.html#takeaways",
    "title": "Lecture 1: Formal Math",
    "section": "Takeaways",
    "text": "Takeaways\n\nPure math consists of definitions, propositions, and examples.\nThese are specified in enough detail so that participants in a mathematical conversation could independently come up with equivalent elaborations.\nIf you feel you could not do this at any point, then you are in a perfectly normal situation and should not feel ashamed whatsoever. However, continuing on without first going back and understanding what you are confused about is a bad idea."
  },
  {
    "objectID": "lecture1.html#takeaways-1",
    "href": "lecture1.html#takeaways-1",
    "title": "Lecture 1: Formal Math",
    "section": "Takeaways",
    "text": "Takeaways\n\nA finite set is a list of things\nA morphism of finite sets from \\(A\\) to \\(B\\) sends each unique element of \\(A\\) to an element of \\(B\\)\nThere are multiple ways of implementing representations of finite sets and morphisms between them on the computer"
  },
  {
    "objectID": "lecture2.html",
    "href": "lecture2.html",
    "title": "Lecture 2: The Category Theory of Finite Sets",
    "section": "",
    "text": "Composition and Isomorphisms\nWe now introduce the operation at the core of all category theory: composition!\nWe now come to an issue that is everywhere in category theory: equality. If you have seen any set theory before, you might think that \\(\\{1,2,3,3\\}\\) and \\(\\{3,2,1\\}\\) are ‚Äúthe same‚Äù set. Note however that when I defined finite set, I just said that a finite set was a list of things surrounded by curly braces.\nSo it seems like something is wrong with our definition.\nBut let‚Äôs think about why we typically choose to make \\(\\{1,2,3,3\\}\\) and \\(\\{3,2,1\\}\\) ‚Äúthe same‚Äù set. One good reason is that any morphism out of \\(\\{1,2,3,3\\}\\) can be seen as a morphism out of \\(\\{3,2,1\\}\\), and the same goes for incoming morphisms.\nTherefore, from a ‚Äúmorphism‚Äôs-eye‚Äù perspective, \\(\\{1,2,3,3\\}\\) and \\(\\{3,2,1\\}\\) behave the exact same way; defining a morphism out of one is the same as defining a morphism out of the other.\nBut if we take this to its logical conclusion, we find that this is true not only of \\(\\{1,2,3,3\\}\\) and of \\(\\{3,2,1\\}\\), but also of \\(\\{1,2,3\\}\\) and \\(\\{\\mathbf{a},\\mathbf{b},\\mathbf{c}\\}\\)!\nTo see this, let \\(B = \\{1,2,3\\}\\), \\(B^\\prime = \\{\\mathbf{a}, \\mathbf{b}, \\mathbf{c}\\}\\), and define \\(f \\colon B \\to B^\\prime\\) and \\(g \\colon B^\\prime \\to B\\) by\n\\[ f(x) = \\begin{cases}\n  \\mathbf{a} & \\text{if $x = 1$} \\\\\n  \\mathbf{b} & \\text{if $x = 2$} \\\\\n  \\mathbf{c} & \\text{if $x = 3$}\n\\end{cases} \\]\n\\[ g(y) = \\begin{cases}\n  1 & \\text{if $y = \\mathbf{a}$} \\\\\n  2 & \\text{if $y = \\mathbf{b}$} \\\\\n  3 & \\text{if $y = \\mathbf{c}$}\n\\end{cases} \\]\nThen given \\(h \\colon B \\to C\\), we can produce \\(h^\\prime \\colon B^\\prime \\to C\\) via \\(h^\\prime = h \\circ g\\), and vice versa. Moreover, when we start out with a function out of \\(B\\), compose it with \\(g\\) to make a function out of \\(B^\\prime\\) and then compose it with \\(f\\) to make a function out of \\(B\\), we get the same function back.\nAll of this motivates the next few definitions.\nYou can remember the reasoning for why the name ‚Äúisomorphic‚Äù by thinking ‚Äúisomorphic = same morphisms‚Äù. That is, if we have an isomorphism between \\(A\\) and \\(A^\\prime\\), then there are ‚Äúthe same morphisms‚Äù out of \\(A\\) and out of \\(A\\prime\\).\nHowever, as noted before, there might be several distinct isomorphisms between \\(A\\) and \\(A^\\prime\\). Thus, one must be careful to specify which isomorphism when you are talking about isomorphic finite sets.\nAnyways, this is why it‚Äôs not a terrible problem to use a vector to represent a finite set. There are only rare cases where you can find a representation of your mathematical objects such that two representations are equal if and only if the mathematical objects are isomorphic. If you are lucky enough to find this, it‚Äôs called a ‚Äúcanonical form‚Äù and it‚Äôs a big deal. As a practical matter, we might use Set instead of Vector because it gets a bit closer to a canonical form, but I wanted to start with Vector to make the point that the representation of your mathematical object on a computer in general will not be canonical.\nWe now discuss some more properties of finite sets and their maps.\nThis is a good opportunity to discuss something very critical in math: ordering of quantifiers. Quantifiers are phrases like ‚Äúfor every ‚Ä¶‚Äù or ‚Äúthere exists ‚Ä¶‚Äù. In the previous definition, if we had instead said ‚Äúthere exists an \\(a \\in A\\) such that for every \\(b \\in B\\), \\(f(a) = b\\)‚Äù, this could only be true if \\(B\\) had only a single element! The fact that the ‚Äúthere exists‚Äù comes after the ‚Äúfor every‚Äù allows us to choose a different \\(a\\) for each \\(b\\).\nWe wrap up this section with a way of telling when there exists any isomorphisms between two finite sets.\nThe point of this first lecture is to introduce you to finite sets and pure math, not category theory. Therefore, we end with a discussion of a theorem from combinatorics."
  },
  {
    "objectID": "lecture2.html#takeaways",
    "href": "lecture2.html#takeaways",
    "title": "Lecture 2: The Category Theory of Finite Sets",
    "section": "Takeaways",
    "text": "Takeaways\n\nYou can compose morphisms between finite sets\nIsomorphisms tell you which finite sets are equivalent from the point of view of morphisms"
  },
  {
    "objectID": "lecture2.html#takeaways-1",
    "href": "lecture2.html#takeaways-1",
    "title": "Lecture 2: The Category Theory of Finite Sets",
    "section": "Takeaways",
    "text": "Takeaways\n\nThere are two special classes of functions: injections and surjections\nIf something is an injection and a surjection, it is an isomorphism\nYou can tell which finite sets are isomorphic by looking at their cardinalities"
  },
  {
    "objectID": "lecture2.html#takeaways-2",
    "href": "lecture2.html#takeaways-2",
    "title": "Lecture 2: The Category Theory of Finite Sets",
    "section": "Takeaways",
    "text": "Takeaways\n\nYou can do basic combinatorics in the framework we have developed in this lecture"
  },
  {
    "objectID": "lecture3.html",
    "href": "lecture3.html",
    "title": "Lecture 3: Category Theory",
    "section": "",
    "text": "Julia from last lecture\n\n\nabstract type ùîΩ end\n\nstruct VecùîΩ <: ùîΩ\n  elems::Vector{Any}\nend\n\nBase.:(‚àà)(a, A::VecùîΩ) = a ‚àà A.elems\n\nBase.iterate(A::VecùîΩ) = iterate(A.elems)\nBase.iterate(A::VecùîΩ, k) = iterate(A.elems, k)\nBase.length(A::VecùîΩ) = length(A.elems)\n\nstruct IntùîΩ <: ùîΩ\n  n::Int\nend\n\nBase.:(‚àà)(a, A::IntùîΩ) = 1 <= a <= A.n\n\nBase.iterate(A::IntùîΩ) = iterate(1:A.n)\nBase.iterate(A::IntùîΩ, k) = iterate(1:A.n, k)\n\nstruct ùîΩMor\n  dom::ùîΩ\n  codom::ùîΩ\n  vals::Dict{Any,Any}\nend\n\n(f::ùîΩMor)(x) = f.vals[x]\n\nstruct IntùîΩMor\n  dom::IntùîΩ\n  codom::IntùîΩ\n  vals::Vector{Int}\nend\n\n(f::IntùîΩMor)(i) = f.vals[i]\n\n\n\nSets\nToday we will be moving on from finite sets to talk about sets which are possibly infinite. Infinite sets are a controversial topic; they don‚Äôt exist as tangibly as finite sets, and generally are much trickier to compute with. For a mathematician, this is not a problem; they write down formulas for infinite sets in precisely the same way they wrote down formulas for finite sets.\nThe crucial difference between finite sets and infinite sets is that any ‚Äúfor all‚Äù statement on an infinite set is not checkable by listing out every element of the set and checking that a property holds of each of them. Relatedly, any ‚Äúexists‚Äù statement is likewise not checkable. This seems kind of obvious, but it means that naive extensions of algorithms from the case of finite sets to the case of infinite sets often fails.\nThus, on a computer infinite sets have a very different feel than finite sets.\nIn traditional foundations, everything is built out of sets. But, as we said in the previous lecture, this is unnecessarily strict. We are instead taking Julia to be our foundation, so that we will have primitive things that are not themselves sets. This is a much saner foundation, because while it might be technically possible to build, say, a real number out of sets, nobody really wants to do that.\n\nA set \\(X\\) consists of a function from Any to Bool, which may or either be written in Julia or defined mathematically. If \\(X(x) = \\mathbf{true}\\), we write \\(x \\in X\\), and if \\(X(x) = \\mathbf{false}\\) we write \\(x \\notin X\\).\n\nNote that when we write down Julia definitions involving sets, we are implicitly assuming that the functions are written in Julia. However, there are some sets that we will use whose functions cannot be written down in Julia, so take the Julia definitions with a grain of salt. If the function defining a set can be written in Julia, we say that set is computable, and otherwise the set is uncomputable.\nObviously, we can only model the computable sets in Julia, but the uncomputable sets are still useful for talking about Julia.\n\nabstract type ComputableSet end\n\n# We expect any subtype of ComputableSet to have in defined on it.\nBase.in(x, s::ComputableSet) = error(\"no specific definition found\")\n\n\nFor any finite set \\(A\\), let \\(\\chi_{A}\\) be defined by \\(\\chi_{A}(x) = \\mathbf{true}\\) if \\(x\\) is listed in \\(A\\) and \\(\\mathbf{false}\\) otherwise. Then \\(\\chi_{A}\\) is a set.\n\n\nAny Julia type T defines a set, via the function which checks whether a Julia value has that type.\n\n\nstruct FiniteSet <: ComputableSet\n  A::ùîΩ\nend\n\nBase.in(x, œá::FiniteSet) = x ‚àà œá.A\n\nstruct TypeSet <: ComputableSet\n  T::Type\nend\n\nBase.in(x, œá::TypeSet) = x isa œá.T\n\n\nGiven two sets \\(A\\) and \\(B\\), the set \\(A \\to B\\) consists of all Julia callables \\(f\\) such that \\(f(a) \\in B\\) for all \\(a \\in A\\). Note that\n\nNote that even if A and B are computable sets, there is no way to check in Julia that a given f is an element of \\(A \\to B\\) because this would involve iterating through possibly infinitely many elements of \\(A\\). Again, languages where this is not the case don‚Äôt have good ODE solvers.\n\nGiven two sets \\(X\\) and \\(Y\\), their intersection \\(X \\cap Y\\) is defined by\n\\[ (X \\cap Y)(x) = X(x) \\wedge Y(x) \\]\nTheir union \\(X \\cup Y\\) is defined by\n\\[ (X \\cup Y)(x) = X(x) \\vee Y(x) \\]\n\n\nstruct IntersectionSet\n  X::ComputableSet\n  Y::ComputableSet\nend\n\nBase.in(x, œá::IntersectionSet) = x ‚àà œá.X && x ‚àà œá.Y\n\nstruct UnionSet\n  X::ComputableSet\n  Y::ComputableSet\nend\n\nBase.in(x, œá::UnionSet) = x ‚àà œá.X || x ‚àà œá.Y\n\n\nGiven two sets \\(X\\) and \\(Y\\), their product \\(X \\times Y\\) is the set of tuples \\((x,y)\\) where \\(x \\in X\\) and \\(y \\in Y\\). That is, \\(z \\in X \\times Y\\) if and only if z isa Tuple, length(z) = 2, \\(z[1] \\in X\\) and \\(z[2] \\in Y\\).\n\n\nproduct(X,Y) = z -> (z isa Tuple) &&\n  length(z) == 2 && X(z[1]) && Y(z[2])\n\n\nWe leave it to the reader to give a mathematical definition for sum given the following definition in Julia\n\n\nstruct Left\n  val::Any\nend\n\nstruct Right\n  val::Any\nend\n\nsum(X,Y) = x ->\n  if x isa Left\n    X(x.val)\n  elseif x isa Right\n    Y(x.val)\n  else\n    false\n  end\n\nWe will now move on to categories. But I would like to make one brief point first, which is that there is no set of all sets. This is because not all sets correspond to Julia values, as we consider uncomputable sets to be sets. But there is a set of all computable sets.\n\n\nCategories\nThe moment we‚Äôve all be waiting for.\n\nA small category \\(C\\) consists of\n\na set \\(C_0\\) of objects\nfor every \\(x,y \\in C_0\\), a set \\(\\mathrm{Hom}_C(x,y)\\) of morphisms from \\(x\\) to \\(y\\)\nfor every \\(x,y,z \\in C_0\\), a composition function \\(\\circ \\colon \\mathrm{Hom}_C(y,z) \\times \\mathrm{Hom}_(x,y) \\to \\mathrm{Hom}(x,z)\\)\nfor every \\(x \\in C_0\\), an identity morphism \\(1_x \\in \\mathrm{Hom}_C(x,x)\\)\n\nsuch that\n\nfor all \\(x,y,z,w \\in C_0\\), \\(f \\in \\mathrm{Hom}_C(x,y)\\), \\(g \\in \\mathrm{Hom}_C(y,z)\\), \\(h \\in \\mathrm{Hom}_C(z,w)\\), \\[ h \\circ (g \\circ f) = (h \\circ g) \\circ f \\]\nfor all \\(x,y \\in C_0\\), \\(f \\in \\mathrm{Hom}_C(x,y)\\), \\[ 1_y \\circ f = f = f \\circ 1_x \\]\n\nThese two laws are called the associativity law and unitality law respectively.\n\n(Julia to be livecoded)\n\nThere is a category \\(\\mathsf{Fin}\\) where the objects are finite sets and the morphisms are morphisms of finite sets, as defined in the previous lecture.\n\n(Julia to be livecoded)\n\nThere is a category where the objects are natural numbers and a morphism from \\(n\\) to \\(m\\) is a \\(n \\times m\\) matrix. Composition of a \\(n \\times m\\) matrix and an \\(m \\times r\\) matrix is done by matrix multiplication.\n\n(Julia to be livecoded)\n\nA graph consists of a finite set of vertices, a finite set of edges, and a source and target map from vertices to edges. Given any graph, there is a ‚Äúfree category‚Äù on that graph, where the objects are vertices and the morphisms are paths.\n\n(Julia to be livecoded)"
  },
  {
    "objectID": "lecture4.html#review-in-kittenlab-syntax",
    "href": "lecture4.html#review-in-kittenlab-syntax",
    "title": "Lecture 4: Functors",
    "section": "Review in Kittenlab syntax",
    "text": "Review in Kittenlab syntax\nIn this lecture, we are finally going to start using the Kittenlab.jl library. We weren‚Äôt using Kittenlab up until now so that I could show you a variety of design tradeoffs, and so that you were learning concepts rather than a specific instantiation of those concepts, but now it becomes worth it to start building up a coherent library instead of starting from scratch every time.\nWe start by giving the Julia definition of category that we will be using now.\n\ninclude(\"../src/Categories.jl\")\nusing .Categories\n\nThis declares an abstract type for category\nabstract type Category{Ob, Hom} end\nalong with the following methods that should be implemented on any subtype of that abstract type.\n# Note: this is not executed; this is just to show expected type signatures\ndom(c::Category{Ob, Hom}, f::Hom)::Ob\ncodom(c::Category{Ob, Hom}, f::Hom)::Ob\ncompose(c::Category{Ob, Hom}, f::Hom, g::Hom)::Hom\nid(c::Category{Ob, Hom}, x::Ob)::Hom\nIn Kittenlab, we have chosen a ‚Äúmiddle path‚Äù between having everything be fully dynamic and trying to put as much as possible into the type system. We use the Julia type system to guide our implementations, to provide documentation, and to resolve dispatch, but we do not rely on it for correctness.\nIf C is a subtype of Category{Ob,Hom}, then we expect that the set of objects for the actual mathematical category is a subset of Ob.\nMoreover, we expect the hom-set from x :: Ob to y :: Ob to be some subset of the elements f :: Hom with dom(f) == x and codom(f) == y.\nThis ‚Äúmiddle path‚Äù is fairly convenient, because often there is a good choice of the types Ob and Hom that makes the category fairly ergonomic to use, in that most or all of the elements of Ob are actually objects of the category, and the same for Hom. Additionally, having more specific types will allow Julia to produce more efficient code.\nWe use slightly different definitions for the category of finite sets, following these principles.\n\ninclude(\"../src/FinSets.jl\")\nusing .FinSets\n\nNamely, we declare\nconst FinSet = AbstractSet\n\nstruct FinFunction{S,T}\n  dom::FinSet{S}\n  codom::FinSet{T}\n  values::AbstractDict{S,T}\nend\nWe simplified our design hierarchy in one way (removing the abstract types), and complicated it in another way (adding type parameters); this is a more pragmatic and less flexible approach.\nWe now declare a category of finsets and finfunctions to go along with this:\nstruct FinSetC <: Category{FinSet, FinFunction}\nend\n\nCategories.dom(::FinSetC, f::FinFunction) = f.dom\n\nCategories.codom(::FinSetC, f::FinFunction) = f.codom\n\nfunction Categories.compose(\n  ::FinSetC,\n  f::FinFunction{S,T}, g::FinFunction{T,R}\n) where {S,T,R}\n  @assert f.codom == g.dom\n  FinFunction(f.dom, g.codom, Dict(x => g(f(x)) for x in f.dom))\nend\n\nfunction Categories.id(::FinSetC, X::FinSet{S}) where {S}\n  FinFunction{S,S}(X,X,Dict(x => x for x in X))\nend\nHopefully, at this point the new conventions that we are using should make sense, so we are going to move on to functors!"
  },
  {
    "objectID": "lecture4.html#functors",
    "href": "lecture4.html#functors",
    "title": "Lecture 4: Functors",
    "section": "Functors",
    "text": "Functors\nCategory theory is all about studying the objects of a category by studying the morphisms between them. So consequently, the study of functors (which are the morphisms between categories) is critical to the studying of categories!\n\nLet \\(\\mathsf{C}\\) and \\(\\mathsf{D}\\) be categories. A functor \\(F\\) from \\(\\mathsf{C}\\) to \\(\\mathsf{D}\\), often written \\(F \\colon \\mathsf{C} \\to \\mathsf{D}\\), consists of:\n\nA function \\(F_0 \\colon \\mathsf{C}_0 \\to \\mathsf{C}_0\\). If \\(x \\in \\mathsf{C}_0\\), we often write \\(F_0(x)\\) as \\(F(x)\\).\nFor every \\(x,y \\in \\mathsf{C}_0\\), a function \\(F_{x,y} \\colon \\mathrm{Hom}_{\\mathsf{C}}(x,y) \\to \\mathrm{Hom}_{\\mathsf{C}}(F(x),F(y))\\). If \\(f \\in \\mathrm{Hom}_{\\mathsf{C}}(x,y)\\), we often write \\(F_{x,y}(f)\\) as \\(F(f)\\).\n\nsuch that the following two laws hold:\n\nFor all \\(x \\in \\mathsf{C}_0\\), \\(1_{F(x)} = F(1_x)\\)\nFor all \\(x,y,z \\in \\mathsf{C}_0\\), \\(f \\colon x \\to y\\), \\(g \\colon y \\to z\\), \\(F(g \\circ f) = F(g) \\circ F(f)\\).\n\n\nWe implement this with the following Julia.\n\ninclude(\"../src/Functors.jl\")\nusing .Functors\n\nThe declaration of functor is the following.\nabstract type Functor{C<:Category, D<:Category} end\n\nfunction ob_map(F::Functor{C,D}, x::ObC)::ObD where\n    {ObC, ObD, C<:Category{ObC}, D<:Category{ObD}}\n  error(\"unimplemented\")\nend\n\nfunction hom_map(F::Functor{C,D}, f::HomC)::HomD where\n    {ObC, HomC, ObD, HomD, C<:Category{ObC, HomC}, D<:Category{ObD, HomD}}\n  error(\"unimplemented\")\nend\n \n# KittenC is the category of Julia-implemented categories and functors\n\nstruct KittenC <: Category{Category, Functor}\nend\n\nfunction Categories.dom(::KittenC, F::Functor{C,D})::C where {C,D}\n  error(\"unimplemented\")\nend\n\nfunction Categories.codom(::KittenC, F::Functor{C,D})::D where {C,D}\n  error(\"unimplemented\")\nend\nThere are some critical subtleties in this declaration.\nFirst of all, functor is an abstract type parameterized by the types of its domain and codomain categories. Crucially, it is not parameterized by the domain and codomain categories! In the case that these types are singletons, this is an academic distinction. But later on, we will have structs that are subtypes of Category that are not singletons, where there is dynamic data in the category, and then dom and codom will be meaningful. The reason we have the types of the categories in the abstract type for functor is that we can then extract the types of the objects and morphisms for each category.\nSecondly, we have declared a category KittenC of categories and functors. Technically speaking, this is the category of ‚Äúcategories and functors that are implemented in Julia‚Äù; we reserve the category \\(\\mathsf{Cat}\\) for the category of all (small) categories. But this category is not complete yet: we need to be able to compose functors and take identity functors!\nWe first handle this mathematically.\n\nGiven three categories \\(\\mathsf{C}\\), \\(\\mathsf{D}\\) and \\(\\mathsf{E}\\), along with two functors \\(F \\colon \\mathsf{C} \\to \\mathsf{D}\\) and \\(G \\colon \\mathsf{D} \\to \\mathsf{E}\\), there is a functor \\(G \\circ F \\colon \\mathsf{C} \\to \\mathsf{E}\\) defined in the following way.\n\nFor \\(x \\in \\mathsf{C}_0\\), \\((G \\circ F)(x) = G(F(x))\\)\nFor \\(x,y \\in \\mathsf{C}_0\\), \\(f \\colon x \\to y\\), \\((G \\circ F)(f) = G(F(f))\\)\n\nWe now show that \\(G \\circ F\\) preserves composition and identities. Suppose that \\(x \\in \\mathsf{C}_0\\). Then\n\\[(G \\circ F)(1_x) = G(F(1_x)) = G(1_{F(x)}) = 1_{G(F(x))} = 1_{(G \\circ F)(x)}\\]\nMoreover, if \\(x,y,z \\in \\mathsf{C}_0\\), and \\(r \\colon x \\to y\\) and \\(s \\colon y \\to z\\), then\n\\[(G \\circ F)(s \\circ r) = G(F(s \\circ r)) = G(F(s) \\circ F(r)) = G(F(s)) \\circ G(F(r)) = (G \\circ F)(s) \\circ (G \\circ F)(r)\\]\nWe are done.\n\n\nGiven any category \\(\\mathsf{C}\\), there is a functor \\(1_{\\mathsf{C}} \\colon \\mathsf{C} \\to \\mathsf{C}\\) defined in the following way.\n\nFor \\(x \\in \\mathsf{C}_0\\), \\(1_{\\mathsf{C}}(x) = x\\)\nFor \\(x,y \\in \\mathsf{C}_0\\), \\(f \\colon x \\to y\\), \\(1_{\\mathsf{C}}(f) = f\\)\n\nWe leave it to the reader to show that this preserves identities and compositions. This is really easy if you can just state what you have to prove, but it might be tricky to state what you have to prove! So that would be a good exercise.\n\nIn Julia, we represent this all with the following data structures.\nstruct ComposedFunctor{C<:Category,D<:Category,E<:Category} <: Functor{C,E}\n  F::Functor{C,D}\n  G::Functor{D,E}\nend\n\nob_map(FG::ComposedFunctor, x) = ob_map(FG.G, ob_map(FG.F, x))\nhom_map(FG::ComposedFunctor, f) = hom_map(FG.G, hom_map(FG.F, f))\n\nCategories.dom(c::KittenC, FG::ComposedFunctor) = dom(c, FG.F)\nCategories.codom(c::KittenC, FG::ComposedFunctor) = codom(c, FG.G)\n\nfunction Categories.compose(\n  c::KittenC,\n  F::Functor{C,D}, G::Functor{D,E}\n) where {C,D,E}\n  @assert codom(c, F) == dom(c, G)\n  ComposedFunctor{C,D,E}(F,G)\nend\n\nstruct IdFunctor{C<:Category}\n  c::C\nend\n\nob_map(I::IdFunctor, x) = x\nhom_map(I::IdFunctor, f) = f\n\nCategories.dom(::KittenC, F::IdFunctor) = F.c\nCategories.codom(::KittenC, F::IdFunctor) = F.c\n\nCategories.id(::KittenC, c::Category) = IdFunctor(c)"
  },
  {
    "objectID": "lecture4.html#examples-of-functors",
    "href": "lecture4.html#examples-of-functors",
    "title": "Lecture 4: Functors",
    "section": "Examples of Functors",
    "text": "Examples of Functors\nThis is the livecoding section! We are going to implement a functor between two categories. Unfortunately, this functor won‚Äôt be terribly interesting, because we haven‚Äôt met too many categories yet! But soon we will meet more categories, and we will be able to talk about many more functors.\nRecall from last lecture the category of matrices, \\(\\mathsf{Mat}\\), where the objects are natural numbers and a morphism from \\(n\\) to \\(m\\) is a \\(n \\times m\\) matrix. Composition is matrix multiplication!\nThere is a category \\(\\mathsf{Fin}\\) where the objects are natural numbers and a morphism from \\(n\\) to \\(m\\) is a function from \\(\\{1,\\ldots,n\\}\\) to \\(\\{1,\\ldots,m\\}\\).\nWe make a functor \\(F\\) from \\(\\mathsf{Fin}\\) to \\(\\mathsf{Mat}\\) that is the identity on objects, and sends a function \\(f \\colon \\{1,\\ldots,n\\} \\to \\{1,\\ldots,m\\}\\) to the \\(n \\times m\\) matrix that has a 1 at index \\((i, f(i))\\) for each \\(i \\in \\{1,\\ldots,n\\}\\), and 0s elsewhere.\nWe must show that \\(F\\) preserves composition and identites.\nWe start with identities. The identity function \\(1_n \\colon \\{1,\\ldots,n\\} \\to \\{1,\\ldots,n\\}\\) turns into the matrix with a \\(1\\) at index \\((i,i)\\) for every \\(i\\), and 0 elsewhere, which is the identity matrix.\nNow, fix \\(n,m,\\ell\\), let \\(f \\colon \\{1,\\ldots,n\\} \\to \\{1,\\ldots,m\\}\\) and \\(g \\colon \\{1,\\ldots,m\\} \\to \\{1,\\ldots,\\ell\\}\\), and let \\(A = F(f)\\) and \\(B = F(g)\\). Then fix \\(i,k\\) and consider the expression for matrix multiplication.\n\\[ (AB)_{ik} = \\sum_{j=1}^{m} A_{ij} B_{jk} \\]\nNote that \\(A_{ij} = 1\\) only when \\(f(i) = j\\), and \\(B_{jk} = 1\\) only when \\(g(j) = k\\). So the only way that both of them are non-zero for the same \\(j\\) is when \\(j = f(i)\\) and \\(k = g(j)\\), or in other words \\(k = (g \\circ f)(i)\\). We are done."
  }
]