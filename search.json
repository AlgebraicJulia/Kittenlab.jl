[
  {
    "objectID": "index.html",
    "href": "index.html",
    "title": "Kittenlab lecture notes",
    "section": "",
    "text": "Introduction\nThis is a Quarto book.\nTo learn more about Quarto books visit https://quarto.org/docs/books."
  },
  {
    "objectID": "lecture1.html",
    "href": "lecture1.html",
    "title": "Lecture 1: Formal Math",
    "section": "",
    "text": "Introduction\nThese lectures are meant to go from 0 to category theory as efficiently as possible. This means that we are going to optimize for being precise, for being clear, and for opening up new possibilities for you. We are not going to optimize for being entertaining or engaging; this is not a ‚Äúmonads as burritos‚Äù blog post or a popsci article about category theory. The answer to ‚Äúwhy do we care about this‚Äù is often going to be ‚Äúbecause it‚Äôs important later on‚Äù, and you are just going to have to trust me on that.\nAs we are going from 0, in this first lecture I plan to get you all aquainted with what it even means to ‚Äúdo math‚Äù at the level that category theory lives. This is a different kind of math than what you might have learned about in lower level math courses, and so sorting out from the beginning the mindset that you should have for the rest of the lectures is the most efficient use of this time. Generally, nobody tells you about this distinction and you have to work it out painfully over years of getting bad grades on university math homeworks; we don‚Äôt have time for that.\nHowever, we will have code examples for you to play with, because most of you are programmers and thus making a connection between math and code should speed the learning process.\nFinally, everyone at some point in this lecture will be frustrated by how pedantic I‚Äôm being. Sorry. I‚Äôm erring on the side of pedantry because there‚Äôs a ‚Äúprice is right‚Äù situation here: if I go too slow, we waste a bit of time, but if I go too fast we waste all of the time.\nPure math consists of a series of definitions, propositions, and examples. In this document, we typeset these like\nA definition introduces a new word, and I will always put that new word in bold. In normal speech, words have meanings given by context, by association, and only sometimes by explicit definition. In math, it is not like that. Every technical word has a single definition. That definition may not be written down explicitly; it may be agreed implicitly between mathematicians based on shared experience. However, in theory there is always a precise definition for every mathematical concept. It is expected that all participants in a mathematical conversation could be locked up in a cell, given paper, a pencil and a great deal of time, and then write down a fully rigorous formulation of each of the words they are using. Moreover, each of these formulations for each of the mathematicians might not be exactly the same, but they should be able to be proven equivalent.\nUntil you learn mathematical logic, which we will not cover here, this expectation cannot be realized because you don‚Äôt know a precise definition of ‚Äúfully rigorous‚Äù. The level of rigor that will suffice for now is that you should be able to expand every definition to a level where it can be explained to a smart, patient human who knows no category theory, by going backwards and defining each of the terms used in that definition until you get to very basic concepts, like sets, functions, and equations.\nThe extremely important corollary to all of this is that if you feel like your understanding of a definition does not reach this level, YOU ARE CONFUSED. This is OK. It is good to be confused. It is far better to be confused and not yet wrong than it is to be unconfused and wrong.\nWhat should you do when you are confused? First of all, GO BACKWARDS. Read the previous section of a textbook. If you are still confused, keep going backwards until you hit something that makes sense, and then work your way back up. Secondly, GO SIDEWAYS. Read another textbook that treats the same material in a different way. Then finally, if neither of those work, ASK AN EXPERT, and keep asking until you feel unconfused. The MOST IMPORTANT SKILL in math is to know when you are confused and don‚Äôt continue until you are unconfused! If you continue on, you will get hopelessly confused; if you turn back immediately there is still hope.\nDefinitions are the most important part of higher math. Understanding the definitions is often half the battle, and it is most of the battle for category theory.\nA proposition is an assertion that one logical statement (the conclusion) follows from several logical statements (the premises). Each proposition comes along with a proof. Just like definitions, it is expected that the participants in a mathematical conversation could expand a proof out to a fully rigorous level, even if the given proof is very vague. What you write down as a proof should be seen as a ‚Äúhint‚Äù for the construction of the actual, fully rigorous proof; mathematicians come to cultural agreements for how much of a hint is needed in different circumstances.\nAs a mathematical learner, proofs are your window into the thought processes of subject experts. Thus, they are very good to study and understand. However, they are not as critical to understand as definitions. It is absolutely essential to fully understand definitions, but proofs can be ‚Äúblackboxed‚Äù sometimes, and you can just remember the proposition without understanding fully the proof.\nPropositions are also known as theorems, lemmas, and corollaries. A theorem is an important proposition, a lemma is a small proposition mainly used to prove other propositions, and a corollary is a proposition whose proof is easy because of another proposition, for example a special case. Really, these are just vibes that mathematicians add to propositions.\nFinally, an example is a definition or proposition that falls under one of three categories.\nA pure math document consists of a sequence of definitions, propositions, and examples, punctuated with interleaving prose that attempts to give intuition for what the definitions, propositions, and examples are saying, and why one should care about those definitions, propositions, and examples. Intuition is a very important part of math; it is what allows mathematicians to elaborate definitions, discover proofs, and most importantly, to figure out what is important to study in the first place. However, intuition is no substitute for rigor. Intuition allows you to leap off cliffs; rigor is what allows you to build a bridge underneath you before you hit the ground.\nIn the foundations of math, we also have two more types of statement: axioms and undefined terms. Definitions and propositions should always ‚Äúbottom out‚Äù at axioms and undefined terms. However, most mathematicians do not do this, instead leaving it to the reader to choose a suitable foundations of math in which to fully formalize their theories. Surprisingly, most interesting math can be fully formalized in many foundations, so this normally works out fine.\nFor us, our ‚Äúreality‚Äù will be what happens on the computer. So we will try to ‚Äúbottom out‚Äù on concepts in the computer.\nWe will now demonstrate the previous concepts by studying finite sets. We will not get to category theory today. Instead, we will revisit some things that should be familiar to you and treat them in the style that we will be using for the rest of the lectures.\nFinite sets will be important for most of the applications of category theory that we will learn in the next lectures, and also most of the concepts of category theory are well-illustrated by finite sets. So a firm grasp of finite sets will be an immense aid in the coming weeks.\nWe start with a basic universe of discourse. It is traditional to be minimalistic with this universe of discourse, and say that everything is a set, or everything is a natural number. However, we choose to be untraditional.\nWe might represent this in Julia with the following data structure.\nNote that this is not the only possible representation of a finite set. Definitions in math always can be translated into code in many ways; the choice of a particular way is a delicate balancing act between simplicity, performance, clarity, and completeness.\nAnother possible representation of finite sets is\nThis represents the finite set \\(\\{1,\\ldots,n\\}\\). Here we have traded performance over completeness; we can only represent some finite sets, but we represent those finite sets more efficiently.\nIt is important to note that even if \\(a\\) is listed multiple times in \\(A\\), \\(f(a)\\) only has one value.\nWe might represent a function between ùîΩs, also known as a morphism of finite sets, with the following data structure.\nHowever, not all instances of this data structure represent functions. The following Julia function determines whether a morphism of finite sets is valid.\nFrequently we will write down Julia types representing mathematical concepts where not all values of that type are valid representations of that mathematical concept. This is unavoidable because Julia types do not have the specificity to narrow down the space of values enough. There are languages where the types can narrow down the space of values sufficiently, but none of those languages have well-maintained BLAS/LAPACK bindings.\nFor finite sets implemented by IntùîΩ, we can give a more efficient encoding of morphism.\nwith corresponding validation function\nFrom now on, we will work with only VecùîΩs and ùîΩMors, and leave the implementation of more efficient code to the reader."
  },
  {
    "objectID": "lecture1.html#takeaways",
    "href": "lecture1.html#takeaways",
    "title": "Lecture 1: Formal Math",
    "section": "Takeaways",
    "text": "Takeaways\n\nPure math consists of definitions, propositions, and examples.\nThese are specified in enough detail so that participants in a mathematical conversation could independently come up with equivalent elaborations.\nIf you feel you could not do this at any point, then you are in a perfectly normal situation and should not feel ashamed whatsoever. However, continuing on without first going back and understanding what you are confused about is a bad idea."
  },
  {
    "objectID": "lecture1.html#takeaways-1",
    "href": "lecture1.html#takeaways-1",
    "title": "Lecture 1: Formal Math",
    "section": "Takeaways",
    "text": "Takeaways\n\nA finite set is a list of things\nA morphism of finite sets from \\(A\\) to \\(B\\) sends each unique element of \\(A\\) to an element of \\(B\\)\nThere are multiple ways of implementing representations of finite sets and morphisms between them on the computer"
  },
  {
    "objectID": "lecture2.html",
    "href": "lecture2.html",
    "title": "Lecture 2: The Category Theory of Finite Sets",
    "section": "",
    "text": "Composition and Isomorphisms\nWe now introduce the operation at the core of all category theory: composition!\nWe now come to an issue that is everywhere in category theory: equality. If you have seen any set theory before, you might think that \\(\\{1,2,3,3\\}\\) and \\(\\{3,2,1\\}\\) are ‚Äúthe same‚Äù set. Note however that when I defined finite set, I just said that a finite set was a list of things surrounded by curly braces.\nSo it seems like something is wrong with our definition.\nBut let‚Äôs think about why we typically choose to make \\(\\{1,2,3,3\\}\\) and \\(\\{3,2,1\\}\\) ‚Äúthe same‚Äù set. One good reason is that any morphism out of \\(\\{1,2,3,3\\}\\) can be seen as a morphism out of \\(\\{3,2,1\\}\\), and the same goes for incoming morphisms.\nTherefore, from a ‚Äúmorphism‚Äôs-eye‚Äù perspective, \\(\\{1,2,3,3\\}\\) and \\(\\{3,2,1\\}\\) behave the exact same way; defining a morphism out of one is the same as defining a morphism out of the other.\nBut if we take this to its logical conclusion, we find that this is true not only of \\(\\{1,2,3,3\\}\\) and of \\(\\{3,2,1\\}\\), but also of \\(\\{1,2,3\\}\\) and \\(\\{\\mathbf{a},\\mathbf{b},\\mathbf{c}\\}\\)!\nTo see this, let \\(B = \\{1,2,3\\}\\), \\(B^\\prime = \\{\\mathbf{a}, \\mathbf{b}, \\mathbf{c}\\}\\), and define \\(f \\colon B \\to B^\\prime\\) and \\(g \\colon B^\\prime \\to B\\) by\n\\[ f(x) = \\begin{cases}\n  \\mathbf{a} & \\text{if $x = 1$} \\\\\n  \\mathbf{b} & \\text{if $x = 2$} \\\\\n  \\mathbf{c} & \\text{if $x = 3$}\n\\end{cases} \\]\n\\[ g(y) = \\begin{cases}\n  1 & \\text{if $y = \\mathbf{a}$} \\\\\n  2 & \\text{if $y = \\mathbf{b}$} \\\\\n  3 & \\text{if $y = \\mathbf{c}$}\n\\end{cases} \\]\nThen given \\(h \\colon B \\to C\\), we can produce \\(h^\\prime \\colon B^\\prime \\to C\\) via \\(h^\\prime = h \\circ g\\), and vice versa. Moreover, when we start out with a function out of \\(B\\), compose it with \\(g\\) to make a function out of \\(B^\\prime\\) and then compose it with \\(f\\) to make a function out of \\(B\\), we get the same function back.\nAll of this motivates the next few definitions.\nYou can remember the reasoning for why the name ‚Äúisomorphic‚Äù by thinking ‚Äúisomorphic = same morphisms‚Äù. That is, if we have an isomorphism between \\(A\\) and \\(A^\\prime\\), then there are ‚Äúthe same morphisms‚Äù out of \\(A\\) and out of \\(A\\prime\\).\nHowever, as noted before, there might be several distinct isomorphisms between \\(A\\) and \\(A^\\prime\\). Thus, one must be careful to specify which isomorphism when you are talking about isomorphic finite sets.\nAnyways, this is why it‚Äôs not a terrible problem to use a vector to represent a finite set. There are only rare cases where you can find a representation of your mathematical objects such that two representations are equal if and only if the mathematical objects are isomorphic. If you are lucky enough to find this, it‚Äôs called a ‚Äúcanonical form‚Äù and it‚Äôs a big deal. As a practical matter, we might use Set instead of Vector because it gets a bit closer to a canonical form, but I wanted to start with Vector to make the point that the representation of your mathematical object on a computer in general will not be canonical.\nWe now discuss some more properties of finite sets and their maps.\nThis is a good opportunity to discuss something very critical in math: ordering of quantifiers. Quantifiers are phrases like ‚Äúfor every ‚Ä¶‚Äù or ‚Äúthere exists ‚Ä¶‚Äù. In the previous definition, if we had instead said ‚Äúthere exists an \\(a \\in A\\) such that for every \\(b \\in B\\), \\(f(a) = b\\)‚Äù, this could only be true if \\(B\\) had only a single element! The fact that the ‚Äúthere exists‚Äù comes after the ‚Äúfor every‚Äù allows us to choose a different \\(a\\) for each \\(b\\).\nWe wrap up this section with a way of telling when there exists any isomorphisms between two finite sets.\nThe point of this first lecture is to introduce you to finite sets and pure math, not category theory. Therefore, we end with a discussion of a theorem from combinatorics."
  },
  {
    "objectID": "lecture2.html#takeaways",
    "href": "lecture2.html#takeaways",
    "title": "Lecture 2: The Category Theory of Finite Sets",
    "section": "Takeaways",
    "text": "Takeaways\n\nYou can compose morphisms between finite sets\nIsomorphisms tell you which finite sets are equivalent from the point of view of morphisms"
  },
  {
    "objectID": "lecture2.html#takeaways-1",
    "href": "lecture2.html#takeaways-1",
    "title": "Lecture 2: The Category Theory of Finite Sets",
    "section": "Takeaways",
    "text": "Takeaways\n\nThere are two special classes of functions: injections and surjections\nIf something is an injection and a surjection, it is an isomorphism\nYou can tell which finite sets are isomorphic by looking at their cardinalities"
  },
  {
    "objectID": "lecture2.html#takeaways-2",
    "href": "lecture2.html#takeaways-2",
    "title": "Lecture 2: The Category Theory of Finite Sets",
    "section": "Takeaways",
    "text": "Takeaways\n\nYou can do basic combinatorics in the framework we have developed in this lecture"
  },
  {
    "objectID": "lecture3.html",
    "href": "lecture3.html",
    "title": "Lecture 3: Category Theory",
    "section": "",
    "text": "Julia from last lecture\n\n\nabstract type ùîΩ end\n\nstruct VecùîΩ <: ùîΩ\n  elems::Vector{Any}\nend\n\nBase.:(‚àà)(a, A::VecùîΩ) = a ‚àà A.elems\n\nBase.iterate(A::VecùîΩ) = iterate(A.elems)\nBase.iterate(A::VecùîΩ, k) = iterate(A.elems, k)\nBase.length(A::VecùîΩ) = length(A.elems)\n\nstruct IntùîΩ <: ùîΩ\n  n::Int\nend\n\nBase.:(‚àà)(a, A::IntùîΩ) = 1 <= a <= A.n\n\nBase.iterate(A::IntùîΩ) = iterate(1:A.n)\nBase.iterate(A::IntùîΩ, k) = iterate(1:A.n, k)\n\nstruct ùîΩMor\n  dom::ùîΩ\n  codom::ùîΩ\n  vals::Dict{Any,Any}\nend\n\n(f::ùîΩMor)(x) = f.vals[x]\n\nstruct IntùîΩMor\n  dom::IntùîΩ\n  codom::IntùîΩ\n  vals::Vector{Int}\nend\n\n(f::IntùîΩMor)(i) = f.vals[i]\n\n\n\nSets\nToday we will be moving on from finite sets to talk about sets which are possibly infinite. Infinite sets are a controversial topic; they don‚Äôt exist as tangibly as finite sets, and generally are much trickier to compute with. For a mathematician, this is not a problem; they write down formulas for infinite sets in precisely the same way they wrote down formulas for finite sets.\nThe crucial difference between finite sets and infinite sets is that any ‚Äúfor all‚Äù statement on an infinite set is not checkable by listing out every element of the set and checking that a property holds of each of them. Relatedly, any ‚Äúexists‚Äù statement is likewise not checkable. This seems kind of obvious, but it means that naive extensions of algorithms from the case of finite sets to the case of infinite sets often fails.\nThus, on a computer infinite sets have a very different feel than finite sets.\nIn traditional foundations, everything is built out of sets. But, as we said in the previous lecture, this is unnecessarily strict. We are instead taking Julia to be our foundation, so that we will have primitive things that are not themselves sets. This is a much saner foundation, because while it might be technically possible to build, say, a real number out of sets, nobody really wants to do that.\n\nA set \\(X\\) consists of a function from Any to Bool, which may or either be written in Julia or defined mathematically. If \\(X(x) = \\mathbf{true}\\), we write \\(x \\in X\\), and if \\(X(x) = \\mathbf{false}\\) we write \\(x \\notin X\\).\n\nNote that when we write down Julia definitions involving sets, we are implicitly assuming that the functions are written in Julia. However, there are some sets that we will use whose functions cannot be written down in Julia, so take the Julia definitions with a grain of salt. If the function defining a set can be written in Julia, we say that set is computable, and otherwise the set is uncomputable.\nObviously, we can only model the computable sets in Julia, but the uncomputable sets are still useful for talking about Julia.\n\nabstract type ComputableSet end\n\n# We expect any subtype of ComputableSet to have in defined on it.\nBase.in(x, s::ComputableSet) = error(\"no specific definition found\")\n\n\nFor any finite set \\(A\\), let \\(\\chi_{A}\\) be defined by \\(\\chi_{A}(x) = \\mathbf{true}\\) if \\(x\\) is listed in \\(A\\) and \\(\\mathbf{false}\\) otherwise. Then \\(\\chi_{A}\\) is a set.\n\n\nAny Julia type T defines a set, via the function which checks whether a Julia value has that type.\n\n\nstruct FiniteSet <: ComputableSet\n  A::ùîΩ\nend\n\nBase.in(x, œá::FiniteSet) = x ‚àà œá.A\n\nstruct TypeSet <: ComputableSet\n  T::Type\nend\n\nBase.in(x, œá::TypeSet) = x isa œá.T\n\n\nGiven two sets \\(A\\) and \\(B\\), the set \\(A \\to B\\) consists of all Julia callables \\(f\\) such that \\(f(a) \\in B\\) for all \\(a \\in A\\). Note that\n\nNote that even if A and B are computable sets, there is no way to check in Julia that a given f is an element of \\(A \\to B\\) because this would involve iterating through possibly infinitely many elements of \\(A\\). Again, languages where this is not the case don‚Äôt have good ODE solvers.\n\nGiven two sets \\(X\\) and \\(Y\\), their intersection \\(X \\cap Y\\) is defined by\n\\[ (X \\cap Y)(x) = X(x) \\wedge Y(x) \\]\nTheir union \\(X \\cup Y\\) is defined by\n\\[ (X \\cup Y)(x) = X(x) \\vee Y(x) \\]\n\n\nstruct IntersectionSet\n  X::ComputableSet\n  Y::ComputableSet\nend\n\nBase.in(x, œá::IntersectionSet) = x ‚àà œá.X && x ‚àà œá.Y\n\nstruct UnionSet\n  X::ComputableSet\n  Y::ComputableSet\nend\n\nBase.in(x, œá::UnionSet) = x ‚àà œá.X || x ‚àà œá.Y\n\n\nGiven two sets \\(X\\) and \\(Y\\), their product \\(X \\times Y\\) is the set of tuples \\((x,y)\\) where \\(x \\in X\\) and \\(y \\in Y\\). That is, \\(z \\in X \\times Y\\) if and only if z isa Tuple, length(z) = 2, \\(z[1] \\in X\\) and \\(z[2] \\in Y\\).\n\n\nproduct(X,Y) = z -> (z isa Tuple) &&\n  length(z) == 2 && X(z[1]) && Y(z[2])\n\n\nWe leave it to the reader to give a mathematical definition for sum given the following definition in Julia\n\n\nstruct Left\n  val::Any\nend\n\nstruct Right\n  val::Any\nend\n\nsum(X,Y) = x ->\n  if x isa Left\n    X(x.val)\n  elseif x isa Right\n    Y(x.val)\n  else\n    false\n  end\n\nWe will now move on to categories. But I would like to make one brief point first, which is that there is no set of all sets. This is because not all sets correspond to Julia values, as we consider uncomputable sets to be sets. But there is a set of all computable sets.\n\n\nCategories\nThe moment we‚Äôve all be waiting for.\n\nA small category \\(C\\) consists of\n\na set \\(C_0\\) of objects\nfor every \\(x,y \\in C_0\\), a set \\(\\mathrm{Hom}_C(x,y)\\) of morphisms from \\(x\\) to \\(y\\)\nfor every \\(x,y,z \\in C_0\\), a composition function \\(\\circ \\colon \\mathrm{Hom}_C(y,z) \\times \\mathrm{Hom}_(x,y) \\to \\mathrm{Hom}(x,z)\\)\nfor every \\(x \\in C_0\\), an identity morphism \\(1_x \\in \\mathrm{Hom}_C(x,x)\\)\n\nsuch that\n\nfor all \\(x,y,z,w \\in C_0\\), \\(f \\in \\mathrm{Hom}_C(x,y)\\), \\(g \\in \\mathrm{Hom}_C(y,z)\\), \\(h \\in \\mathrm{Hom}_C(z,w)\\), \\[ h \\circ (g \\circ f) = (h \\circ g) \\circ f \\]\nfor all \\(x,y \\in C_0\\), \\(f \\in \\mathrm{Hom}_C(x,y)\\), \\[ 1_y \\circ f = f = f \\circ 1_x \\]\n\nThese two laws are called the associativity law and unitality law respectively.\n\n(Julia to be livecoded)\n\nThere is a category \\(\\mathsf{Fin}\\) where the objects are finite sets and the morphisms are morphisms of finite sets, as defined in the previous lecture.\n\n(Julia to be livecoded)\n\nThere is a category where the objects are natural numbers and a morphism from \\(n\\) to \\(m\\) is a \\(n \\times m\\) matrix. Composition of a \\(n \\times m\\) matrix and an \\(m \\times r\\) matrix is done by matrix multiplication.\n\n(Julia to be livecoded)\n\nA graph consists of a finite set of vertices, a finite set of edges, and a source and target map from vertices to edges. Given any graph, there is a ‚Äúfree category‚Äù on that graph, where the objects are vertices and the morphisms are paths.\n\n(Julia to be livecoded)"
  },
  {
    "objectID": "lecture4.html#review-in-kittenlab-syntax",
    "href": "lecture4.html#review-in-kittenlab-syntax",
    "title": "Lecture 4: Functors",
    "section": "Review in Kittenlab syntax",
    "text": "Review in Kittenlab syntax\nIn this lecture, we are finally going to start using the Kittenlab.jl library. We weren‚Äôt using Kittenlab up until now so that I could show you a variety of design tradeoffs, and so that you were learning concepts rather than a specific instantiation of those concepts, but now it becomes worth it to start building up a coherent library instead of starting from scratch every time.\nWe start by giving the Julia definition of category that we will be using now.\n\ninclude(\"../src/Categories.jl\")\nusing .Categories\n\nThis declares an abstract type for category\nabstract type Category{Ob, Hom} end\nalong with the following methods that should be implemented on any subtype of that abstract type.\n# Note: this is not executed; this is just to show expected type signatures\ndom(c::Category{Ob, Hom}, f::Hom)::Ob\ncodom(c::Category{Ob, Hom}, f::Hom)::Ob\ncompose(c::Category{Ob, Hom}, f::Hom, g::Hom)::Hom\nid(c::Category{Ob, Hom}, x::Ob)::Hom\nIn Kittenlab, we have chosen a ‚Äúmiddle path‚Äù between having everything be fully dynamic and trying to put as much as possible into the type system. We use the Julia type system to guide our implementations, to provide documentation, and to resolve dispatch, but we do not rely on it for correctness.\nIf C is a subtype of Category{Ob,Hom}, then we expect that the set of objects for any element of C to be a subset of Ob.\nMoreover, we expect the hom-set from x :: Ob to y :: Ob to be some subset of the elements f :: Hom with dom(c, f) == x and codom(c, f) == y.\nThis ‚Äúmiddle path‚Äù is fairly convenient, because often there is a good choice of the types Ob and Hom that makes the category fairly ergonomic to use, in that most or all of the elements of Ob are actually objects of the category, and the same for Hom. Additionally, having more specific types will allow Julia to produce more efficient code.\nWe use slightly different definitions for the category of finite sets, following these principles.\n\ninclude(\"../src/FinSets.jl\")\nusing .FinSets\n\nNamely, we declare\nconst FinSet = AbstractSet\n\nstruct FinFunction{S,T}\n  dom::FinSet{S}\n  codom::FinSet{T}\n  values::AbstractDict{S,T}\nend\nWe simplified our design hierarchy in one way (removing the abstract types), and complicated it in another way (adding type parameters); this is a more pragmatic and less flexible approach.\nWe now declare a category of finsets and finfunctions to go along with this:\nstruct FinSetC <: Category{FinSet, FinFunction}\nend\n\nCategories.dom(::FinSetC, f::FinFunction) = f.dom\n\nCategories.codom(::FinSetC, f::FinFunction) = f.codom\n\nfunction Categories.compose(\n  ::FinSetC,\n  f::FinFunction{S,T}, g::FinFunction{T,R}\n) where {S,T,R}\n  @assert f.codom == g.dom\n  FinFunction(f.dom, g.codom, Dict(x => g(f(x)) for x in f.dom))\nend\n\nfunction Categories.id(::FinSetC, X::FinSet{S}) where {S}\n  FinFunction{S,S}(X,X,Dict(x => x for x in X))\nend\nHopefully, at this point the new conventions that we are using should make sense, so we are going to move on to functors!"
  },
  {
    "objectID": "lecture4.html#functors",
    "href": "lecture4.html#functors",
    "title": "Lecture 4: Functors",
    "section": "Functors",
    "text": "Functors\nCategory theory is all about studying the objects of a category by studying the morphisms between them. So consequently, the study of functors (which are the morphisms between categories) is critical to the studying of categories!\n\nLet \\(\\mathsf{C}\\) and \\(\\mathsf{D}\\) be categories. A functor \\(F\\) from \\(\\mathsf{C}\\) to \\(\\mathsf{D}\\), often written \\(F \\colon \\mathsf{C} \\to \\mathsf{D}\\), consists of:\n\nA function \\(F_0 \\colon \\mathsf{C}_0 \\to \\mathsf{D}_0\\). If \\(x \\in \\mathsf{C}_0\\), we often write \\(F_0(x)\\) as \\(F(x)\\).\nFor every \\(x,y \\in \\mathsf{C}_0\\), a function \\(F_{x,y} \\colon \\mathrm{Hom}_{\\mathsf{C}}(x,y) \\to \\mathrm{Hom}_{\\mathsf{D}}(F(x),F(y))\\). If \\(f \\in \\mathrm{Hom}_{\\mathsf{C}}(x,y)\\), we often write \\(F_{x,y}(f)\\) as \\(F(f)\\).\n\nsuch that the following two laws hold:\n\nFor all \\(x \\in \\mathsf{C}_0\\), \\(1_{F(x)} = F(1_x)\\)\nFor all \\(x,y,z \\in \\mathsf{C}_0\\), \\(f \\colon x \\to y\\), \\(g \\colon y \\to z\\), \\(F(g \\circ f) = F(g) \\circ F(f)\\).\n\n\nWe implement this with the following Julia.\n\ninclude(\"../src/Functors.jl\")\nusing .Functors\n\nThe declaration of functor is the following.\nabstract type Functor{C<:Category, D<:Category} end\n\nfunction ob_map(F::Functor{C,D}, x::ObC)::ObD where\n    {ObC, ObD, C<:Category{ObC}, D<:Category{ObD}}\n  error(\"unimplemented\")\nend\n\nfunction hom_map(F::Functor{C,D}, f::HomC)::HomD where\n    {ObC, HomC, ObD, HomD, C<:Category{ObC, HomC}, D<:Category{ObD, HomD}}\n  error(\"unimplemented\")\nend\n \n# KittenC is the category of Julia-implemented categories and functors\n\nstruct KittenC <: Category{Category, Functor}\nend\n\nfunction Categories.dom(::KittenC, F::Functor{C,D})::C where {C,D}\n  error(\"unimplemented\")\nend\n\nfunction Categories.codom(::KittenC, F::Functor{C,D})::D where {C,D}\n  error(\"unimplemented\")\nend\nThere are some critical subtleties in this declaration.\nFirst of all, functor is an abstract type parameterized by the types of its domain and codomain categories. Crucially, it is not parameterized by the domain and codomain categories! In the case that these types are singletons, this is an academic distinction. But later on, we will have structs that are subtypes of Category that are not singletons, where there is dynamic data in the category, and then dom and codom will be meaningful. The reason we have the types of the categories in the abstract type for functor is that we can then extract the types of the objects and morphisms for each category.\nSecondly, we have declared a category KittenC of categories and functors. Technically speaking, this is the category of ‚Äúcategories and functors that are implemented in Julia‚Äù; we reserve the category \\(\\mathsf{Cat}\\) for the category of all (small) categories. But this category is not complete yet: we need to be able to compose functors and take identity functors!\nWe first handle this mathematically.\n\nGiven three categories \\(\\mathsf{C}\\), \\(\\mathsf{D}\\) and \\(\\mathsf{E}\\), along with two functors \\(F \\colon \\mathsf{C} \\to \\mathsf{D}\\) and \\(G \\colon \\mathsf{D} \\to \\mathsf{E}\\), there is a functor \\(G \\circ F \\colon \\mathsf{C} \\to \\mathsf{E}\\) defined in the following way.\n\nFor \\(x \\in \\mathsf{C}_0\\), \\((G \\circ F)(x) = G(F(x))\\)\nFor \\(x,y \\in \\mathsf{C}_0\\), \\(f \\colon x \\to y\\), \\((G \\circ F)(f) = G(F(f))\\)\n\nWe now show that \\(G \\circ F\\) preserves composition and identities. Suppose that \\(x \\in \\mathsf{C}_0\\). Then\n\\[(G \\circ F)(1_x) = G(F(1_x)) = G(1_{F(x)}) = 1_{G(F(x))} = 1_{(G \\circ F)(x)}\\]\nMoreover, if \\(x,y,z \\in \\mathsf{C}_0\\), and \\(r \\colon x \\to y\\) and \\(s \\colon y \\to z\\), then\n\\[(G \\circ F)(s \\circ r) = G(F(s \\circ r)) = G(F(s) \\circ F(r)) = G(F(s)) \\circ G(F(r)) = (G \\circ F)(s) \\circ (G \\circ F)(r)\\]\nWe are done.\n\n\nGiven any category \\(\\mathsf{C}\\), there is a functor \\(1_{\\mathsf{C}} \\colon \\mathsf{C} \\to \\mathsf{C}\\) defined in the following way.\n\nFor \\(x \\in \\mathsf{C}_0\\), \\(1_{\\mathsf{C}}(x) = x\\)\nFor \\(x,y \\in \\mathsf{C}_0\\), \\(f \\colon x \\to y\\), \\(1_{\\mathsf{C}}(f) = f\\)\n\nWe leave it to the reader to show that this preserves identities and compositions. This is really easy if you can just state what you have to prove, but it might be tricky to state what you have to prove! So that would be a good exercise.\n\nIn Julia, we represent this all with the following data structures.\nstruct ComposedFunctor{C<:Category,D<:Category,E<:Category} <: Functor{C,E}\n  F::Functor{C,D}\n  G::Functor{D,E}\nend\n\nob_map(FG::ComposedFunctor, x) = ob_map(FG.G, ob_map(FG.F, x))\nhom_map(FG::ComposedFunctor, f) = hom_map(FG.G, hom_map(FG.F, f))\n\nCategories.dom(c::KittenC, FG::ComposedFunctor) = dom(c, FG.F)\nCategories.codom(c::KittenC, FG::ComposedFunctor) = codom(c, FG.G)\n\nfunction Categories.compose(\n  c::KittenC,\n  F::Functor{C,D}, G::Functor{D,E}\n) where {C,D,E}\n  @assert codom(c, F) == dom(c, G)\n  ComposedFunctor{C,D,E}(F,G)\nend\n\nstruct IdFunctor{C<:Category}\n  c::C\nend\n\nob_map(I::IdFunctor, x) = x\nhom_map(I::IdFunctor, f) = f\n\nCategories.dom(::KittenC, F::IdFunctor) = F.c\nCategories.codom(::KittenC, F::IdFunctor) = F.c\n\nCategories.id(::KittenC, c::Category) = IdFunctor(c)"
  },
  {
    "objectID": "lecture4.html#examples-of-functors",
    "href": "lecture4.html#examples-of-functors",
    "title": "Lecture 4: Functors",
    "section": "Examples of Functors",
    "text": "Examples of Functors\nThis is the livecoding section! We are going to implement a functor between two categories. Unfortunately, this functor won‚Äôt be terribly interesting, because we haven‚Äôt met too many categories yet! But soon we will meet more categories, and we will be able to talk about many more functors.\nRecall from last lecture the category of matrices, \\(\\mathsf{Mat}\\), where the objects are natural numbers and a morphism from \\(n\\) to \\(m\\) is a \\(n \\times m\\) matrix. Composition is matrix multiplication!\nThere is a category \\(\\mathsf{Fin}\\) where the objects are natural numbers and a morphism from \\(n\\) to \\(m\\) is a function from \\(\\{1,\\ldots,n\\}\\) to \\(\\{1,\\ldots,m\\}\\).\nWe make a functor \\(F\\) from \\(\\mathsf{Fin}\\) to \\(\\mathsf{Mat}\\) that is the identity on objects, and sends a function \\(f \\colon \\{1,\\ldots,n\\} \\to \\{1,\\ldots,m\\}\\) to the \\(n \\times m\\) matrix that has a 1 at index \\((i, f(i))\\) for each \\(i \\in \\{1,\\ldots,n\\}\\), and 0s elsewhere.\nWe must show that \\(F\\) preserves composition and identites.\nWe start with identities. The identity function \\(1_n \\colon \\{1,\\ldots,n\\} \\to \\{1,\\ldots,n\\}\\) turns into the matrix with a \\(1\\) at index \\((i,i)\\) for every \\(i\\), and 0 elsewhere, which is the identity matrix.\nNow, fix \\(n,m,\\ell\\), let \\(f \\colon \\{1,\\ldots,n\\} \\to \\{1,\\ldots,m\\}\\) and \\(g \\colon \\{1,\\ldots,m\\} \\to \\{1,\\ldots,\\ell\\}\\), and let \\(A = F(f)\\) and \\(B = F(g)\\). Then fix \\(i,k\\) and consider the expression for matrix multiplication.\n\\[ (AB)_{ik} = \\sum_{j=1}^{m} A_{ij} B_{jk} \\]\nNote that \\(A_{ij} = 1\\) only when \\(f(i) = j\\), and \\(B_{jk} = 1\\) only when \\(g(j) = k\\). So the only way that both of them are non-zero for the same \\(j\\) is when \\(j = f(i)\\) and \\(k = g(j)\\), or in other words \\(k = (g \\circ f)(i)\\). We are done."
  },
  {
    "objectID": "lecture5.html#preorders",
    "href": "lecture5.html#preorders",
    "title": "Lecture 5: A Variety of Categories and Functors",
    "section": "Preorders",
    "text": "Preorders\n\nA preorder consists of\n\nA set \\(X\\)\nA function \\(\\leq \\colon X \\times X \\to \\{\\top, \\bot\\}\\) (which is how we write true and false in math)\n\nsuch that\n\nFor all \\(x \\in X\\), \\(x \\leq x\\)\nFor all \\(x,y,z \\in X\\), if \\(x \\leq y\\) and \\(y \\leq z\\), then \\(x \\leq z\\).\n\n\n\nabstract type Preorder{T} end\n\n# leq(p::Preorder{T}, x::T, y::T)::Bool\n\n\nLet \\(A\\) be a finite set. A subset of \\(A\\) is a finite set containing only elements of \\(A\\). Equivalently, a subset of \\(A\\) is a function \\(A \\to \\{\\top, \\bot\\}\\).\nThe set of subsets of \\(A\\) is a preorder, where \\(U \\leq V\\) if every element of \\(U\\) is an element of \\(V\\).\n\n\nfunction subsetof(U::FinSet{T}, A::FinSet{T}) where {T}\n  all(x ‚àà A for x in U)\nend\n\nstruct SubsetPreorder{T} <: Preorder{FinSet{T}}\n  A::FinSet{T}\nend\n\nfunction leq(p::SubsetPreorder{T}, U::FinSet{T}, V::FinSet{T}) where {T}\n  @assert subsetof(U,p.A)\n  @assert subsetof(V,p.A)\n  subsetof(U,V)\nend\n\n\nThe real numbers, \\(\\mathbb{R}\\), are a partially ordered set, using the standard ordering.\n\n\nstruct RealPreorder <: Preorder{Float64}\nend\n\nleq(::RealPreorder, x::Float64, y::Float64) = x <= y\n\n\nGiven any preorder \\((X,\\leq)\\), there is a category with objects \\(X\\) and\n\nPrecisely one morphism from \\(x\\) to \\(y\\) if \\(x \\leq y\\)\nNo morphisms from \\(x\\) to \\(y\\) if \\(x \\nleq y\\) (if \\(x\\) is not less than \\(y\\)).\n\n\nIn fact, we can take this as an alternative definition of preorder: a preorder is a category where there is either one or zero morphisms between any two objects. The idea is that a morphism from \\(x\\) to \\(y\\) ‚Äúwitnesses‚Äù the fact that \\(x \\leq y\\).\nWe express this with Julia.\n\nstruct PreorderMorphism{T,P<:Preorder{T}}\n  p::P\n  dom::T\n  codom::T\n  function PreorderMorphism(p::Preorder{T}, dom::T, codom::T) where {T}\n    # We can only create this morphism if dom ‚â§ codom\n    @assert leq(p, dom, codom)\n    new{T,typeof(p)}(p, dom, codom)\n  end\nend\n\nstruct PreorderAsCat{T,P<:Preorder{T}} <: Category{T,PreorderMorphism{T,P}}\n  p::P\nend\n\nCategories.dom(::PreorderAsCat{T,P}, f::PreorderMorphism{T,P}) where {T,P} = f.dom\nCategories.codom(::PreorderAsCat{T,P}, f::PreorderMorphism{T,P}) where {T,P} = f.codom\n\nCategories.id(c::PreorderAsCat{T,P}, x::T) where {T,P} = PreorderMorphism(c.p, x, x)\nCategories.compose(\n  c::PreorderAsCat{T,P},\n  f::PreorderMorphism{T,P},\n  g::PreorderMorphism{T,P}\n) where {T,P} = PreorderMorphism(c.p, f.dom, g.codom)\n\nLet us now determine what a functor between two preorders would be, if we understand those preorders as categories.\n\nA functor between preorders \\(X\\) and \\(Y\\) simply consists of a function \\(F \\colon X \\to Y\\) such that if \\(x \\leq x'\\) for \\(x,x' \\in X\\), then \\(F(x) \\leq F(x')\\).\n\n\nProof. If there is a morphism \\(f\\) from \\(x\\) to \\(y\\), then there must exist a morphism \\(F(f)\\) from \\(f(x)\\) to \\(f(y)\\). Moreover, \\(F\\) can send morphisms to only one place, so it must preserve composites and identities.\n\nWe call a functor between preorders an order-preserving map.\n\nThere is a category \\(\\mathsf{Preorder}\\) of where the objects are preorders and the morphisms are order-preserving maps.\n\nWe said that we can view preorders as categories. Let‚Äôs make this statement precise.\n\nIf \\(\\mathsf{C}\\) is a category, then a subcategory \\(\\mathsf{D}\\) of \\(\\mathsf{C}\\) consists of a subset \\(\\mathsf{D}_{0} \\subset \\mathsf{C}_{0}\\) of objects, and for each \\(x,y \\in \\mathsf{D}_{0}\\), a subset \\(\\mathrm{Hom}_{\\mathsf{D}}(x,y) \\subset \\mathrm{Hom}_{\\mathsf{C}}(x,y)\\) of morphisms, such that\n\nAll identities are in \\(\\mathsf{D}\\)\nThe composite of morphisms in \\(\\mathsf{D}\\) is again in \\(\\mathsf{D}\\)\n\nIf \\(\\mathsf{D}_{0} = \\mathsf{C}_{0}\\), we call \\(\\mathsf{D}\\) wide, and if \\(\\mathrm{Hom}_{D}(x,y) = \\mathrm{Hom}_{C}(x,y)\\) for all \\(x,y \\in \\mathsf{D}_{0}\\), we call \\(\\mathsf{D}\\) full. The only wide, full subcategory is \\(\\mathsf{C}\\) itself.\n\nWe now state the following proposition\n\n\\(\\mathsf{Preorder}\\) is a full subcategory of \\(\\mathsf{Cat}\\).\n\nNow is when something very subtle comes into play. We have two different definitions of preorder, which are in some sense equivalent, but the way we have stated definitions, one of these definitions would make the previous proposition true, and another of those definitions would make the previous proposition false. Specifically, if we say that a preorder is a category with the property that each hom-set is a singleton or empty, then the set of preorders is literally a subset of the set of (small) categories. However, if we say that a preorder is a set with a function to Bool, then this is not true! Concretely, it is not true that Preorder <: Category, it‚Äôs just that we can construct a category out of a preorder!\nIt is for this reason in category theory that we take a slightly generalized notion of ‚Äúsubobject‚Äù. Instead of using subset, where the elements of set \\(A\\) have to be contained in set \\(B\\), we just require there to be an injection from \\(A\\) to \\(B\\)! So we say that a subcategory of \\(\\mathsf{C}\\) is just another category \\(\\mathsf{D}\\) that has an injective functor into \\(\\mathsf{C}\\).\nThis follows from a more general principle that we should not distinguish between isomorphic objects. I.e., if we have an injective functor into \\(\\mathsf{C}\\), then \\(\\mathsf{D}\\) is isomorphic to the image of that functor, which is a literal subset of \\(\\mathsf{C}\\).\nNow that we have made this pedantic and subtle point, we will follow convention in category to ignore it, and say things like \\(\\mathsf{Preorder}\\) is a full subcategory of \\(\\mathsf{Cat}\\) without caring about the precise definition of preorder we have chosen.\nWith this out of the way, we now talk about a menagerie of functors. In category theory, often functors are described by what they do on objects, and their action on morphisms is inferred. This makes a good exercise for the reader; see if you can tell what the action on morphisms of each of the following functors is.\n\nThere is a functor \\(\\mathsf{Preorder} \\to \\mathsf{Cat}\\) that simply sends a preorder to that preorder viewed as a category, as we discussed before.\nThere is a functor \\(\\mathsf{Cat}\\) which sends a category \\(\\mathsf{C}\\) to the preorder with the objects of \\(\\mathsf{C}\\), and \\(x \\leq y\\) if and only if \\(\\mathrm{Hom}_{\\mathsf{C}}(x,y)\\) is non-empty.\nThere is a functor \\(\\mathsf{Preorder} \\to \\mathsf{Set}\\) which simply sends a preorder to its underlying set.\nThere is a functor \\(\\mathsf{Set} \\to \\mathsf{Preorder}\\) which sends a set \\(X\\) to the preorder with underlying set \\(X\\) where \\(x \\leq y\\) if and only if \\(x = y\\). Such a preorder is known as a discrete preorder.\nThere is a functor \\(\\mathsf{Set} \\to \\mathsf{Preorder}\\) which sends a set \\(X\\) to the preorder with underlying set \\(X\\) where \\(x \\leq y\\) always. Such a preorder is known as a codiscrete preorder.\n\nTo sum up, preorders are a special case of categories, where there is at most one morphism between any two objects. We now move on to another special case of categories."
  },
  {
    "objectID": "lecture5.html#monoids",
    "href": "lecture5.html#monoids",
    "title": "Lecture 5: A Variety of Categories and Functors",
    "section": "Monoids",
    "text": "Monoids\nPreorders are an ‚Äúextreme‚Äù example of categories, where there are lots of objects, but very few morphisms. The other extreme is monoids, where there is only one object, but plenty of morphisms. We start with the classical definition of morphism.\n\nA monoid is a set \\(M\\) along with a binary operation \\(\\ast \\colon M \\times M \\to M\\) and an element \\(e \\in M\\) such that:\n\nFor all \\(a,b,c \\in M\\), \\((a \\ast b) \\ast c = a \\ast (b \\ast c)\\)\nFor all \\(a \\in M\\), \\(a \\ast e = a = e \\ast a\\)\n\nWe call \\(e\\) the unit or identity element of the monoid, and \\(\\ast\\) the multiplication.\n\n\nabstract type Monoid{T} end\n\n# mul(m::Monoid{T}, x::T, y::T)::T\n# ident(m::Monoid{T})::T\n\n\nLet \\(A\\) be an alphabet, and let \\(A^{\\ast}\\) be the set of strings on that alphabet. For instance, if \\(A = \\{a,b,c\\}\\), then \\(A^{\\ast} = \\{[],[a],[b],[c],[aa],[ab],[ac],[ba],\\ldots\\}\\). Then if we define \\(\\ast\\) to be ‚Äúconcatenation‚Äù, i.e.¬†\\([ab] \\ast [cba] = [abcba]\\), and if we define \\(e = []\\), \\((A^{\\ast},\\ast,[])\\) is a monoid.\n\n\nstruct ConcatMonoid{T} <: Monoid{Vector{T}}\n  alphabet::Set{T}\nend\n\nfunction mul(m::ConcatMonoid{T}, xs::Vector{T}, ys::Vector{T}) where {T}\n  @assert all(x ‚àà m.alphabet for x in xs)\n  @assert all(y ‚àà m.alphabet for y in xs)\n  [xs; ys]\nend\nident(::ConcatMonoid{T}) where {T} = T[]\n\n\nAny of \\(\\mathbb{N},\\mathbb{Z},\\mathbb{Q},\\mathbb{R},\\mathbb{C}\\) with \\(+\\) or \\(\\cdot\\) is a monoid.\n\n\nThe set of \\(n \\times n\\) matrices with either matrix multiplication, element-wise multiplication, or element-wise addition is a monoid.\n\n\nThe set of subsets of some fixed set \\(A\\) with either intersection or union is a monoid. The unit of intersection is \\(A\\), and the unit of union is \\(\\emptyset\\).\n\n\nA monoid is precisely the same thing as a category with only a single object.\n\n\nProof. Suppose that \\(\\mathsf{C}\\) is a category with one object \\(x\\). Then \\(\\mathsf{Hom}_{\\mathsf{C}}(x,x)\\) is a monoid with multiplication \\(\\circ\\) and unit \\(1_x\\). Conversely, if \\(M\\) is a monoid, we can construct a category with one object \\(x\\), and \\(\\mathsf{Hom}_{\\mathsf{C}}(x,x) = M\\), with \\(\\circ = \\ast\\) and \\(1_x = e\\).\n\nMoreover, a functor between two monoids viewed as categories is a simply a function \\(F \\colon M \\to N\\) such that \\(F(a \\ast b) = F(a) \\ast F(b)\\), as the single object of the monoid has only one place to go!\nLet \\(\\mathsf{Mon}\\) be the category of monoids. Then there are a bunch of functors between \\(\\mathsf{Mon}\\) and our old familiar categories.\n\nThere is a functor \\(\\mathsf{Mon} \\to \\mathsf{Cat}\\) which sends a monoid to that monoid viewed as a category.\nThere is a functor \\(\\mathsf{Mon} \\to \\mathsf{Set}\\) which sends a monoid to its underlying set.\nThere is a functor \\(\\mathsf{Set} \\to \\mathsf{Mon}\\) which sends a set \\(A\\) to the monoid \\(A^{\\ast}\\) of strings on the alphabet \\(A\\)."
  },
  {
    "objectID": "lecture6.html#graphs",
    "href": "lecture6.html#graphs",
    "title": "Lecture 6: Path categories and functors as data structures",
    "section": "Graphs",
    "text": "Graphs\n\nA graph \\(G\\) consists of the following.\n\nA finite set \\(G(V)\\) of vertices\nA finite set \\(G(E)\\) of edges\nA function \\(G(\\mathrm{src}) \\colon G(E) \\to G(V)\\) called the source map\nA function \\(G(\\mathrm{tgt}) \\colon G(E) \\to G(V)\\) called the target map\n\n\nYou can think about this like a ‚Äúdatabase‚Äù with two tables, one table for edges and one table for vertices. The vertex table has only a primary key column, and the edge table has two foreign key columns in addition to a primary key column.\n\n\n\n\n\nA graph as a database\n\n\n\n\n\nArad to Bucharest\n\n\nFigure¬†1: Two illustrations of graphs. The first is a simple graph, translated into two ‚Äúdatabase tables‚Äù on the right as well. The second is a classic graph from computer science: major towns and cities in Romania. This graph is often used for search problems; finding the shortest path from Arad to Bucharest and for some reason is one of my favorite graphs.\n\n\nNotice that we allow multiple edges between a single pair of vertices, and also edges from a vertex to itself.\nIn Julia, we can represent this in the following way.\nstruct Graph\n  vertices::FinSet{Int}\n  edges::FinSet{Int}\n  src::FinFunction{Int,Int}\n  tgt::FinFunction{Int,Int}\nend\nNote that graphs seem somewhat similar to categories; vertices are analogous to objects and edges are analogous to morphisms. The important difference is that categories have composition and identities, and graphs don‚Äôt. There is, however, a way of building a category out of a graph, and that is the subject of the next section."
  },
  {
    "objectID": "lecture6.html#path-categories-and-functors-out-of-them",
    "href": "lecture6.html#path-categories-and-functors-out-of-them",
    "title": "Lecture 6: Path categories and functors as data structures",
    "section": "Path categories and functors out of them",
    "text": "Path categories and functors out of them\n\nIf \\(G\\) is a graph, then a path in \\(G\\) is a list \\(e_{1},\\ldots,e_{n}\\) of edges, such that \\(G(\\mathrm{tgt})(e_{i}) = G(\\mathrm{src})(e_{i+1})\\) for \\(i=1,\\ldots,n-1\\). We say that the path goes from \\(G(\\mathrm{src})(e_{1})\\) to \\(G(\\mathrm{tgt})(e_{n})\\).\n\n\nWe can make a path from Arad to Bucharest by going\nArad -> Sibiu -> Fagaras -> Bucharest\n\n\nIf \\(G\\) is a graph, then given a path \\(e_{1},\\ldots,e_{n}\\) from a vertex \\(a\\) to a vertex \\(b\\), and a path \\(e_{1}^{\\prime},\\ldots,e_{m}^{\\prime}\\) from \\(b\\) to another vertex \\(c\\), we can construct a path \\(e_{1},\\ldots,e_{n},e_{1}^{\\prime},\\ldots,e_{m}^{\\prime}\\) from \\(a\\) to \\(b\\).\n\nWhen you hear the word ‚Äúcompose‚Äù your eyes should light up and think ‚ÄúOh, is this a category?‚Äù And in this case, it is!\n\nFor any graph \\(G\\), there is a category \\(\\mathrm{Path}(G)\\), where the objects are vertices in \\(G\\) and a morphism from a vertex \\(a\\) to a vertex \\(b\\) is a path from \\(a\\) to \\(b\\) in \\(G\\). Composition is as it was in the proposition above, i.e.¬†list concatenation, and the identity on a vertex is simply the empty list.\n\nWhenever you see something that constructs something from another thing, you should think ‚Äúis this a functor‚Äù? And it turns out that \\(\\mathrm{Path}\\) is in fact a functor from the category of graphs to the category of categories. However, in order to write this down properly, we have to define the category of graphs, and we aren‚Äôt quite ready to do that yet (we will do it by the end of this lecture, though).\nThe category \\(\\mathrm{Path}(G)\\) has a special property. Namely, in order to define a functor \\(F\\) from \\(\\mathrm{Path}(G)\\) to a category \\(\\mathsf{C}\\), all you have to do is pick an object \\(F(v)\\) \\(\\mathsf{C}\\) for every vertex \\(v \\in G(V)\\), and then pick a morphism \\(F(e) \\colon F(G(\\mathrm{src})(e)) \\to F(G(\\mathrm{tgt})(e))\\) for every edge \\(e \\in G(E)\\).\nThen where do you send a path \\(e_{1},\\ldots,e_{n}\\)? Well, you just send it to the composite morphism \\(F(e_{n}) \\circ \\cdots \\circ F(e_{1})\\)! It turns out that any choice of the \\(F(e)\\) works for this; you get preservation of composition ‚Äúfor free‚Äù!\nSo it‚Äôs particularly easy to define a functor coming out of \\(\\mathrm{Path}(G)\\), and it‚Äôs also particularly easy to store such a functor: we just store an object for every vertex of \\(G\\) and a morphism for every edge.\nWe call a functor from \\(\\mathrm{Path}(G)\\) to \\(\\mathsf{Set}\\) an acset, pronounced to rhyme with ‚Äúhatchet‚Äù. Other terminology you might see (and the etymology for acset) is C-set or copresheaf. However, this can be confusing because sometimes the ‚ÄúC‚Äù in C-set refers to \\(\\mathrm{Path}(G)\\), but sometimes we just use C-set as a word. I like to use ‚Äúacset on schema C‚Äù instead of C-set, because then I can just say ‚Äúacset‚Äù without having to define C first. And copresheaf is just unnecessarily fancy. We say ‚Äúschema‚Äù here, because you can think of \\(\\mathsf{C} = \\mathrm{Path}(G)\\) as a ‚Äúdatabase schema‚Äù; we‚Äôll see more about this later.\nStrictly speaking, there‚Äôs more to an acset than what we just presented; the ‚Äúa‚Äù in acset stands for ‚Äúattributed‚Äù. But we will cover this later; functors from \\(\\mathrm{Path}(G)\\) to \\(\\mathsf{Set}\\) are a special case of acsets.\nWe will now look at some examples!"
  },
  {
    "objectID": "lecture6.html#graphs-1",
    "href": "lecture6.html#graphs-1",
    "title": "Lecture 6: Path categories and functors as data structures",
    "section": "Graphs",
    "text": "Graphs\nFirst of all, we can go meta and define graphs themselves this way!\nConsider the following graph \\(G\\).\n\n\n\nGraph schema\n\n\nWe let \\(\\mathsf{Gr} = \\mathrm{Path}(G)\\). Then an acset on \\(\\mathsf{Gr}\\) is a graph. Using graphs to define graphs is pretty trippy, but fortunately we can ‚Äúclose the loop‚Äù because our original definition of graph didn‚Äôt rely on any of this notation. Notice that we have been using the notation for a functor out of \\(\\mathsf{Gr}\\) all along however!"
  },
  {
    "objectID": "lecture6.html#petri-nets",
    "href": "lecture6.html#petri-nets",
    "title": "Lecture 6: Path categories and functors as data structures",
    "section": "Petri nets",
    "text": "Petri nets\nConsider the following graph \\(G\\).\n\n\n\nPetri net schema\n\n\nWe let \\(\\mathsf{Petri} = \\mathrm{Path}(G)\\). Then an acset on \\(\\mathsf{Petri}\\) is a petri net.\nExamples of Petri nets:\n\n\n\nSIR model\n\n\n\n\n\nLotka-Volterra model"
  },
  {
    "objectID": "lecture6.html#wiring-diagrams",
    "href": "lecture6.html#wiring-diagrams",
    "title": "Lecture 6: Path categories and functors as data structures",
    "section": "Wiring diagrams",
    "text": "Wiring diagrams\nConsider the following graph \\(G\\).\n\n\n\nDirected port graph schema\n\n\nWe let \\(\\mathsf{DPG} = \\mathrm{Path}(G)\\). Then an acset on \\(\\mathsf{DPG}\\) is a directed port graph.\n\n\n\nDirected port graph\n\n\nWiring diagrams are slightly more complicated, because they also allow incoming and outgoing wires. Wiring diagrams and directed port graphs can be used to model processes."
  },
  {
    "objectID": "lecture6.html#acsets-in-julia",
    "href": "lecture6.html#acsets-in-julia",
    "title": "Lecture 6: Path categories and functors as data structures",
    "section": "ACSets in Julia",
    "text": "ACSets in Julia\n(this part will be livecoded)"
  },
  {
    "objectID": "lecture6.html#sneak-peak-natural-transformations",
    "href": "lecture6.html#sneak-peak-natural-transformations",
    "title": "Lecture 6: Path categories and functors as data structures",
    "section": "Sneak peak: natural transformations",
    "text": "Sneak peak: natural transformations\nWe said before that there is a category of graphs. In this part, we will give a definition of a graph homomorphism that will make this precise. It turns out that this comes from a general definition of natural transformation, which can be defined at the level of functors and categories! However, we will only give a hint at what this is, and leave a full exploration of natural transformations to the next lecture.\n\nA graph homomorphism \\(\\alpha\\) from a graph \\(G\\) to a graph \\(H\\) consists of two maps\n\n\\(\\alpha_{V} \\colon G(V) \\to H(V)\\)\n\\(\\alpha_{E} \\colon G(E) \\to H(E)\\)\n\nsuch that \\(\\alpha_{V} \\circ G(\\mathrm{src}) = H(\\mathrm{src}) \\circ \\alpha_{E}\\) and \\(\\alpha_{V} \\circ G(\\mathrm{tgt}) = H(\\mathrm{tgt}) \\circ \\alpha_{E}\\).\nThis means that the graph homomorphism has to ‚Äúpreserve sources and targets‚Äù. Just like a functor has to send a morphism from \\(A\\) to \\(B\\) to a morphism from \\(F(A)\\) to \\(F(B)\\), a graph homomorphism has to send an edge from \\(a\\) to \\(b\\) to an edge from \\(\\alpha_V(a)\\) to \\(\\alpha_{V}(b)\\).\nThese conditions can be expressed equivalently as commutative diagrams. Basically, an commutative diagram is a way of writing an equation between composites of morphisms in a category. The equation is that when you compose the morphisms along any path in the diagram, you get the same result.\n\n\n\n\n\n\nIn a future lecture, we will see that these are specific instances of the so-called ‚Äúnaturality squares‚Äù for natural transformations.\n\n\n\n\nThree coloring graph\n\n\n\nA three-coloring of a graph \\(G\\) is a graph homomorphism from \\(G\\) into the graph above. It assigns each vertex of the graph to a color. Notice in a three-coloring, any two vertices connected by an edge must be assigned different colors, because there are no self-edges in the above graph."
  },
  {
    "objectID": "lecture7.html#recap",
    "href": "lecture7.html#recap",
    "title": "Lecture 7: Natural Transformations",
    "section": "Recap",
    "text": "Recap\nBefore we plunge into natural transformations, let‚Äôs briefly review the first six lectures, because it has been a while.\n\nIn lecture 1, we learned about what it means to do formal math, and we we did finite sets in Julia.\nIn lecture 2, we learned about morphisms between finite sets, including composition, surjections, injections, and bijections. We then learned about the idea of cardinality; how two finite sets can be isomorphic but not equal.\nIn lecture 3, we learned how finite sets and functions between them were a special case of a more general concept: a category. In order to do this, we had to first think about what it means to represent an infinite set in Julia, as a function from Any to Bool.\nIn lecture 4, we learned about functors between categories. We implemented a general pattern for functors in Julia, and then implemented a specific functor from the category of finite sets to the category of matrices.\nIn lecture 5, we learned about special cases of categories: partially ordered sets (each partially ordered set is a category, and the collection of all partially ordered sets with order-preserving maps is also a category) and monoids (each monoid is a category, and the collection of all monoids is also a category). Associated with these examples we also have a variety of functors; order-preserving maps are functors, monoid homomorphisms are functors, and we have a bunch of different functors between the categories of monoids, sets, and partial orders.\nFinally, in lecture 6 we learned about C-sets. We first learned about finitely-presented categories, i.e.¬†categories generated by a graph. We then showed that we could think about functors out of these path graph categories as databases, and then we implemented on the fly a version of databases based on this model. We finished by talking about graph homomorphisms.\n\nIn this lecture, we are going to pick up where we left off last time with graph homomorphisms, and talk about general natural transformations."
  },
  {
    "objectID": "lecture7.html#natural-transformations",
    "href": "lecture7.html#natural-transformations",
    "title": "Lecture 7: Natural Transformations",
    "section": "Natural transformations",
    "text": "Natural transformations\nI said before that category theory is unique among mathematics because it is its own metatheory; the collection of all categories forms a category, but the collection of all rings does not form a ring, nor does the collection of all PDEs form a PDE. However, I wasn‚Äôt quite telling the truth, because there is actually more structure to the collection of all categories than just a category.\nWe can not only consider morphisms between categories (i.e.¬†functors), but also morphisms between the functors themselves. We call these natural transformations. More generally, ‚Äúmorphisms that go between morphisms‚Äù are also called 2-morphisms, and we call ordinary morphisms 1-morphisms to contrast.\nThe standard picture for natural transformations is\n\n\n\n\n\nFigure¬†2: The natural transformation \\(\\alpha\\) is meant to look like it ‚Äúgoes between‚Äù \\(F\\) and \\(G\\)\n\n\nHowever, I‚Äôve always thought that this obscured an essential asymmetry to natural transformations, because there is a sense where natural transformations really ‚Äúlive in‚Äù \\(\\mathsf{D}\\), not in the abstract space between \\(\\mathsf{C}\\) and \\(\\mathsf{D}\\).\nA more informative picture is this:\n\n\n\n\n\nFigure¬†3: The natural transformation really ‚Äúlives in‚Äù \\(\\mathsf{D}\\).\n\n\nLooking at that picture already gives you half of the definition of a natural transformation, so we might as well go all the way and give the whole definition.\n\nLet \\(\\mathsf{C}\\) and \\(\\mathsf{D}\\) be categories, and \\(F,G \\colon \\mathsf{C} \\to \\mathsf{D}\\) be functors between them. Then a natural transformation \\(\\alpha \\colon F \\Rightarrow G\\) consists of a morphism \\(\\alpha_{c} \\colon F(c) \\to G(c)\\) for every object \\(c \\in \\mathsf{C}\\), such the following holds, which is called the naturality condition.\nFor all \\(c,c^{\\prime} \\in \\mathsf{C}\\) and all \\(f \\colon c \\to c^{\\prime}\\), the bottom square in Figure¬†4 commutes. That is, \\(G(f) \\circ \\alpha_{c} = \\alpha_{c^{\\prime}} \\circ F(f)\\), or in other words, you can follow any path and you get the same result.\n\n\n\n\n\n\nFigure¬†4: The naturality condition\n\n\nThis may seem like a big scary diagram, but I want to convince you that this condition is in fact very‚Ä¶ natural.\nRecall that a graph is a functor into \\(\\mathsf{Set}\\) from the category \\(\\mathsf{Gr}\\) which has two objects \\(V\\) and \\(E\\), and two non-identity morphisms \\(\\mathrm{src},\\mathrm{tgt} \\colon E \\to V\\).\nSuppose that \\(G_{1}\\) and \\(G_{2}\\) are graphs, and \\(\\alpha\\) is a natural transformation between them. Then \\(\\alpha\\) consists of two maps: a mapping of edges \\(\\alpha_{E} \\colon G_{1}(E) \\to G_{2}(E)\\) and a mapping of vertices \\(\\alpha_{V} \\colon G_{1}(V) \\to G_{2}(V)\\). The naturality condition for \\(\\mathrm{src}\\) can be written as in Figure¬†5.\n\n\n\n\n\nFigure¬†5: The naturality condition for \\(\\mathrm{src}\\).\n\n\nWhat does this mean? Well, if we follow the arrows in one way, this says that if we start with an edge in \\(G_{1}(E)\\), map it over to \\(G_{2}(E)\\) following the homomorphism, and then take its source, we get the same thing as if we started by taking its source and then mapped the source over.\nSo the naturality condition is precisely that sources and targets of edges are preserved.\nIf we do Petri nets next, the naturality condition just states that the sources and targets of arcs are preserved.\nThe plan for the live section of this lecture is to implement natural transformations in Julia building off of the implementation of C-sets that we had last time. But first, let‚Äôs give some examples of natural transformations between functors that are not C-sets.\n\nSuppose that \\(f, g \\colon \\mathbb{R} \\to \\mathbb{R}\\) are order-preserving functions, i.e.¬†endofunctors on the poset \\(\\mathbb{R}\\) considered as a category. Then a natural transformation \\(\\alpha \\colon f \\to g\\) would be a morphism \\(f(x) \\to g(x)\\) for every \\(x\\). As there is at most one morphism \\(f(x) \\to g(x)\\), and it exists only if \\(f(x) \\leq g(x)\\), there is at most one natural transformation \\(f \\Rightarrow g\\), and it exists only if \\(f(x) \\leq g(x)\\) for all \\(x\\). Thus, the collection of order-preserving maps \\(\\mathbb{R} \\to \\mathbb{R}\\) is itself a poset.\n\n\nSuppose that \\(G\\) and \\(H\\) are groups, and \\(f,g\\) are functors from \\(G\\) to \\(H\\) when viewed as one-element categories. Then a natural transformation from \\(f\\) to \\(g\\) is a choice of \\(h \\in H\\) such that \\(f(x) h = h g(x)\\) for all \\(x \\in G\\). Or in other words, \\(f(x) = h g(x) h^{-1}\\). If \\(H\\) is abelian (meaning that the multiplication is commutative), then this can only happen if \\(f(x) = g(x)\\). However, if \\(H\\) is non-commutative, then this ‚Äúconjugation‚Äù can be non-trivial.\nFor instance, suppose that \\(H\\) is the group of 2x2 real matrices, and \\(G\\) is the group of real numbers. Let \\(f \\colon G \\to H\\) send \\(\\theta \\in \\mathbb{R}\\) to a rotation by \\(\\theta\\), and \\(g \\colon G \\to H\\) send \\(\\theta\\) to a rotation by \\(-\\theta\\). Then if \\(h \\in H\\) is the mirror flip around the \\(y\\) axis, \\(f(\\theta) = h g(\\theta) h^{-1}\\). I encourage the interested reader to work this out by taking points on the unit circle, and rotating and flipping them in sequence.\n\n\nRecall in lecture 5 we defined several functors between \\(\\mathsf{Mon}\\) and \\(\\mathsf{Set}\\). One of these functors, which we will now call \\(F\\), sent a set \\(X\\) to the monoid \\(X^{\\ast}\\) of strings on the alphabet \\(X\\) (which you can also think of as lists with elements taken from \\(X\\)). Another functor, which we will now call \\(U\\), sent a monoid \\(M\\) to its underlying set.\nWe can compose these to get a functor \\(UF \\colon \\mathsf{Set} \\to \\mathsf{Set}\\). We then define a natural transformation \\(\\eta \\colon 1_{\\mathsf{Set}} \\to UF\\), where \\(1_{\\mathsf{Set}}\\) is the identity functor on \\(\\mathsf{Set}\\). For a set \\(X\\), \\(\\eta_{X}\\) sends an element \\(x \\in X = 1_{\\mathsf{Set}}(X)\\) to the singleton list \\([x] \\in X^{\\ast}\\).\nWe show naturality by recalling what \\(F\\) and \\(U\\) do on morphisms. Essentially, \\(UF\\) takes a morphism \\(f \\colon X \\to Y\\) and ‚Äúmaps it‚Äù over a list \\([x_{1},\\ldots,x_{n}]\\) to produce \\([f(x_{1}), \\ldots, f(x_{n})]\\). So naturality of \\(\\eta\\) is simply saying that taking the singleton of \\(f(x)\\) and mapping \\(f\\) over \\([x]\\) give the same result.\n\n(live section now)\nRemember, the jupyter notebooks for the live section can be found in the github repository for these lecture notes: Kittenlab.jl."
  },
  {
    "objectID": "lecture8.html#representable-functors",
    "href": "lecture8.html#representable-functors",
    "title": "Lecture 8: Universal Mapping Properties",
    "section": "Representable Functors",
    "text": "Representable Functors\nWe now have all the players in category theory: categories, functors, and natural transformations. But we need something to make them dance together; this thing is called universal mapping properties.\nUniversal mapping properties are the soul of category theory. The idea is that we characterize an object in a category by looking at all the morphisms in or out of that object. There are two ways to do this: look at the morphisms in, and look at the morphisms out. We‚Äôll start with morphisms out.\nFor any object \\(x\\) in a category \\(\\mathsf{C}\\), there is a functor\n\\[ \\operatorname{Hom}_{\\mathsf{C}}(x, -) \\colon \\mathsf{C}\\to \\mathsf{Set}\\]\ncalled the covariant representable functor on \\(x\\).1\n\\(\\operatorname{Hom}_{\\mathsf{C}}(x, -)\\) sends \\(y \\in \\mathsf{C}\\) to the set \\(\\operatorname{Hom}_{\\mathsf{C}}(x,y)\\) of morphisms from \\(x\\) to \\(y\\), and given a morphisms \\(g \\colon y \\to z\\), the function\n\\[ \\operatorname{Hom}_{\\mathsf{C}}(x,g) \\colon \\operatorname{Hom}_{\\mathsf{C}}(x,y) \\to \\operatorname{Hom}_{\\mathsf{C}}(x,z) \\]\nis given by composition, i.e.\n\\[ \\operatorname{Hom}_{\\mathsf{C}}(x,g)(f \\in \\operatorname{Hom}_{\\mathsf{C}}(x,y)) = g \\circ f \\in \\operatorname{Hom}_{\\mathsf{C}}(x,z) \\]\n\nLet \\(\\mathsf{C}= \\mathsf{Gr}\\), the schema for graphs. Then \\(\\operatorname{Hom}_{\\mathsf{Gr}}(V,-)\\) is the graph with one vertex \\(\\operatorname{id}_V \\in \\operatorname{Hom}_{\\mathsf{Gr}}(V,V)\\) and no edges:\n\n\n\nThe representable on \\(V\\)\n\n\nSimilarly, \\(\\operatorname{Hom}_\\mathsf{Gr}(E,-)\\) is the graph with one edge \\(\\operatorname{id}_E \\in \\operatorname{Hom}_{\\mathsf{Gr}}(E,E)\\) and two vertices \\(\\operatorname{src}, \\operatorname{tgt}\\in \\operatorname{Hom}_{\\mathsf{Gr}}(E,V)\\).\n\n\n\nThe representable on \\(E\\)\n\n\n\n\n\\(\\operatorname{Hom}_{\\mathsf{Set}}(2,-)\\) is the functor on \\(\\mathsf{Set}\\) that sends a set \\(X\\) to the set \\[\\{f \\colon 2 \\to X\\} = X^{2} \\] Given a function \\(f \\colon X \\to Y\\), \\(\\operatorname{Hom}_{\\mathsf{Set}}(2,f)\\) is the function that sends a tuple \\((x_{1},x_{2}) \\in X^2\\) to the tuple \\((f(x_{1}), f(x_{2})) \\in Y^2\\).\n\n\nFor \\(n \\in \\mathbb{N}\\), let \\(P_n\\) be the path graph of length \\(n\\). Then for a graph \\(G\\), \\(\\operatorname{Hom}_{\\mathsf{Set}^{\\mathsf{Gr}}}(P_{n}, G)\\) is the set of length-\\(n\\) paths in \\(G\\). Thus, we can think of the representable \\(\\operatorname{Hom}_{\\mathsf{Set}^{\\mathsf{Gr}}}(P_{n}, -)\\) as a functor which sends a graph to the set of length-\\(n\\) paths in that graph. Notice that as a special case if \\(n = 1\\), then this simply sends a graph to the set of edges in that graph. This is sneak peak at the Yoneda lemma (but we won‚Äôt get there today).\nIn catlab, we have a very powerful homomorphism search, which can actually compute the set \\(Hom_{\\mathsf{Set}^{\\mathsf{C}}}(G,H)\\) for any finite \\(\\mathsf{C}\\). There are all sorts of uses for this, but one is simply finding length-\\(n\\) paths in a graph!"
  },
  {
    "objectID": "lecture8.html#representatives-of-functors",
    "href": "lecture8.html#representatives-of-functors",
    "title": "Lecture 8: Universal Mapping Properties",
    "section": "Representatives of functors",
    "text": "Representatives of functors\nNow, there is a natural question to ask: can we go the other way? I.e., given a functor \\(F \\colon \\mathsf{C}\\to \\mathsf{Set}\\), is there an object \\(c \\in \\mathsf{C}\\) such that \\(F \\cong \\operatorname{Hom}_\\mathsf{C}(c,-)\\), where \\(\\cong\\) means natural isomorphism.\nThis is certainly not always the case, because there are graphs other than the single vertex graph and the single edge graph.\nBut when it is the case, it turns out that this \\(c\\) is unique up to isomorphism! That is, if \\(\\operatorname{Hom}_\\mathsf{C}(c, -) \\cong \\operatorname{Hom}_\\mathsf{C}(c', -)\\), then \\(c \\cong c'\\)! We won‚Äôt prove this today, but we will use it.\nSo this gives us a very powerful tool for constructing objects in a category; we can look for representatives of functors into \\(\\mathsf{Set}\\), and if they exist, they must be unique! Let‚Äôs do an example.\n\nLet \\(X\\) and \\(Y\\) be sets. Then consider the functor \\(F \\colon \\mathsf{Set}\\to \\mathsf{Set}\\) defined by\n\\[ F(Z) = \\operatorname{Hom}(X,Z) \\times \\operatorname{Hom}(Y,Z) \\]\nThe disjoint union \\(X+Y\\) of \\(X\\) and \\(Y\\) represents this functor. That is, there is a natural isomorphism\n\\[ \\operatorname{Hom}(X,-) \\times \\operatorname{Hom}(Y,-) \\cong \\operatorname{Hom}(X+Y,-) \\]\nWe can implement this isomorphism in Julia.\n\ninclude(\"../src/Kittenlab.jl\")\nusing .Kittenlab.FinSets\nusing .Kittenlab.Categories\n\nstruct Right{T}\n  val::T\nend\n\nstruct Left{T}\n  val::T\nend\n\ndisjoint_union(X::FinSet{S}, Y::FinSet{T}) where {S,T} =\n  Set{Union{Left{S}, Right{T}}}([Left.(X)..., Right.(Y)...])\n\n\ndisjoint_union(Set([1,2,3]), Set([1,2,3]))\n\nSet{Union{Left{Int64}, Right{Int64}}} with 6 elements:\n  Right{Int64}(3)\n  Left{Int64}(2)\n  Right{Int64}(2)\n  Right{Int64}(1)\n  Left{Int64}(3)\n  Left{Int64}(1)\n\n\n\n# Hom(X,-) x Hom(Y,-) -> Hom(X+Y,-)\ncopair(f::FinFunction{X,Z}, g::FinFunction{Y,Z}) where {X,Y,Z} =\n  FinFunction{Union{Left{X}, Right{Y}},Z}(\n    disjoint_union(dom(FinSetC(), f), dom(FinSetC(), g)),\n    codom(FinSetC(), g),\n    Dict(\n      vcat(\n        [Left(x) => f(x) for x in dom(FinSetC(), f)],\n        [Right(x) => g(x) for x in dom(FinSetC(), g)],\n      )\n    )\n  )\n\n# Hom(X+Y,-) -> Hom(X,-) x Hom(Y,-)\nunpack(xs::FinSet{X}, ys::FinSet{Y},\n       f::FinFunction{Union{Left{X}, Right{Y}}, Z}) where {X,Y,Z} =\n    (\n      FinFunction{X,Z}(\n        xs, codom(FinSetC(), f),\n        Dict(x => f(Left(x)) for x in xs)\n      ),\n      FinFunction{Y,Z}(\n        ys, codom(FinSetC(), f),\n        Dict(y => f(Right(y)) for y in ys)\n      )\n    )\n\nxs = Set([1,2,3])\nys = Set([1,2,3])\nzs = Set([:a,:b])\n\nf = FinFunction(xs, zs, Dict([1 => :a, 2 => :b, 3 => :b]))\ng = FinFunction(ys, zs, Dict([1 => :b, 2 => :b, 3 => :a]))\n\n(f‚Ä≤, g‚Ä≤) = unpack(xs, ys, copair(f, g))\n(f == f‚Ä≤, g == g‚Ä≤)\n\n(true, true)\n\n\n\nHowever, there‚Äôs no reason why we should only consider such a construction for \\(\\mathsf{Set}\\).\n\nIn a general category \\(\\mathsf{C}\\), a representing object of \\(\\operatorname{Hom}(x,-) \\times \\operatorname{Hom}(y,-)\\) is called the coproduct of \\(x\\) and \\(y\\), and we write it as \\(x + y\\). A category is said to have coproducts if there exists a coproduct for every pair \\(x,y \\in \\mathsf{C}\\).\n\nRecall that representing objects are unique up to isomorphism, so the coproduct of two objects is unique up to isomorphism, which justifies our use of the word ‚Äúthe‚Äù.\n\nThe category of graphs has coproducts. The coproduct of two graphs \\(G\\) and \\(H\\) has\n\\[\n\\begin{align*}\n  (G + H)(V) &= G(V) + H(V) \\\\\n  (G + H)(E) &= G(E) + H(E) \\\\\n\\end{align*}\n\\]\n\nIn fact, all categories of \\(\\mathsf{C}\\)-sets have coproducts, given in a similar manner.\nThat about wraps up the material for this lecture, but before we close, I want to present the ‚Äúmore traditional way‚Äù of talking about coproducts.\nFollowing the isomorphism\n\\[ \\operatorname{Hom}(X+Y, -) \\cong \\operatorname{Hom}(X, -) \\times Hom(Y, -) \\]\nwith \\(\\operatorname{id}_{X+Y} \\in \\operatorname{Hom}(X+Y, X+Y)\\), we get two maps\n\\[ \\iota_{X} \\in \\operatorname{Hom}(X, X+Y), \\iota_{Y} \\in Hom(Y, X+Y) \\]\nWe say that \\(X+Y\\) is the universal object with these mappings, which means that for any other\n\n\n\nthere is a unique map \\(\\langle f, g \\rangle \\colon X+Y \\to Z\\) such that the following commutes.\n\n\n\nWe leave it to the reader to show that this is an equivalent definition of coproduct!"
  },
  {
    "objectID": "lecture9.html#colimits-as-gluing",
    "href": "lecture9.html#colimits-as-gluing",
    "title": "Lecture 9: Colimits",
    "section": "Colimits as gluing",
    "text": "Colimits as gluing\nThe core idea behind colimits is that we take a bunch of objects in a category, take their ‚Äúdisjoint union‚Äù (i.e., their \\(n\\)-ary coproduct), and then ‚Äúglue‚Äù parts of those objects together.\nSo before we get into the category theory, let‚Äôs talk about exactly what that means.\nWe want to be able to ‚Äúdeclare by fiat‚Äù that two elements of a set are actually the same element. How can we record this declaration mathematically?\nWe start out with a set \\(X\\). We then make a relation on \\(X\\), i.e.¬†\\(R \\subset X \\times X\\), where \\((x,x') \\in X\\) if we are ‚Äúdeclaring‚Äù that \\(x\\) should be equal to \\(x'\\).\nThis relation should satisfy three properties.\n\n\\((x,x) \\in R\\) for all \\(x\\)\nIf \\((x,y) \\in R\\), then \\((y, x) \\in R\\)\nIf \\((x,y) \\in R\\) and \\((y,z) \\in R\\), then \\((x,z) \\in R\\)\n\nOne way of saying this succinctly is that \\((X,R)\\) is a preorder where all morphisms are invertible. This is called an equivalence relation.\nWe can then take the set of ‚Äúconnected components‚Äù, which we call \\(X/R\\). An element of \\(X/R\\) is a subset \\(U\\) of \\(X\\) such that for all \\(x,y \\in U\\), \\((x,y) \\in R\\), and if \\(x \\in U\\) and \\((x,y) \\in R\\), then \\(y \\in U\\).\nThere is a very efficient data structure for storing an equivalence relation on the set \\(\\{1,\\ldots,n\\}\\), called a union find.\nWe‚Äôre going to start with a more naive data structure, and then improve it to a union find.\nThe idea is that we choose a representative for each equivalence class, and we store the mapping from number to representative in an array. Two elements are in the same equivalence class if and only if their representatives are the same.\nWe start out with the equivalence classes \\(\\{\\{1\\},\\ldots,\\{n\\}\\}\\), and thus each element is assigned itself as a representative.\nstruct RepStore\n  representative::Vector{Int}\n  function RepStore(n::Int)\n    new(Vector{Int}(1:n))\n  end\nend\n\nequivalent(uf::RepStore, i::Int, j::Int) = uf.representative[i] == uf.representative[j]\nWe now want to be able to ‚Äúdeclare by fiat‚Äù that two elements are equal. Naively, an algorithm for this would look something like the following.\nfunction union!(uf::RepStore, i::Int, j::Int)\n  irep, jrep = uf.representative[i], uf.representative[j]\n  for k in 1:length(uf.representative)\n    if uf.representative[k] == jrep\n      uf.representative[k] = irep\n    end\n  end\nend\nThis sets anything that previously had the same representative as j to now have the same representative as i.\nBut we can do better than this. Ideally, we would just write\nfunction union!(uf::RepStore, i::Int, j::Int)\n  irep, jrep = uf.representative[i], uf.representative[j]\n  uf.representative[jrep] = irep\nend\nThis doesn‚Äôt quite work. In order to make it work, we use a different strategy for storing the representatives.\nstruct UnionFind\n  parent::Vector{Int}\n  function UnionFind(n::Int)\n    new(Vector{Int}(1:n))\n  end\nend\n\nfunction find_root(uf::UnionFind, i::Int)\n  parent = uf.parent[i]\n  if parent == i\n    i\n  else\n    find_root(uf, parent)\n  end\nend\n\nfunction union!(uf::UnionFind, i::Int, j::Int)\n  iroot, jroot = find_root(uf, i), find_root(uf, j)\n  uf.parent[jroot] = iroot\nend\nThis implicitly stores the representative for each equivalence class via a chain of links. One way of thinking about this is that we are storing a forest of nodes, and we can check if two nodes are in the same tree by following the links up to the root and checking if the root is the same for each.\nThere are then several optimizations that we can make then in order to make this run even faster, which we won‚Äôt get into now, but once we have done that find_root and union! both run in essentially constant time.\nSo this gives us a good way of ‚Äúdeclaring by fiat‚Äù that two elements of a set are equal: we just run merge! on them.\nLet‚Äôs now use this to make an implementation of the categorical operation of pushout."
  },
  {
    "objectID": "lecture9.html#pushouts",
    "href": "lecture9.html#pushouts",
    "title": "Lecture 9: Colimits",
    "section": "Pushouts",
    "text": "Pushouts\nA pushout is a type of colimit, and understanding how pushouts work will generalize well to understanding of general colimits.\n\nSuppose we have the following diagram in a category \\(\\mathsf{C}\\)\n\n\n\nThen the pushout of this diagram is given by another object \\(X +_{Z} Y \\in \\mathsf{C}\\) along with maps \\(\\iota_{X}\\), \\(\\iota_{Y}\\) and \\(\\iota_{Z}\\) that make the following commute\n\n\n\nsuch that for any \\(W\\) with \\(\\iota_{X}'\\), \\(\\iota_{Y}'\\) \\(\\iota_{Z}'\\) similar, there exists a unique map \\(p_{W} \\colon X +_{Z} Y \\to W\\) such that the following commutes.\n\n\n\n(there should also be \\(\\iota_{Z}\\) and \\(\\iota_{Z}'\\), but it‚Äôs hard to fit them in that diagram).\n\nThe way we think about this is that \\(X +_{Z} Y\\) is the coproduct of \\(X\\) and \\(Y\\), but with the image of \\(Z\\) in \\(X\\) ‚Äúequalized by fiat‚Äù with the image of \\(Z\\) in \\(Y\\).\n\nIn \\(\\mathsf{Set}\\), the pushout of the diagram\n\n\n\nis \\(X + Y/\\sim\\), where \\(\\sim\\) is the equivalence relation generated by \\(f(z) \\sim g(z)\\) for all \\(z \\in Z\\).\nWe compute this with\nfunction pushout(f::FinFunction, g::FinFunction)\n  @assert dom(f) == dom(g)\n  n = length(codom(f))\n  m = length(codom(g))\n  po = UnionFind(n + m)\n  for z in dom(f)\n    union!(po, f(z), n + g(z))\n  end\n  roots = unique!([find_root(res, i) for i in 1:length(po)])\n  (Set(roots),\n   Dict(i => find_root(res, f(i)) for i in 1:n),\n   Dict(i => find_root(res, g(i) + n) for i in 1:m),\n   )\nend\nWhy is this a pushout? Well, given another set \\(W\\) with maps in from \\(X\\), \\(Y\\) and \\(Z\\) that commute, we can figure out where to send each equivalence class in \\(X+Y/\\sim\\), because by the commutation property, all elements of each equivalence class have to go to the same element of \\(W\\).\n\nWe can do the exact same thing for graphs. We can take two graphs, take their coproduct, and then ‚Äúglue‚Äù some of their edges and vertices together, according to maps out of a third graph.\nNow, recall in the last lecture that we characterized coproducts as representatives of certain functors. We can do the exact same thing here, but we have to describe the functor that it‚Äôs representing in a special way.\nLet \\(\\mathsf{D}\\) be the category presented by the graph\n\n\n\nThen the ‚Äúsetup‚Äù for a pushout is a functor \\(F \\colon \\mathsf{D} \\to \\mathsf{C}\\).\n\nThe pushout of \\(F \\colon \\mathsf{D} \\to \\mathsf{C}\\) is a representing object for \\(\\operatorname{Hom}_{\\mathsf{C}^{\\mathsf{D}}}(F, \\Delta(-))\\), where \\(\\Delta \\colon \\mathsf{C}\\to \\mathsf{C}^{\\mathsf{D}}\\) sends an object \\(X\\) to the constant functor at \\(X\\).\n\n\nProof. An element of \\(\\operatorname{Hom}_{\\mathsf{C}^{\\mathsf{D}}}(F, \\Delta(W))\\) is a natural transformation \\(\\alpha\\) from \\(F\\) to \\(\\Delta(W)\\). Remember, a natural transformation consists of a morphism in \\(\\mathsf{C}\\) for every object in \\(\\mathsf{D}\\), so in this case we have three morphisms. Then the naturality condition implies that the diagram\n\n\n\ncommutes.\nA representative of \\(\\operatorname{Hom}_{\\mathsf{C}^{\\mathsf{D}}}(F, \\Delta(-))\\) is an object \\(\\varprojlim F \\in \\mathsf{C}\\) such that \\(\\operatorname{Hom}_{\\mathsf{C}}(\\varprojlim F, W) \\cong \\operatorname{Hom}_{\\mathsf{C}^{\\mathsf{D}}}(F, \\Delta(W))\\). We can show that such an object satisfies the earlier definition of pushout by passing in the identity on \\(\\varprojlim F\\) into the right hand side, to get a map \\(\\operatorname{Hom}_{\\mathsf{C}^{\\mathsf{D}}}(F, \\Delta(\\varprojlim F))\\) that gives the diagram in the definition. And then the naturality of the isomorphism gives us the factorization property. The converse can be proved similarly.\n\nThis gives us a hint on how to do general colimits.\n\nGiven two categories \\(\\mathsf{D}\\) and \\(\\mathsf{C}\\), and a functor \\(F \\colon \\mathsf{D} \\to \\mathsf{C}\\), the colimit \\(\\varprojlim F\\) is the representing object for \\(\\operatorname{Hom}_{\\mathsf{C}^{\\mathsf{D}}}(F, \\Delta(-))\\) (if such an object exists).\n\n\nIf \\(\\mathsf{D}\\) is the discrete category with two objects, then we just get coproducts again. More generally, we can do \\(n\\)-ary coproducts by making \\(\\mathsf{D}\\) the discrete category with \\(n\\) objects.\n\n\nIf \\(\\mathsf{D}\\) is the empty category, what do we get? Well \\(\\operatorname{Hom}_{\\mathsf{C}^{\\mathsf{D}}}(F, \\Delta(-))\\) is always a singleton, if \\(F\\) is the unique functor from \\(\\mathsf{D}\\) to \\(\\mathsf{C}\\). So we are looking for an object \\(X \\in C\\) such that \\(\\operatorname{Hom}(X,Y)\\) is a singleton for all \\(Y\\).\nIn \\(\\mathsf{Set}\\), this is the empty set. More generally, this is called an initial object.\n\n\nIf \\(\\mathsf{D}\\) is a category that looks like this:\n\n\n\nthen the colimit of a functor \\(F \\colon \\mathsf{D} \\to \\mathsf{C}\\) is called a coequalizer.\nCategory theory is the subject where the examples have examples: let‚Äôs give an example of a coequalizer. Suppose that \\(\\mathsf{C}\\) is the category of abelian groups, and we have the diagram\n\n\n\nwhere \\(H\\) is a subgroup of \\(G\\), \\(f\\) is the inclusion, and \\(0\\) is the constant map at the identity. Then the coequalizer of that diagram is \\(G/H\\), the quotient group. This is the group that results from ‚Äúdeclaring by fiat‚Äù every element of \\(H\\) to be \\(0\\).\n\nColimits are a rich subject which we will no doubt return to over and over again, but that will be it for today!"
  },
  {
    "objectID": "lecture10.html",
    "href": "lecture10.html",
    "title": "Lecture 10: Applied Colimits",
    "section": "",
    "text": "$$ \n\n\n$$\n\nOur goal for the next couple lectures is to learn how to compose open graphs.\n\nAn open graph is a graph \\(G\\) along with an input set \\(I\\) and an output set \\(O\\) and maps \\(i \\colon I \\to G(V)\\), \\(o \\colon O \\to G(V)\\).\n\n\n\n\nAn Open Graph\n\n\nWe want to make a category where the objects are finite sets and the morphisms are open graphs between the finite sets.\nWe are going to build up the technology for this category in parts. The first step is defining what a cospan category is. The second step is going to generalize this.\n\nA cospan in a category \\(\\mathsf{C}\\) from an object \\(X \\in \\mathsf{C}\\) to an object \\(Y \\in \\mathsf{C}\\) is a diagram of the form\n\n\n\n\n\nLet \\(\\mathsf{C}\\) be a category that has pushouts. Then define the category \\(\\operatorname{Csp}(\\mathsf{C})\\) in the following way. The objects of \\(\\operatorname{Csp}(\\mathsf{C})\\) are the objects of \\(\\mathsf{C}\\), and a morphism from \\(X\\) to \\(Y\\) is a cospan from \\(X\\) to \\(Y\\). Composition of two cospans\n\n\n\nis given by the pushout\n\n\n\n\nWhat is the identity in this category? I claim that the identity on \\(X\\) is\n\n\n\nLet‚Äôs prove that this is the case. Suppose that we have another cospan\n\n\n\nThen their composition is\n\n\n\nI want to show that \\(A = X +_{X} A\\), and that the two upper morphisms are \\(f\\) and \\(1_A\\) respectively.\nImmediately here, alarm bells should be going off in your head. Showing that two objects in a category are equal is almost always the wrong thing to do! Instead, one should show that two objects are isomorphic. But in this case, these ‚Äúobjects‚Äù are serving the purpose of morphisms, and morphisms need to be equal ‚Äúon the nose‚Äù! So what do we do?\nWe have to redefine \\(\\operatorname{Csp}(\\mathsf{C})\\). There are two ways of doing this. One is that we can consider a notion of morphism between morphism, which gets us into bicategories. But we choose to not walk that route today.\nThe second way is to make a morphism from \\(X\\) to \\(Y\\) be an equivalence class of cospans.\n\nThe two cospans\n\n\n\nand\n\n\n\nare equivalent when there exists an isomorphism \\(\\phi \\colon A \\to A'\\) such that\n\n\n\ncommutes.\n\nWe then redefine \\(\\operatorname{Csp}(\\mathsf{C})\\).\n\nThe category \\(\\operatorname{Csp}(\\mathsf{C})\\) has as objects, objects of \\(\\mathsf{C}\\), and as morphisms equivalence classes of cospans.\nGiven two morphisms \\(E_{1} \\colon X \\to Y\\) and \\(E_{2} \\colon Y \\to Z\\), we compose them by picking a cospan from \\(E_{1}\\), a cospan from \\(E_{2}\\), taking their pushout, and then taking the equivalence class of all morphisms equivalent to that pushout.\n\nThere‚Äôs something very important that we have to check for this to work: we have to check that composing equivalent cospans give equivalent results! Proving this will enable us to flex some of our theoretical muscles for pushouts.\n\nSuppose that we have the following commuting diagram:\n\n\n\nwhere \\(\\phi\\) and \\(\\psi\\) are isomorphisms. Then there is an isomorphism \\(\\phi +_Y \\psi \\colon A +_Y B \\to A' +_Y B'\\) such that the diagram\n\n\n\ncommutes.\n\n\nProof. This is our first big serious proof in category theory, so before we get started, let‚Äôs just make sure we understand where we are and where we‚Äôre going.\nThe diagrams above look big and scary, but when we chunk them, they aren‚Äôt so bad. We have two pairs of equivalent cospans: two equivalent cospans between \\(X\\) and \\(Y\\), and two equivalent cospans between \\(Y\\) and \\(Z\\). Then we‚Äôve composed each one, to get the top and bottom of the diagram, and finally the curved arrow is an isomorphism between the composed cospans.\nOften in proofs like this, it is hard to know where to start. One good thing to do is to go back to definitions.\nLet \\(\\mathsf{D}\\) be the category that looks like this\n\n\n\nLet \\(F, F'\\) be functors from \\(\\mathsf{D}\\) into \\(\\mathsf{C}\\) that send\n\n\n\nto\n\n\n\nand\n\n\n\nrespectively.\nThen recall that the pushout of the diagram \\(F\\) is a representing object for the functor\n\\(X \\mapsto \\operatorname{Hom}_{\\mathsf{C}^{\\mathsf{D}}}(F, \\Delta X)\\)\nwhich sends an object \\(X\\) to the set of natural transformations from \\(F\\) to the constant functor at \\(X\\), i.e.¬†commuting diagrams\n\n\n\nwhich are the same as commuting squares\n\n\n\nNow, I claim that if we can show that \\(F\\) and \\(F'\\) are naturally isomorphic functors, then the pushout of \\(F\\) and the pushout of \\(F'\\) will be isomorphic as well.\nThis is because if \\(F \\cong F'\\), then \\(\\operatorname{Hom}_{C^{\\mathsf{D}}}(F, \\Delta-) \\cong \\operatorname{Hom}_{C^{\\mathsf{D}}}(F', \\Delta-)\\), and representing objects of isomorphic functors are isomorphic. I‚Äôm not sure if we‚Äôve proved that explicitly by now; it‚Äôs a consequence of the Yoneda lemma, but it should be intuitive!\nTo show that \\(F\\) and \\(F'\\) are naturally isomorphic, we must construct a natural isomorphism. This consists of an isomorphism \\(F(x) \\cong F'(x)\\) for each \\(x \\in \\mathsf{D}\\), chosen to satisfy the naturality condition. But we are given exactly what we need by our assumption! Namely, we make the following natural isomorphism:\n\n\n\nNow, through what some might call ‚Äúabstract nonsense‚Äù, we have summoned an isomorphism from \\(A +_{Y} B\\) to \\(A' +_{Y} B'\\): we will call this isomorphism \\(\\phi +_{Y} \\psi\\).\nThis is not enough though: we still have to show that the whole diagram commutes! Unfortunately, I can‚Äôt think of a slick way to do this quickly, so instead I will summarize the strategy. Basically, you have to trace through the proof that isomorphic functors give isomorphic representing objects, and you will see that the construction of the isomorphism shows that this should commute."
  }
]