[
  {
    "objectID": "index.html",
    "href": "index.html",
    "title": "Kittenlab lecture notes",
    "section": "",
    "text": "Introduction\nThis is a Quarto book.\nTo learn more about Quarto books visit https://quarto.org/docs/books."
  },
  {
    "objectID": "lecture1.html",
    "href": "lecture1.html",
    "title": "Lecture 1: Formal Math",
    "section": "",
    "text": "Introduction\nThese lectures are meant to go from 0 to category theory as efficiently as possible. This means that we are going to optimize for being precise, for being clear, and for opening up new possibilities for you. We are not going to optimize for being entertaining or engaging; this is not a ‚Äúmonads as burritos‚Äù blog post or a popsci article about category theory. The answer to ‚Äúwhy do we care about this‚Äù is often going to be ‚Äúbecause it‚Äôs important later on‚Äù, and you are just going to have to trust me on that.\nAs we are going from 0, in this first lecture I plan to get you all aquainted with what it even means to ‚Äúdo math‚Äù at the level that category theory lives. This is a different kind of math than what you might have learned about in lower level math courses, and so sorting out from the beginning the mindset that you should have for the rest of the lectures is the most efficient use of this time. Generally, nobody tells you about this distinction and you have to work it out painfully over years of getting bad grades on university math homeworks; we don‚Äôt have time for that.\nHowever, we will have code examples for you to play with, because most of you are programmers and thus making a connection between math and code should speed the learning process.\nFinally, everyone at some point in this lecture will be frustrated by how pedantic I‚Äôm being. Sorry. I‚Äôm erring on the side of pedantry because there‚Äôs a ‚Äúprice is right‚Äù situation here: if I go too slow, we waste a bit of time, but if I go too fast we waste all of the time.\nPure math consists of a series of definitions, propositions, and examples. In this document, we typeset these like\nA definition introduces a new word, and I will always put that new word in bold. In normal speech, words have meanings given by context, by association, and only sometimes by explicit definition. In math, it is not like that. Every technical word has a single definition. That definition may not be written down explicitly; it may be agreed implicitly between mathematicians based on shared experience. However, in theory there is always a precise definition for every mathematical concept. It is expected that all participants in a mathematical conversation could be locked up in a cell, given paper, a pencil and a great deal of time, and then write down a fully rigorous formulation of each of the words they are using. Moreover, each of these formulations for each of the mathematicians might not be exactly the same, but they should be able to be proven equivalent.\nUntil you learn mathematical logic, which we will not cover here, this expectation cannot be realized because you don‚Äôt know a precise definition of ‚Äúfully rigorous‚Äù. The level of rigor that will suffice for now is that you should be able to expand every definition to a level where it can be explained to a smart, patient human who knows no category theory, by going backwards and defining each of the terms used in that definition until you get to very basic concepts, like sets, functions, and equations.\nThe extremely important corollary to all of this is that if you feel like your understanding of a definition does not reach this level, YOU ARE CONFUSED. This is OK. It is good to be confused. It is far better to be confused and not yet wrong than it is to be unconfused and wrong.\nWhat should you do when you are confused? First of all, GO BACKWARDS. Read the previous section of a textbook. If you are still confused, keep going backwards until you hit something that makes sense, and then work your way back up. Secondly, GO SIDEWAYS. Read another textbook that treats the same material in a different way. Then finally, if neither of those work, ASK AN EXPERT, and keep asking until you feel unconfused. The MOST IMPORTANT SKILL in math is to know when you are confused and don‚Äôt continue until you are unconfused! If you continue on, you will get hopelessly confused; if you turn back immediately there is still hope.\nDefinitions are the most important part of higher math. Understanding the definitions is often half the battle, and it is most of the battle for category theory.\nA proposition is an assertion that one logical statement (the conclusion) follows from several logical statements (the premises). Each proposition comes along with a proof. Just like definitions, it is expected that the participants in a mathematical conversation could expand a proof out to a fully rigorous level, even if the given proof is very vague. What you write down as a proof should be seen as a ‚Äúhint‚Äù for the construction of the actual, fully rigorous proof; mathematicians come to cultural agreements for how much of a hint is needed in different circumstances.\nAs a mathematical learner, proofs are your window into the thought processes of subject experts. Thus, they are very good to study and understand. However, they are not as critical to understand as definitions. It is absolutely essential to fully understand definitions, but proofs can be ‚Äúblackboxed‚Äù sometimes, and you can just remember the proposition without understanding fully the proof.\nPropositions are also known as theorems, lemmas, and corollaries. A theorem is an important proposition, a lemma is a small proposition mainly used to prove other propositions, and a corollary is a proposition whose proof is easy because of another proposition, for example a special case. Really, these are just vibes that mathematicians add to propositions.\nFinally, an example is a definition or proposition that falls under one of three categories.\nA pure math document consists of a sequence of definitions, propositions, and examples, punctuated with interleaving prose that attempts to give intuition for what the definitions, propositions, and examples are saying, and why one should care about those definitions, propositions, and examples. Intuition is a very important part of math; it is what allows mathematicians to elaborate definitions, discover proofs, and most importantly, to figure out what is important to study in the first place. However, intuition is no substitute for rigor. Intuition allows you to leap off cliffs; rigor is what allows you to build a bridge underneath you before you hit the ground.\nIn the foundations of math, we also have two more types of statement: axioms and undefined terms. Definitions and propositions should always ‚Äúbottom out‚Äù at axioms and undefined terms. However, most mathematicians do not do this, instead leaving it to the reader to choose a suitable foundations of math in which to fully formalize their theories. Surprisingly, most interesting math can be fully formalized in many foundations, so this normally works out fine.\nFor us, our ‚Äúreality‚Äù will be what happens on the computer. So we will try to ‚Äúbottom out‚Äù on concepts in the computer.\nWe will now demonstrate the previous concepts by studying finite sets. We will not get to category theory today. Instead, we will revisit some things that should be familiar to you and treat them in the style that we will be using for the rest of the lectures.\nFinite sets will be important for most of the applications of category theory that we will learn in the next lectures, and also most of the concepts of category theory are well-illustrated by finite sets. So a firm grasp of finite sets will be an immense aid in the coming weeks.\nWe start with a basic universe of discourse. It is traditional to be minimalistic with this universe of discourse, and say that everything is a set, or everything is a natural number. However, we choose to be untraditional.\nWe might represent this in Julia with the following data structure.\nNote that this is not the only possible representation of a finite set. Definitions in math always can be translated into code in many ways; the choice of a particular way is a delicate balancing act between simplicity, performance, clarity, and completeness.\nAnother possible representation of finite sets is\nThis represents the finite set \\(\\{1,\\ldots,n\\}\\). Here we have traded performance over completeness; we can only represent some finite sets, but we represent those finite sets more efficiently.\nIt is important to note that even if \\(a\\) is listed multiple times in \\(A\\), \\(f(a)\\) only has one value.\nWe might represent a function between ùîΩs, also known as a morphism of finite sets, with the following data structure.\nHowever, not all instances of this data structure represent functions. The following Julia function determines whether a morphism of finite sets is valid.\nFrequently we will write down Julia types representing mathematical concepts where not all values of that type are valid representations of that mathematical concept. This is unavoidable because Julia types do not have the specificity to narrow down the space of values enough. There are languages where the types can narrow down the space of values sufficiently, but none of those languages have well-maintained BLAS/LAPACK bindings.\nFor finite sets implemented by IntùîΩ, we can give a more efficient encoding of morphism.\nwith corresponding validation function\nFrom now on, we will work with only VecùîΩs and ùîΩMors, and leave the implementation of more efficient code to the reader."
  },
  {
    "objectID": "lecture1.html#takeaways",
    "href": "lecture1.html#takeaways",
    "title": "Lecture 1: Formal Math",
    "section": "Takeaways",
    "text": "Takeaways\n\nPure math consists of definitions, propositions, and examples.\nThese are specified in enough detail so that participants in a mathematical conversation could independently come up with equivalent elaborations.\nIf you feel you could not do this at any point, then you are in a perfectly normal situation and should not feel ashamed whatsoever. However, continuing on without first going back and understanding what you are confused about is a bad idea."
  },
  {
    "objectID": "lecture1.html#takeaways-1",
    "href": "lecture1.html#takeaways-1",
    "title": "Lecture 1: Formal Math",
    "section": "Takeaways",
    "text": "Takeaways\n\nA finite set is a list of things\nA morphism of finite sets from \\(A\\) to \\(B\\) sends each unique element of \\(A\\) to an element of \\(B\\)\nThere are multiple ways of implementing representations of finite sets and morphisms between them on the computer"
  },
  {
    "objectID": "lecture2.html",
    "href": "lecture2.html",
    "title": "Lecture 2: The Category Theory of Finite Sets",
    "section": "",
    "text": "Composition and Isomorphisms\nWe now introduce the operation at the core of all category theory: composition!\nWe now come to an issue that is everywhere in category theory: equality. If you have seen any set theory before, you might think that \\(\\{1,2,3,3\\}\\) and \\(\\{3,2,1\\}\\) are ‚Äúthe same‚Äù set. Note however that when I defined finite set, I just said that a finite set was a list of things surrounded by curly braces.\nSo it seems like something is wrong with our definition.\nBut let‚Äôs think about why we typically choose to make \\(\\{1,2,3,3\\}\\) and \\(\\{3,2,1\\}\\) ‚Äúthe same‚Äù set. One good reason is that any morphism out of \\(\\{1,2,3,3\\}\\) can be seen as a morphism out of \\(\\{3,2,1\\}\\), and the same goes for incoming morphisms.\nTherefore, from a ‚Äúmorphism‚Äôs-eye‚Äù perspective, \\(\\{1,2,3,3\\}\\) and \\(\\{3,2,1\\}\\) behave the exact same way; defining a morphism out of one is the same as defining a morphism out of the other.\nBut if we take this to its logical conclusion, we find that this is true not only of \\(\\{1,2,3,3\\}\\) and of \\(\\{3,2,1\\}\\), but also of \\(\\{1,2,3\\}\\) and \\(\\{\\mathbf{a},\\mathbf{b},\\mathbf{c}\\}\\)!\nTo see this, let \\(B = \\{1,2,3\\}\\), \\(B^\\prime = \\{\\mathbf{a}, \\mathbf{b}, \\mathbf{c}\\}\\), and define \\(f \\colon B \\to B^\\prime\\) and \\(g \\colon B^\\prime \\to B\\) by\n\\[ f(x) = \\begin{cases}\n  \\mathbf{a} & \\text{if $x = 1$} \\\\\n  \\mathbf{b} & \\text{if $x = 2$} \\\\\n  \\mathbf{c} & \\text{if $x = 3$}\n\\end{cases} \\]\n\\[ g(y) = \\begin{cases}\n  1 & \\text{if $y = \\mathbf{a}$} \\\\\n  2 & \\text{if $y = \\mathbf{b}$} \\\\\n  3 & \\text{if $y = \\mathbf{c}$}\n\\end{cases} \\]\nThen given \\(h \\colon B \\to C\\), we can produce \\(h^\\prime \\colon B^\\prime \\to C\\) via \\(h^\\prime = h \\circ g\\), and vice versa. Moreover, when we start out with a function out of \\(B\\), compose it with \\(g\\) to make a function out of \\(B^\\prime\\) and then compose it with \\(f\\) to make a function out of \\(B\\), we get the same function back.\nAll of this motivates the next few definitions.\nYou can remember the reasoning for why the name ‚Äúisomorphic‚Äù by thinking ‚Äúisomorphic = same morphisms‚Äù. That is, if we have an isomorphism between \\(A\\) and \\(A^\\prime\\), then there are ‚Äúthe same morphisms‚Äù out of \\(A\\) and out of \\(A\\prime\\).\nHowever, as noted before, there might be several distinct isomorphisms between \\(A\\) and \\(A^\\prime\\). Thus, one must be careful to specify which isomorphism when you are talking about isomorphic finite sets.\nAnyways, this is why it‚Äôs not a terrible problem to use a vector to represent a finite set. There are only rare cases where you can find a representation of your mathematical objects such that two representations are equal if and only if the mathematical objects are isomorphic. If you are lucky enough to find this, it‚Äôs called a ‚Äúcanonical form‚Äù and it‚Äôs a big deal. As a practical matter, we might use Set instead of Vector because it gets a bit closer to a canonical form, but I wanted to start with Vector to make the point that the representation of your mathematical object on a computer in general will not be canonical.\nWe now discuss some more properties of finite sets and their maps.\nThis is a good opportunity to discuss something very critical in math: ordering of quantifiers. Quantifiers are phrases like ‚Äúfor every ‚Ä¶‚Äù or ‚Äúthere exists ‚Ä¶‚Äù. In the previous definition, if we had instead said ‚Äúthere exists an \\(a \\in A\\) such that for every \\(b \\in B\\), \\(f(a) = b\\)‚Äù, this could only be true if \\(B\\) had only a single element! The fact that the ‚Äúthere exists‚Äù comes after the ‚Äúfor every‚Äù allows us to choose a different \\(a\\) for each \\(b\\).\nWe wrap up this section with a way of telling when there exists any isomorphisms between two finite sets.\nThe point of this first lecture is to introduce you to finite sets and pure math, not category theory. Therefore, we end with a discussion of a theorem from combinatorics."
  },
  {
    "objectID": "lecture2.html#takeaways",
    "href": "lecture2.html#takeaways",
    "title": "Lecture 2: The Category Theory of Finite Sets",
    "section": "Takeaways",
    "text": "Takeaways\n\nYou can compose morphisms between finite sets\nIsomorphisms tell you which finite sets are equivalent from the point of view of morphisms"
  },
  {
    "objectID": "lecture2.html#takeaways-1",
    "href": "lecture2.html#takeaways-1",
    "title": "Lecture 2: The Category Theory of Finite Sets",
    "section": "Takeaways",
    "text": "Takeaways\n\nThere are two special classes of functions: injections and surjections\nIf something is an injection and a surjection, it is an isomorphism\nYou can tell which finite sets are isomorphic by looking at their cardinalities"
  },
  {
    "objectID": "lecture2.html#takeaways-2",
    "href": "lecture2.html#takeaways-2",
    "title": "Lecture 2: The Category Theory of Finite Sets",
    "section": "Takeaways",
    "text": "Takeaways\n\nYou can do basic combinatorics in the framework we have developed in this lecture"
  },
  {
    "objectID": "lecture3.html",
    "href": "lecture3.html",
    "title": "Lecture 3: Category Theory",
    "section": "",
    "text": "Julia from last lecture\n\n\nabstract type ùîΩ end\n\nstruct VecùîΩ <: ùîΩ\n  elems::Vector{Any}\nend\n\nBase.:(‚àà)(a, A::VecùîΩ) = a ‚àà A.elems\n\nBase.iterate(A::VecùîΩ) = iterate(A.elems)\nBase.iterate(A::VecùîΩ, k) = iterate(A.elems, k)\nBase.length(A::VecùîΩ) = length(A.elems)\n\nstruct IntùîΩ <: ùîΩ\n  n::Int\nend\n\nBase.:(‚àà)(a, A::IntùîΩ) = 1 <= a <= A.n\n\nBase.iterate(A::IntùîΩ) = iterate(1:A.n)\nBase.iterate(A::IntùîΩ, k) = iterate(1:A.n, k)\n\nstruct ùîΩMor\n  dom::ùîΩ\n  codom::ùîΩ\n  vals::Dict{Any,Any}\nend\n\n(f::ùîΩMor)(x) = f.vals[x]\n\nstruct IntùîΩMor\n  dom::IntùîΩ\n  codom::IntùîΩ\n  vals::Vector{Int}\nend\n\n(f::IntùîΩMor)(i) = f.vals[i]\n\n\n\nSets\nToday we will be moving on from finite sets to talk about sets which are possibly infinite. Infinite sets are a controversial topic; they don‚Äôt exist as tangibly as finite sets, and generally are much trickier to compute with. For a mathematician, this is not a problem; they write down formulas for infinite sets in precisely the same way they wrote down formulas for finite sets.\nThe crucial difference between finite sets and infinite sets is that any ‚Äúfor all‚Äù statement on an infinite set is not checkable by listing out every element of the set and checking that a property holds of each of them. Relatedly, any ‚Äúexists‚Äù statement is likewise not checkable. This seems kind of obvious, but it means that naive extensions of algorithms from the case of finite sets to the case of infinite sets often fails.\nThus, on a computer infinite sets have a very different feel than finite sets.\nIn traditional foundations, everything is built out of sets. But, as we said in the previous lecture, this is unnecessarily strict. We are instead taking Julia to be our foundation, so that we will have primitive things that are not themselves sets. This is a much saner foundation, because while it might be technically possible to build, say, a real number out of sets, nobody really wants to do that.\n\nA set \\(X\\) consists of a function from Any to Bool, which may or either be written in Julia or defined mathematically. If \\(X(x) = \\mathbf{true}\\), we write \\(x \\in X\\), and if \\(X(x) = \\mathbf{false}\\) we write \\(x \\notin X\\).\n\nNote that when we write down Julia definitions involving sets, we are implicitly assuming that the functions are written in Julia. However, there are some sets that we will use whose functions cannot be written down in Julia, so take the Julia definitions with a grain of salt. If the function defining a set can be written in Julia, we say that set is computable, and otherwise the set is uncomputable.\nObviously, we can only model the computable sets in Julia, but the uncomputable sets are still useful for talking about Julia.\n\nabstract type ComputableSet end\n\n# We expect any subtype of ComputableSet to have in defined on it.\nBase.in(x, s::ComputableSet) = error(\"no specific definition found\")\n\n\nFor any finite set \\(A\\), let \\(\\chi_{A}\\) be defined by \\(\\chi_{A}(x) = \\mathbf{true}\\) if \\(x\\) is listed in \\(A\\) and \\(\\mathbf{false}\\) otherwise. Then \\(\\chi_{A}\\) is a set.\n\n\nAny Julia type T defines a set, via the function which checks whether a Julia value has that type.\n\n\nstruct FiniteSet <: ComputableSet\n  A::ùîΩ\nend\n\nBase.in(x, œá::FiniteSet) = x ‚àà œá.A\n\nstruct TypeSet <: ComputableSet\n  T::Type\nend\n\nBase.in(x, œá::TypeSet) = x isa œá.T\n\n\nGiven two sets \\(A\\) and \\(B\\), the set \\(A \\to B\\) consists of all Julia callables \\(f\\) such that \\(f(a) \\in B\\) for all \\(a \\in A\\). Note that\n\nNote that even if A and B are computable sets, there is no way to check in Julia that a given f is an element of \\(A \\to B\\) because this would involve iterating through possibly infinitely many elements of \\(A\\). Again, languages where this is not the case don‚Äôt have good ODE solvers.\n\nGiven two sets \\(X\\) and \\(Y\\), their intersection \\(X \\cap Y\\) is defined by\n\\[ (X \\cap Y)(x) = X(x) \\wedge Y(x) \\]\nTheir union \\(X \\cup Y\\) is defined by\n\\[ (X \\cup Y)(x) = X(x) \\vee Y(x) \\]\n\n\nstruct IntersectionSet\n  X::ComputableSet\n  Y::ComputableSet\nend\n\nBase.in(x, œá::IntersectionSet) = x ‚àà œá.X && x ‚àà œá.Y\n\nstruct UnionSet\n  X::ComputableSet\n  Y::ComputableSet\nend\n\nBase.in(x, œá::UnionSet) = x ‚àà œá.X || x ‚àà œá.Y\n\n\nGiven two sets \\(X\\) and \\(Y\\), their product \\(X \\times Y\\) is the set of tuples \\((x,y)\\) where \\(x \\in X\\) and \\(y \\in Y\\). That is, \\(z \\in X \\times Y\\) if and only if z isa Tuple, length(z) = 2, \\(z[1] \\in X\\) and \\(z[2] \\in Y\\).\n\n\nproduct(X,Y) = z -> (z isa Tuple) &&\n  length(z) == 2 && X(z[1]) && Y(z[2])\n\n\nWe leave it to the reader to give a mathematical definition for sum given the following definition in Julia\n\n\nstruct Left\n  val::Any\nend\n\nstruct Right\n  val::Any\nend\n\nsum(X,Y) = x ->\n  if x isa Left\n    X(x.val)\n  elseif x isa Right\n    Y(x.val)\n  else\n    false\n  end\n\nWe will now move on to categories. But I would like to make one brief point first, which is that there is no set of all sets. This is because not all sets correspond to Julia values, as we consider uncomputable sets to be sets. But there is a set of all computable sets.\n\n\nCategories\nThe moment we‚Äôve all be waiting for.\n\nA small category \\(C\\) consists of\n\na set \\(C_0\\) of objects\nfor every \\(x,y \\in C_0\\), a set \\(\\mathrm{Hom}_C(x,y)\\) of morphisms from \\(x\\) to \\(y\\)\nfor every \\(x,y,z \\in C_0\\), a composition function \\(\\circ \\colon \\mathrm{Hom}_C(y,z) \\times \\mathrm{Hom}_(x,y) \\to \\mathrm{Hom}(x,z)\\)\nfor every \\(x \\in C_0\\), an identity morphism \\(1_x \\in \\mathrm{Hom}_C(x,x)\\)\n\nsuch that\n\nfor all \\(x,y,z,w \\in C_0\\), \\(f \\in \\mathrm{Hom}_C(x,y)\\), \\(g \\in \\mathrm{Hom}_C(y,z)\\), \\(h \\in \\mathrm{Hom}_C(z,w)\\), \\[ h \\circ (g \\circ f) = (h \\circ g) \\circ f \\]\nfor all \\(x,y \\in C_0\\), \\(f \\in \\mathrm{Hom}_C(x,y)\\), \\[ 1_y \\circ f = f = f \\circ 1_x \\]\n\nThese two laws are called the associativity law and unitality law respectively.\n\n(Julia to be livecoded)\n\nThere is a category \\(\\mathsf{Fin}\\) where the objects are finite sets and the morphisms are morphisms of finite sets, as defined in the previous lecture.\n\n(Julia to be livecoded)\n\nThere is a category where the objects are natural numbers and a morphism from \\(n\\) to \\(m\\) is a \\(n \\times m\\) matrix. Composition of a \\(n \\times m\\) matrix and an \\(m \\times r\\) matrix is done by matrix multiplication.\n\n(Julia to be livecoded)\n\nA graph consists of a finite set of vertices, a finite set of edges, and a source and target map from vertices to edges. Given any graph, there is a ‚Äúfree category‚Äù on that graph, where the objects are vertices and the morphisms are paths.\n\n(Julia to be livecoded)"
  },
  {
    "objectID": "lecture4.html#review-in-kittenlab-syntax",
    "href": "lecture4.html#review-in-kittenlab-syntax",
    "title": "Lecture 4: Functors",
    "section": "Review in Kittenlab syntax",
    "text": "Review in Kittenlab syntax\nIn this lecture, we are finally going to start using the Kittenlab.jl library. We weren‚Äôt using Kittenlab up until now so that I could show you a variety of design tradeoffs, and so that you were learning concepts rather than a specific instantiation of those concepts, but now it becomes worth it to start building up a coherent library instead of starting from scratch every time.\nWe start by giving the Julia definition of category that we will be using now.\n\ninclude(\"../src/Categories.jl\")\nusing .Categories\n\nThis declares an abstract type for category\nabstract type Category{Ob, Hom} end\nalong with the following methods that should be implemented on any subtype of that abstract type.\n# Note: this is not executed; this is just to show expected type signatures\ndom(c::Category{Ob, Hom}, f::Hom)::Ob\ncodom(c::Category{Ob, Hom}, f::Hom)::Ob\ncompose(c::Category{Ob, Hom}, f::Hom, g::Hom)::Hom\nid(c::Category{Ob, Hom}, x::Ob)::Hom\nIn Kittenlab, we have chosen a ‚Äúmiddle path‚Äù between having everything be fully dynamic and trying to put as much as possible into the type system. We use the Julia type system to guide our implementations, to provide documentation, and to resolve dispatch, but we do not rely on it for correctness.\nIf C is a subtype of Category{Ob,Hom}, then we expect that the set of objects for any element of C to be a subset of Ob.\nMoreover, we expect the hom-set from x :: Ob to y :: Ob to be some subset of the elements f :: Hom with dom(c, f) == x and codom(c, f) == y.\nThis ‚Äúmiddle path‚Äù is fairly convenient, because often there is a good choice of the types Ob and Hom that makes the category fairly ergonomic to use, in that most or all of the elements of Ob are actually objects of the category, and the same for Hom. Additionally, having more specific types will allow Julia to produce more efficient code.\nWe use slightly different definitions for the category of finite sets, following these principles.\n\ninclude(\"../src/FinSets.jl\")\nusing .FinSets\n\nNamely, we declare\nconst FinSet = AbstractSet\n\nstruct FinFunction{S,T}\n  dom::FinSet{S}\n  codom::FinSet{T}\n  values::AbstractDict{S,T}\nend\nWe simplified our design hierarchy in one way (removing the abstract types), and complicated it in another way (adding type parameters); this is a more pragmatic and less flexible approach.\nWe now declare a category of finsets and finfunctions to go along with this:\nstruct FinSetC <: Category{FinSet, FinFunction}\nend\n\nCategories.dom(::FinSetC, f::FinFunction) = f.dom\n\nCategories.codom(::FinSetC, f::FinFunction) = f.codom\n\nfunction Categories.compose(\n  ::FinSetC,\n  f::FinFunction{S,T}, g::FinFunction{T,R}\n) where {S,T,R}\n  @assert f.codom == g.dom\n  FinFunction(f.dom, g.codom, Dict(x => g(f(x)) for x in f.dom))\nend\n\nfunction Categories.id(::FinSetC, X::FinSet{S}) where {S}\n  FinFunction{S,S}(X,X,Dict(x => x for x in X))\nend\nHopefully, at this point the new conventions that we are using should make sense, so we are going to move on to functors!"
  },
  {
    "objectID": "lecture4.html#functors",
    "href": "lecture4.html#functors",
    "title": "Lecture 4: Functors",
    "section": "Functors",
    "text": "Functors\nCategory theory is all about studying the objects of a category by studying the morphisms between them. So consequently, the study of functors (which are the morphisms between categories) is critical to the studying of categories!\n\nLet \\(\\mathsf{C}\\) and \\(\\mathsf{D}\\) be categories. A functor \\(F\\) from \\(\\mathsf{C}\\) to \\(\\mathsf{D}\\), often written \\(F \\colon \\mathsf{C} \\to \\mathsf{D}\\), consists of:\n\nA function \\(F_0 \\colon \\mathsf{C}_0 \\to \\mathsf{D}_0\\). If \\(x \\in \\mathsf{C}_0\\), we often write \\(F_0(x)\\) as \\(F(x)\\).\nFor every \\(x,y \\in \\mathsf{C}_0\\), a function \\(F_{x,y} \\colon \\mathrm{Hom}_{\\mathsf{C}}(x,y) \\to \\mathrm{Hom}_{\\mathsf{D}}(F(x),F(y))\\). If \\(f \\in \\mathrm{Hom}_{\\mathsf{C}}(x,y)\\), we often write \\(F_{x,y}(f)\\) as \\(F(f)\\).\n\nsuch that the following two laws hold:\n\nFor all \\(x \\in \\mathsf{C}_0\\), \\(1_{F(x)} = F(1_x)\\)\nFor all \\(x,y,z \\in \\mathsf{C}_0\\), \\(f \\colon x \\to y\\), \\(g \\colon y \\to z\\), \\(F(g \\circ f) = F(g) \\circ F(f)\\).\n\n\nWe implement this with the following Julia.\n\ninclude(\"../src/Functors.jl\")\nusing .Functors\n\nThe declaration of functor is the following.\nabstract type Functor{C<:Category, D<:Category} end\n\nfunction ob_map(F::Functor{C,D}, x::ObC)::ObD where\n    {ObC, ObD, C<:Category{ObC}, D<:Category{ObD}}\n  error(\"unimplemented\")\nend\n\nfunction hom_map(F::Functor{C,D}, f::HomC)::HomD where\n    {ObC, HomC, ObD, HomD, C<:Category{ObC, HomC}, D<:Category{ObD, HomD}}\n  error(\"unimplemented\")\nend\n \n# KittenC is the category of Julia-implemented categories and functors\n\nstruct KittenC <: Category{Category, Functor}\nend\n\nfunction Categories.dom(::KittenC, F::Functor{C,D})::C where {C,D}\n  error(\"unimplemented\")\nend\n\nfunction Categories.codom(::KittenC, F::Functor{C,D})::D where {C,D}\n  error(\"unimplemented\")\nend\nThere are some critical subtleties in this declaration.\nFirst of all, functor is an abstract type parameterized by the types of its domain and codomain categories. Crucially, it is not parameterized by the domain and codomain categories! In the case that these types are singletons, this is an academic distinction. But later on, we will have structs that are subtypes of Category that are not singletons, where there is dynamic data in the category, and then dom and codom will be meaningful. The reason we have the types of the categories in the abstract type for functor is that we can then extract the types of the objects and morphisms for each category.\nSecondly, we have declared a category KittenC of categories and functors. Technically speaking, this is the category of ‚Äúcategories and functors that are implemented in Julia‚Äù; we reserve the category \\(\\mathsf{Cat}\\) for the category of all (small) categories. But this category is not complete yet: we need to be able to compose functors and take identity functors!\nWe first handle this mathematically.\n\nGiven three categories \\(\\mathsf{C}\\), \\(\\mathsf{D}\\) and \\(\\mathsf{E}\\), along with two functors \\(F \\colon \\mathsf{C} \\to \\mathsf{D}\\) and \\(G \\colon \\mathsf{D} \\to \\mathsf{E}\\), there is a functor \\(G \\circ F \\colon \\mathsf{C} \\to \\mathsf{E}\\) defined in the following way.\n\nFor \\(x \\in \\mathsf{C}_0\\), \\((G \\circ F)(x) = G(F(x))\\)\nFor \\(x,y \\in \\mathsf{C}_0\\), \\(f \\colon x \\to y\\), \\((G \\circ F)(f) = G(F(f))\\)\n\nWe now show that \\(G \\circ F\\) preserves composition and identities. Suppose that \\(x \\in \\mathsf{C}_0\\). Then\n\\[(G \\circ F)(1_x) = G(F(1_x)) = G(1_{F(x)}) = 1_{G(F(x))} = 1_{(G \\circ F)(x)}\\]\nMoreover, if \\(x,y,z \\in \\mathsf{C}_0\\), and \\(r \\colon x \\to y\\) and \\(s \\colon y \\to z\\), then\n\\[(G \\circ F)(s \\circ r) = G(F(s \\circ r)) = G(F(s) \\circ F(r)) = G(F(s)) \\circ G(F(r)) = (G \\circ F)(s) \\circ (G \\circ F)(r)\\]\nWe are done.\n\n\nGiven any category \\(\\mathsf{C}\\), there is a functor \\(1_{\\mathsf{C}} \\colon \\mathsf{C} \\to \\mathsf{C}\\) defined in the following way.\n\nFor \\(x \\in \\mathsf{C}_0\\), \\(1_{\\mathsf{C}}(x) = x\\)\nFor \\(x,y \\in \\mathsf{C}_0\\), \\(f \\colon x \\to y\\), \\(1_{\\mathsf{C}}(f) = f\\)\n\nWe leave it to the reader to show that this preserves identities and compositions. This is really easy if you can just state what you have to prove, but it might be tricky to state what you have to prove! So that would be a good exercise.\n\nIn Julia, we represent this all with the following data structures.\nstruct ComposedFunctor{C<:Category,D<:Category,E<:Category} <: Functor{C,E}\n  F::Functor{C,D}\n  G::Functor{D,E}\nend\n\nob_map(FG::ComposedFunctor, x) = ob_map(FG.G, ob_map(FG.F, x))\nhom_map(FG::ComposedFunctor, f) = hom_map(FG.G, hom_map(FG.F, f))\n\nCategories.dom(c::KittenC, FG::ComposedFunctor) = dom(c, FG.F)\nCategories.codom(c::KittenC, FG::ComposedFunctor) = codom(c, FG.G)\n\nfunction Categories.compose(\n  c::KittenC,\n  F::Functor{C,D}, G::Functor{D,E}\n) where {C,D,E}\n  @assert codom(c, F) == dom(c, G)\n  ComposedFunctor{C,D,E}(F,G)\nend\n\nstruct IdFunctor{C<:Category}\n  c::C\nend\n\nob_map(I::IdFunctor, x) = x\nhom_map(I::IdFunctor, f) = f\n\nCategories.dom(::KittenC, F::IdFunctor) = F.c\nCategories.codom(::KittenC, F::IdFunctor) = F.c\n\nCategories.id(::KittenC, c::Category) = IdFunctor(c)"
  },
  {
    "objectID": "lecture4.html#examples-of-functors",
    "href": "lecture4.html#examples-of-functors",
    "title": "Lecture 4: Functors",
    "section": "Examples of Functors",
    "text": "Examples of Functors\nThis is the livecoding section! We are going to implement a functor between two categories. Unfortunately, this functor won‚Äôt be terribly interesting, because we haven‚Äôt met too many categories yet! But soon we will meet more categories, and we will be able to talk about many more functors.\nRecall from last lecture the category of matrices, \\(\\mathsf{Mat}\\), where the objects are natural numbers and a morphism from \\(n\\) to \\(m\\) is a \\(n \\times m\\) matrix. Composition is matrix multiplication!\nThere is a category \\(\\mathsf{Fin}\\) where the objects are natural numbers and a morphism from \\(n\\) to \\(m\\) is a function from \\(\\{1,\\ldots,n\\}\\) to \\(\\{1,\\ldots,m\\}\\).\nWe make a functor \\(F\\) from \\(\\mathsf{Fin}\\) to \\(\\mathsf{Mat}\\) that is the identity on objects, and sends a function \\(f \\colon \\{1,\\ldots,n\\} \\to \\{1,\\ldots,m\\}\\) to the \\(n \\times m\\) matrix that has a 1 at index \\((i, f(i))\\) for each \\(i \\in \\{1,\\ldots,n\\}\\), and 0s elsewhere.\nWe must show that \\(F\\) preserves composition and identites.\nWe start with identities. The identity function \\(1_n \\colon \\{1,\\ldots,n\\} \\to \\{1,\\ldots,n\\}\\) turns into the matrix with a \\(1\\) at index \\((i,i)\\) for every \\(i\\), and 0 elsewhere, which is the identity matrix.\nNow, fix \\(n,m,\\ell\\), let \\(f \\colon \\{1,\\ldots,n\\} \\to \\{1,\\ldots,m\\}\\) and \\(g \\colon \\{1,\\ldots,m\\} \\to \\{1,\\ldots,\\ell\\}\\), and let \\(A = F(f)\\) and \\(B = F(g)\\). Then fix \\(i,k\\) and consider the expression for matrix multiplication.\n\\[ (AB)_{ik} = \\sum_{j=1}^{m} A_{ij} B_{jk} \\]\nNote that \\(A_{ij} = 1\\) only when \\(f(i) = j\\), and \\(B_{jk} = 1\\) only when \\(g(j) = k\\). So the only way that both of them are non-zero for the same \\(j\\) is when \\(j = f(i)\\) and \\(k = g(j)\\), or in other words \\(k = (g \\circ f)(i)\\). We are done."
  },
  {
    "objectID": "lecture5.html#preorders",
    "href": "lecture5.html#preorders",
    "title": "Lecture 5: A Variety of Categories and Functors",
    "section": "Preorders",
    "text": "Preorders\n\nA preorder consists of\n\nA set \\(X\\)\nA function \\(\\leq \\colon X \\times X \\to \\{\\top, \\bot\\}\\) (which is how we write true and false in math)\n\nsuch that\n\nFor all \\(x \\in X\\), \\(x \\leq x\\)\nFor all \\(x,y,z \\in X\\), if \\(x \\leq y\\) and \\(y \\leq z\\), then \\(x \\leq z\\).\n\n\n\nabstract type Preorder{T} end\n\n# leq(p::Preorder{T}, x::T, y::T)::Bool\n\n\nLet \\(A\\) be a finite set. A subset of \\(A\\) is a finite set containing only elements of \\(A\\). Equivalently, a subset of \\(A\\) is a function \\(A \\to \\{\\top, \\bot\\}\\).\nThe set of subsets of \\(A\\) is a preorder, where \\(U \\leq V\\) if every element of \\(U\\) is an element of \\(V\\).\n\n\nfunction subsetof(U::FinSet{T}, A::FinSet{T}) where {T}\n  all(x ‚àà A for x in U)\nend\n\nstruct SubsetPreorder{T} <: Preorder{FinSet{T}}\n  A::FinSet{T}\nend\n\nfunction leq(p::SubsetPreorder{T}, U::FinSet{T}, V::FinSet{T}) where {T}\n  @assert subsetof(U,p.A)\n  @assert subsetof(V,p.B)\n  subsetof(U,V)\nend\n\n\nThe real numbers, \\(\\mathbb{R}\\), are a partially ordered set, using the standard ordering.\n\n\nstruct RealPreorder <: Preorder{Float64}\nend\n\nleq(::RealPreorder, x::Float64, y::Float64) = x <= y\n\n\nGiven any preorder \\((X,\\leq)\\), there is a category with objects \\(X\\) and\n\nPrecisely one morphism from \\(x\\) to \\(y\\) if \\(x \\leq y\\)\nNo morphisms from \\(x\\) to \\(y\\) if \\(x \\nleq y\\) (if \\(x\\) is not less than \\(y\\)).\n\n\nIn fact, we can take this as an alternative definition of preorder: a preorder is a category where there is either one or zero morphisms between any two objects. The idea is that a morphism from \\(x\\) to \\(y\\) ‚Äúwitnesses‚Äù the fact that \\(x \\leq y\\).\nWe express this with Julia.\n\nstruct PreorderMorphism{T,P<:Preorder{T}}\n  p::P\n  dom::T\n  codom::T\n  function PreorderMorphism(p::Preorder{T}, dom::T, codom::T) where {T}\n    # We can only create this morphism if dom ‚â§ codom\n    @assert leq(p, dom, codom)\n    new{T,typeof(p)}(p, dom, codom)\n  end\nend\n\nstruct PreorderAsCat{T,P<:Preorder{T}} <: Category{T,PreorderMorphism{T,P}}\n  p::P\nend\n\nCategories.dom(::PreorderAsCat{T,P}, f::PreorderMorphism{T,P}) where {T,P} = f.dom\nCategories.codom(::PreorderAsCat{T,P}, f::PreorderMorphism{T,P}) where {T,P} = f.codom\n\nCategories.id(c::PreorderAsCat{T,P}, x::T) where {T,P} = PreorderMorphism(c.p, x, x)\nCategories.compose(\n  c::PreorderAsCat{T,P},\n  f::PreorderMorphism{T,P},\n  g::PreorderMorphism{T,P}\n) where {T,P} = PreorderMorphism(c.p, f.dom, g.codom)\n\nLet us now determine what a functor between two preorders would be, if we understand those preorders as categories.\n\nA functor between preorders \\(X\\) and \\(Y\\) simply consists of a function \\(F \\colon X \\to Y\\) such that if \\(x \\leq x'\\) for \\(x,x' \\in X\\), then \\(F(x) \\leq F(x')\\).\n\n\nProof. If there is a morphism \\(f\\) from \\(x\\) to \\(y\\), then there must exist a morphism \\(F(f)\\) from \\(f(x)\\) to \\(f(y)\\). Moreover, \\(F\\) can send morphisms to only one place, so it must preserve composites and identities.\n\nWe call a functor between preorders an order-preserving map.\n\nThere is a category \\(\\mathsf{Preorder}\\) of where the objects are preorders and the morphisms are order-preserving maps.\n\nWe said that we can view preorders as categories. Let‚Äôs make this statement precise.\n\nIf \\(\\mathsf{C}\\) is a category, then a subcategory \\(\\mathsf{D}\\) of \\(\\mathsf{C}\\) consists of a subset \\(\\mathsf{D}_{0} \\subset \\mathsf{C}_{0}\\) of objects, and for each \\(x,y \\in \\mathsf{D}_{0}\\), a subset \\(\\mathrm{Hom}_{\\mathsf{D}}(x,y) \\subset \\mathrm{Hom}_{\\mathsf{C}}(x,y)\\) of morphisms, such that\n\nAll identities are in \\(\\mathsf{D}\\)\nThe composite of morphisms in \\(\\mathsf{D}\\) is again in \\(\\mathsf{D}\\)\n\nIf \\(\\mathsf{D}_{0} = \\mathsf{C}_{0}\\), we call \\(\\mathsf{D}\\) wide, and if \\(\\mathrm{Hom}_{D}(x,y) = \\mathrm{Hom}_{C}(x,y)\\) for all \\(x,y \\in \\mathsf{D}_{0}\\), we call \\(\\mathsf{D}\\) full. The only wide, full subcategory is \\(\\mathsf{C}\\) itself.\n\nWe now state the following proposition\n\n\\(\\mathsf{Preorder}\\) is a full subcategory of \\(\\mathsf{Cat}\\).\n\nNow is when something very subtle comes into play. We have two different definitions of preorder, which are in some sense equivalent, but the way we have stated definitions, one of these definitions would make the previous proposition true, and another of those definitions would make the previous proposition false. Specifically, if we say that a preorder is a category with the property that each hom-set is a singleton or empty, then the set of preorders is literally a subset of the set of (small) categories. However, if we say that a preorder is a set with a function to Bool, then this is not true! Concretely, it is not true that Preorder <: Category, it‚Äôs just that we can construct a category out of a preorder!\nIt is for this reason in category theory that we take a slightly generalized notion of ‚Äúsubobject‚Äù. Instead of using subset, where the elements of set \\(A\\) have to be contained in set \\(B\\), we just require there to be an injection from \\(A\\) to \\(B\\)! So we say that a subcategory of \\(\\mathsf{C}\\) is just another category \\(\\mathsf{D}\\) that has an injective functor into \\(\\mathsf{C}\\).\nThis follows from a more general principle that we should not distinguish between isomorphic objects. I.e., if we have an injective functor into \\(\\mathsf{C}\\), then \\(\\mathsf{D}\\) is isomorphic to the image of that functor, which is a literal subset of \\(\\mathsf{C}\\).\nNow that we have made this pedantic and subtle point, we will follow convention in category to ignore it, and say things like \\(\\mathsf{Preorder}\\) is a full subcategory of \\(\\mathsf{Cat}\\) without caring about the precise definition of preorder we have chosen.\nWith this out of the way, we now talk about a menagerie of functors. In category theory, often functors are described by what they do on objects, and their action on morphisms is inferred. This makes a good exercise for the reader; see if you can tell what the action on morphisms of each of the following functors is.\n\nThere is a functor \\(\\mathsf{Preorder} \\to \\mathsf{Cat}\\) that simply sends a preorder to that preorder viewed as a category, as we discussed before.\nThere is a functor \\(\\mathsf{Cat}\\) which sends a category \\(\\mathsf{C}\\) to the preorder with the objects of \\(\\mathsf{C}\\), and \\(x \\leq y\\) if and only if \\(\\mathrm{Hom}_{\\mathsf{C}}(x,y)\\) is non-empty.\nThere is a functor \\(\\mathsf{Preorder} \\to \\mathsf{Set}\\) which simply sends a preorder to its underlying set.\nThere is a functor \\(\\mathsf{Set} \\to \\mathsf{Preorder}\\) which sends a set \\(X\\) to the preorder with underlying set \\(X\\) where \\(x \\leq y\\) if and only if \\(x = y\\). Such a preorder is known as a discrete preorder.\nThere is a functor \\(\\mathsf{Set} \\to \\mathsf{Preorder}\\) which sends a set \\(X\\) to the preorder with underlying set \\(X\\) where \\(x \\leq y\\) always. Such a preorder is known as a codiscrete preorder.\n\nTo sum up, preorders are a special case of categories, where there is at most one morphism between any two objects. We now move on to another special case of categories."
  },
  {
    "objectID": "lecture5.html#monoids",
    "href": "lecture5.html#monoids",
    "title": "Lecture 5: A Variety of Categories and Functors",
    "section": "Monoids",
    "text": "Monoids\nPreorders are an ‚Äúextreme‚Äù example of categories, where there are lots of objects, but very few morphisms. The other extreme is monoids, where there is only one object, but plenty of morphisms. We start with the classical definition of morphism.\n\nA monoid is a set \\(M\\) along with a binary operation \\(\\ast \\colon M \\times M \\to M\\) and an element \\(e \\in M\\) such that:\n\nFor all \\(a,b,c \\in M\\), \\((a \\ast b) \\ast c = a \\ast (b \\ast c)\\)\nFor all \\(a \\in M\\), \\(a \\ast e = a = e \\ast a\\)\n\nWe call \\(e\\) the unit or identity element of the monoid, and \\(\\ast\\) the multiplication.\n\n\nabstract type Monoid{T} end\n\n# mul(m::Monoid{T}, x::T, y::T)::T\n# ident(m::Monoid{T})::T\n\n\nLet \\(A\\) be an alphabet, and let \\(A^{\\ast}\\) be the set of strings on that alphabet. For instance, if \\(A = \\{a,b,c\\}\\), then \\(A^{\\ast} = \\{[],[a],[b],[c],[aa],[ab],[ac],[ba],\\ldots\\}\\). Then if we define \\(\\ast\\) to be ``concatenation‚Äô‚Äô, i.e.¬†\\([ab] \\ast [cba] = [abcba]\\), and if we define \\(e = []\\), \\((A^{\\ast},\\ast,[])\\) is a monoid.\n\n\nstruct ConcatMonoid{T} <: Monoid{Vector{T}}\n  alphabet::Set{T}\nend\n\nfunction mul(m::ConcatMonoid{T}, xs::Vector{T}, ys::Vector{T}) where {T}\n  @assert all(x ‚àà m.alphabet for x in xs)\n  @assert all(y ‚àà m.alphabet for y in xs)\n  [xs; ys]\nend\nident(::ConcatMonoid{T}) where {T} = T[]\n\n\nAny of \\(\\mathbb{N},\\mathbb{Z},\\mathbb{Q},\\mathbb{R},\\mathbb{C}\\) with \\(+\\) or \\(\\cdot\\) is a monoid.\n\n\nThe set of \\(n \\times n\\) matrices with either matrix multiplication, element-wise multiplication, or element-wise addition is a monoid.\n\n\nThe set of subsets of some fixed set \\(A\\) with either intersection or union is a monoid. The unit of intersection is \\(A\\), and the unit of union is \\(\\emptyset\\).\n\n\nA monoid is precisely the same thing as a category with only a single object.\n\n\nProof. Suppose that \\(\\mathsf{C}\\) is a category with one object \\(x\\). Then \\(\\mathsf{Hom}_{\\mathsf{C}}(x,x)\\) is a monoid with multiplication \\(\\circ\\) and unit \\(1_x\\). Conversely, if \\(M\\) is a monoid, we can construct a category with one object \\(x\\), and \\(\\mathsf{Hom}_{\\mathsf{C}}(x,x) = M\\), with \\(\\circ = \\ast\\) and \\(1_x = e\\).\n\nMoreover, a functor between two monoids viewed as categories is a simply a function \\(F \\colon M \\to N\\) such that \\(F(a \\ast b) = F(a) \\ast F(b)\\), as the single object of the monoid has only one place to go!\nLet \\(\\mathsf{Mon}\\) be the category of monoids. Then there are a bunch of functors between \\(\\mathsf{Mon}\\) and our old familiar categories.\n\nThere is a functor \\(\\mathsf{Mon} \\to \\mathsf{Cat}\\) which sends a monoid to that monoid viewed as a category.\nThere is a functor \\(\\mathsf{Mon} \\to \\mathsf{Set}\\) which sends a monoid to its underlying set.\nThere is a functor \\(\\mathsf{Set} \\to \\mathsf{Mon}\\) which sends a set \\(A\\) to the monoid \\(A^{\\ast}\\) of strings on the alphabet \\(A\\)."
  },
  {
    "objectID": "lecture6.html#graphs",
    "href": "lecture6.html#graphs",
    "title": "Lecture 6: Path categories and functors as data structures",
    "section": "Graphs",
    "text": "Graphs\n\nA graph \\(G\\) consists of the following.\n\nA finite set \\(G(V)\\) of vertices\nA finite set \\(G(E)\\) of edges\nA function \\(G(\\mathrm{src}) \\colon G(E) \\to G(V)\\) called the source map\nA function \\(G(\\mathrm{tgt}) \\colon G(E) \\to G(V)\\) called the target map\n\n\nYou can think about this like a ‚Äúdatabase‚Äù with two tables, one table for edges and one table for vertices. The vertex table has only a primary key column, and the edge table has two foreign key columns in addition to a primary key column.\n\n\n\n\n\nA graph as a database\n\n\n\n\n\nArad to Bucharest\n\n\nFigure¬†1: Two illustrations of graphs. The first is a simple graph, translated into two ‚Äúdatabase tables‚Äù on the right as well. The second is a classic graph from computer science: major towns and cities in Romania. This graph is often used for search problems; finding the shortest path from Arad to Bucharest and for some reason is one of my favorite graphs.\n\n\nNotice that we allow multiple edges between a single pair of vertices, and also edges from a vertex to itself.\nIn Julia, we can represent this in the following way.\nstruct Graph\n  vertices::FinSet{Int}\n  edges::FinSet{Int}\n  src::FinFunction{Int,Int}\n  tgt::FinFunction{Int,Int}\nend\nNote that graphs seem somewhat similar to categories; vertices are analogous to objects and edges are analogous to morphisms. The important difference is that categories have composition and identities, and graphs don‚Äôt. There is, however, a way of building a category out of a graph, and that is the subject of the next section."
  },
  {
    "objectID": "lecture6.html#path-categories-and-functors-out-of-them",
    "href": "lecture6.html#path-categories-and-functors-out-of-them",
    "title": "Lecture 6: Path categories and functors as data structures",
    "section": "Path categories and functors out of them",
    "text": "Path categories and functors out of them\n\nIf \\(G\\) is a graph, then a path in \\(G\\) is a list \\(e_{1},\\ldots,e_{n}\\) of edges, such that \\(G(\\mathrm{tgt})(e_{i}) = G(\\mathrm{src})(e_{i+1})\\) for \\(i=1,\\ldots,n-1\\). We say that the path goes from \\(G(\\mathrm{src})(e_{1})\\) to \\(G(\\mathrm{tgt})(e_{n})\\).\n\n\nWe can make a path from Arad to Bucharest by going\nArad -> Sibiu -> Fagaras -> Bucharest\n\n\nIf \\(G\\) is a graph, then given a path \\(e_{1},\\ldots,e_{n}\\) from a vertex \\(a\\) to a vertex \\(b\\), and a path \\(e_{1}^{\\prime},\\ldots,e_{m}^{\\prime}\\) from \\(b\\) to another vertex \\(c\\), we can construct a path \\(e_{1},\\ldots,e_{n},e_{1}^{\\prime},\\ldots,e_{m}^{\\prime}\\) from \\(a\\) to \\(b\\).\n\nWhen you hear the word ‚Äúcompose‚Äù your eyes should light up and think ‚ÄúOh, is this a category?‚Äù And in this case, it is!\n\nFor any graph \\(G\\), there is a category \\(\\mathrm{Path}(G)\\), where the objects are vertices in \\(G\\) and a morphism from a vertex \\(a\\) to a vertex \\(b\\) is a path from \\(a\\) to \\(b\\) in \\(G\\). Composition is as it was in the proposition above, i.e.¬†list concatenation, and the identity on a vertex is simply the empty list.\n\nWhenever you see something that constructs something from another thing, you should think ‚Äúis this a functor‚Äù? And it turns out that \\(\\mathrm{Path}\\) is in fact a functor from the category of graphs to the category of categories. However, in order to write this down properly, we have to define the category of graphs, and we aren‚Äôt quite ready to do that yet (we will do it by the end of this lecture, though).\nThe category \\(\\mathrm{Path}(G)\\) has a special property. Namely, in order to define a functor \\(F\\) from \\(\\mathrm{Path}(G)\\) to a category \\(\\mathsf{C}\\), all you have to do is pick an object \\(F(v)\\) \\(\\mathsf{C}\\) for every vertex \\(v \\in G(V)\\), and then pick a morphism \\(F(e) \\colon F(G(\\mathrm{src})(e)) \\to F(G(\\mathrm{tgt})(e))\\) for every edge \\(e \\in G(E)\\).\nThen where do you send a path \\(e_{1},\\ldots,e_{n}\\)? Well, you just send it to the composite morphism \\(F(e_{n}) \\circ \\cdots \\circ F(e_{1})\\)! It turns out that any choice of the \\(F(e)\\) works for this; you get preservation of composition ‚Äúfor free‚Äù!\nSo it‚Äôs particularly easy to define a functor coming out of \\(\\mathrm{Path}(G)\\), and it‚Äôs also particularly easy to store such a functor: we just store an object for every vertex of \\(G\\) and a morphism for every edge.\nWe call a functor from \\(\\mathrm{Path}(G)\\) to \\(\\mathsf{Set}\\) an acset, pronounced to rhyme with ‚Äúhatchet‚Äù. Other terminology you might see (and the etymology for acset) is C-set or copresheaf. However, this can be confusing because sometimes the ‚ÄúC‚Äù in C-set refers to \\(\\mathrm{Path}(G)\\), but sometimes we just use C-set as a word. I like to use ‚Äúacset on schema C‚Äù instead of C-set, because then I can just say ‚Äúacset‚Äù without having to define C first. And copresheaf is just unnecessarily fancy. We say ‚Äúschema‚Äù here, because you can think of \\(\\mathsf{C} = \\mathrm{Path}(G)\\) as a ‚Äúdatabase schema‚Äù; we‚Äôll see more about this later.\nStrictly speaking, there‚Äôs more to an acset than what we just presented; the ‚Äúa‚Äù in acset stands for ‚Äúattributed‚Äù. But we will cover this later; functors from \\(\\mathrm{Path}(G)\\) to \\(\\mathsf{Set}\\) are a special case of acsets.\nWe will now look at some examples!"
  },
  {
    "objectID": "lecture6.html#graphs-1",
    "href": "lecture6.html#graphs-1",
    "title": "Lecture 6: Path categories and functors as data structures",
    "section": "Graphs",
    "text": "Graphs\nFirst of all, we can go meta and define graphs themselves this way!\nConsider the following graph \\(G\\).\n\n\n\nGraph schema\n\n\nWe let \\(\\mathsf{Gr} = \\mathrm{Path}(G)\\). Then an acset on \\(\\mathsf{Gr}\\) is a graph. Using graphs to define graphs is pretty trippy, but fortunately we can ‚Äúclose the loop‚Äù because our original definition of graph didn‚Äôt rely on any of this notation. Notice that we have been using the notation for a functor out of \\(\\mathsf{Gr}\\) all along however!"
  },
  {
    "objectID": "lecture6.html#petri-nets",
    "href": "lecture6.html#petri-nets",
    "title": "Lecture 6: Path categories and functors as data structures",
    "section": "Petri nets",
    "text": "Petri nets\nConsider the following graph \\(G\\).\n\n\n\nPetri net schema\n\n\nWe let \\(\\mathsf{Petri} = \\mathrm{Path}(G)\\). Then an acset on \\(\\mathsf{Petri}\\) is a petri net.\nExamples of Petri nets:\n\n\n\nSIR model\n\n\n\n\n\nLotka-Volterra model"
  },
  {
    "objectID": "lecture6.html#wiring-diagrams",
    "href": "lecture6.html#wiring-diagrams",
    "title": "Lecture 6: Path categories and functors as data structures",
    "section": "Wiring diagrams",
    "text": "Wiring diagrams\nConsider the following graph \\(G\\).\n\n\n\nDirected port graph schema\n\n\nWe let \\(\\mathsf{DPG} = \\mathrm{Path}(G)\\). Then an acset on \\(\\mathsf{DPG}\\) is a directed port graph.\n\n\n\nDirected port graph\n\n\nWiring diagrams are slightly more complicated, because they also allow incoming and outgoing wires. Wiring diagrams and directed port graphs can be used to model processes."
  },
  {
    "objectID": "lecture6.html#acsets-in-julia",
    "href": "lecture6.html#acsets-in-julia",
    "title": "Lecture 6: Path categories and functors as data structures",
    "section": "ACSets in Julia",
    "text": "ACSets in Julia\n(this part will be livecoded)"
  },
  {
    "objectID": "lecture6.html#sneak-peak-natural-transformations",
    "href": "lecture6.html#sneak-peak-natural-transformations",
    "title": "Lecture 6: Path categories and functors as data structures",
    "section": "Sneak peak: natural transformations",
    "text": "Sneak peak: natural transformations\nWe said before that there is a category of graphs. In this part, we will give a definition of a graph homomorphism that will make this precise. It turns out that this comes from a general definition of natural transformation, which can be defined at the level of functors and categories! However, we will only give a hint at what this is, and leave a full exploration of natural transformations to the next lecture.\n\nA graph homomorphism \\(\\alpha\\) from a graph \\(G\\) to a graph \\(H\\) consists of two maps\n\n\\(\\alpha_{V} \\colon G(V) \\to H(V)\\)\n\\(\\alpha_{E} \\colon G(E) \\to H(E)\\)\n\nsuch that \\(\\alpha_{V} \\circ G(\\mathrm{src}) = H(\\mathrm{src}) \\circ \\alpha_{E}\\) and \\(\\alpha_{V} \\circ G(\\mathrm{tgt}) = H(\\mathrm{tgt}) \\circ \\alpha_{E}\\).\nThis means that the graph homomorphism has to ‚Äúpreserve sources and targets‚Äù. Just like a functor has to send a morphism from \\(A\\) to \\(B\\) to a morphism from \\(F(A)\\) to \\(F(B)\\), a graph homomorphism has to send an edge from \\(a\\) to \\(b\\) to an edge from \\(\\alpha_V(a)\\) to \\(\\alpha_{V}(b)\\).\nThese conditions can be expressed equivalently as commutative diagrams. Basically, an commutative diagram is a way of writing an equation between composites of morphisms in a category. The equation is that when you compose the morphisms along any path in the diagram, you get the same result.\n\n\n\n\n\n\nIn a future lecture, we will see that these are specific instances of the so-called ‚Äúnaturality squares‚Äù for natural transformations.\n\n\n\n\nThree coloring graph\n\n\n\nA three-coloring of a graph \\(G\\) is a graph homomorphism from \\(G\\) into the graph above. It assigns each vertex of the graph to a color. Notice in a three-coloring, any two vertices connected by an edge must be assigned different colors, because there are no self-edges in the above graph."
  }
]