<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml" lang="en" xml:lang="en"><head>

<meta charset="utf-8">
<meta name="generator" content="quarto-1.2.269">

<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes">


<title>Kittenlab lecture notes - Lecture 9: Colimits</title>
<style>
code{white-space: pre-wrap;}
span.smallcaps{font-variant: small-caps;}
div.columns{display: flex; gap: min(4vw, 1.5em);}
div.column{flex: auto; overflow-x: auto;}
div.hanging-indent{margin-left: 1.5em; text-indent: -1.5em;}
ul.task-list{list-style: none;}
ul.task-list li input[type="checkbox"] {
  width: 0.8em;
  margin: 0 0.8em 0.2em -1.6em;
  vertical-align: middle;
}
pre > code.sourceCode { white-space: pre; position: relative; }
pre > code.sourceCode > span { display: inline-block; line-height: 1.25; }
pre > code.sourceCode > span:empty { height: 1.2em; }
.sourceCode { overflow: visible; }
code.sourceCode > span { color: inherit; text-decoration: inherit; }
div.sourceCode { margin: 1em 0; }
pre.sourceCode { margin: 0; }
@media screen {
div.sourceCode { overflow: auto; }
}
@media print {
pre > code.sourceCode { white-space: pre-wrap; }
pre > code.sourceCode > span { text-indent: -5em; padding-left: 5em; }
}
pre.numberSource code
  { counter-reset: source-line 0; }
pre.numberSource code > span
  { position: relative; left: -4em; counter-increment: source-line; }
pre.numberSource code > span > a:first-child::before
  { content: counter(source-line);
    position: relative; left: -1em; text-align: right; vertical-align: baseline;
    border: none; display: inline-block;
    -webkit-touch-callout: none; -webkit-user-select: none;
    -khtml-user-select: none; -moz-user-select: none;
    -ms-user-select: none; user-select: none;
    padding: 0 4px; width: 4em;
    color: #aaaaaa;
  }
pre.numberSource { margin-left: 3em; border-left: 1px solid #aaaaaa;  padding-left: 4px; }
div.sourceCode
  {   }
@media screen {
pre > code.sourceCode > span > a:first-child::before { text-decoration: underline; }
}
code span.al { color: #ff0000; font-weight: bold; } /* Alert */
code span.an { color: #60a0b0; font-weight: bold; font-style: italic; } /* Annotation */
code span.at { color: #7d9029; } /* Attribute */
code span.bn { color: #40a070; } /* BaseN */
code span.bu { color: #008000; } /* BuiltIn */
code span.cf { color: #007020; font-weight: bold; } /* ControlFlow */
code span.ch { color: #4070a0; } /* Char */
code span.cn { color: #880000; } /* Constant */
code span.co { color: #60a0b0; font-style: italic; } /* Comment */
code span.cv { color: #60a0b0; font-weight: bold; font-style: italic; } /* CommentVar */
code span.do { color: #ba2121; font-style: italic; } /* Documentation */
code span.dt { color: #902000; } /* DataType */
code span.dv { color: #40a070; } /* DecVal */
code span.er { color: #ff0000; font-weight: bold; } /* Error */
code span.ex { } /* Extension */
code span.fl { color: #40a070; } /* Float */
code span.fu { color: #06287e; } /* Function */
code span.im { color: #008000; font-weight: bold; } /* Import */
code span.in { color: #60a0b0; font-weight: bold; font-style: italic; } /* Information */
code span.kw { color: #007020; font-weight: bold; } /* Keyword */
code span.op { color: #666666; } /* Operator */
code span.ot { color: #007020; } /* Other */
code span.pp { color: #bc7a00; } /* Preprocessor */
code span.sc { color: #4070a0; } /* SpecialChar */
code span.ss { color: #bb6688; } /* SpecialString */
code span.st { color: #4070a0; } /* String */
code span.va { color: #19177c; } /* Variable */
code span.vs { color: #4070a0; } /* VerbatimString */
code span.wa { color: #60a0b0; font-weight: bold; font-style: italic; } /* Warning */
</style>


<script src="site_libs/quarto-nav/quarto-nav.js"></script>
<script src="site_libs/quarto-nav/headroom.min.js"></script>
<script src="site_libs/clipboard/clipboard.min.js"></script>
<script src="site_libs/quarto-search/autocomplete.umd.js"></script>
<script src="site_libs/quarto-search/fuse.min.js"></script>
<script src="site_libs/quarto-search/quarto-search.js"></script>
<meta name="quarto:offset" content="./">
<link href="./lecture10.html" rel="next">
<link href="./lecture8.html" rel="prev">
<script src="site_libs/quarto-html/quarto.js"></script>
<script src="site_libs/quarto-html/popper.min.js"></script>
<script src="site_libs/quarto-html/tippy.umd.min.js"></script>
<script src="site_libs/quarto-html/anchor.min.js"></script>
<link href="site_libs/quarto-html/tippy.css" rel="stylesheet">
<link href="site_libs/quarto-html/quarto-syntax-highlighting.css" rel="stylesheet" id="quarto-text-highlighting-styles">
<script src="site_libs/bootstrap/bootstrap.min.js"></script>
<link href="site_libs/bootstrap/bootstrap-icons.css" rel="stylesheet">
<link href="site_libs/bootstrap/bootstrap.min.css" rel="stylesheet" id="quarto-bootstrap" data-mode="light">
<script id="quarto-search-options" type="application/json">{
  "location": "sidebar",
  "copy-button": false,
  "collapse-after": 3,
  "panel-placement": "start",
  "type": "textbox",
  "limit": 20,
  "language": {
    "search-no-results-text": "No results",
    "search-matching-documents-text": "matching documents",
    "search-copy-link-title": "Copy link to search",
    "search-hide-matches-text": "Hide additional matches",
    "search-more-match-text": "more match in this document",
    "search-more-matches-text": "more matches in this document",
    "search-clear-button-title": "Clear",
    "search-detached-cancel-button-title": "Cancel",
    "search-submit-button-title": "Submit"
  }
}</script>

  <script src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-chtml-full.js" type="text/javascript"></script>

<link rel="stylesheet" href="main.css">
</head>

<body class="nav-sidebar floating">

<div id="quarto-search-results"></div>
  <header id="quarto-header" class="headroom fixed-top">
  <nav class="quarto-secondary-nav" data-bs-toggle="collapse" data-bs-target="#quarto-sidebar" aria-controls="quarto-sidebar" aria-expanded="false" aria-label="Toggle sidebar navigation" onclick="if (window.quartoToggleHeadroom) { window.quartoToggleHeadroom(); }">
    <div class="container-fluid d-flex justify-content-between">
      <h1 class="quarto-secondary-nav-title">Lecture 9: Colimits</h1>
      <button type="button" class="quarto-btn-toggle btn" aria-label="Show secondary navigation">
        <i class="bi bi-chevron-right"></i>
      </button>
    </div>
  </nav>
</header>
<!-- content -->
<div id="quarto-content" class="quarto-container page-columns page-rows-contents page-layout-article">
<!-- sidebar -->
  <nav id="quarto-sidebar" class="sidebar collapse sidebar-navigation floating overflow-auto">
    <div class="pt-lg-2 mt-2 text-left sidebar-header">
    <div class="sidebar-title mb-0 py-0">
      <a href="./">Kittenlab lecture notes</a> 
    </div>
      </div>
      <div class="mt-2 flex-shrink-0 align-items-center">
        <div class="sidebar-search">
        <div id="quarto-search" class="" title="Search"></div>
        </div>
      </div>
    <div class="sidebar-menu-container"> 
    <ul class="list-unstyled mt-1">
        <li class="sidebar-item">
  <div class="sidebar-item-container"> 
  <a href="./index.html" class="sidebar-item-text sidebar-link">Introduction</a>
  </div>
</li>
        <li class="sidebar-item">
  <div class="sidebar-item-container"> 
  <a href="./lecture1.html" class="sidebar-item-text sidebar-link">Lecture 1: Formal Math</a>
  </div>
</li>
        <li class="sidebar-item">
  <div class="sidebar-item-container"> 
  <a href="./lecture2.html" class="sidebar-item-text sidebar-link">Lecture 2: The Category Theory of Finite Sets</a>
  </div>
</li>
        <li class="sidebar-item">
  <div class="sidebar-item-container"> 
  <a href="./lecture3.html" class="sidebar-item-text sidebar-link">Lecture 3: Category Theory</a>
  </div>
</li>
        <li class="sidebar-item">
  <div class="sidebar-item-container"> 
  <a href="./lecture4.html" class="sidebar-item-text sidebar-link">Lecture 4: Functors</a>
  </div>
</li>
        <li class="sidebar-item">
  <div class="sidebar-item-container"> 
  <a href="./lecture5.html" class="sidebar-item-text sidebar-link">Lecture 5: A Variety of Categories and Functors</a>
  </div>
</li>
        <li class="sidebar-item">
  <div class="sidebar-item-container"> 
  <a href="./lecture6.html" class="sidebar-item-text sidebar-link">Lecture 6: Path categories and functors as data structures</a>
  </div>
</li>
        <li class="sidebar-item">
  <div class="sidebar-item-container"> 
  <a href="./lecture7.html" class="sidebar-item-text sidebar-link">Lecture 7: Natural Transformations</a>
  </div>
</li>
        <li class="sidebar-item">
  <div class="sidebar-item-container"> 
  <a href="./lecture8.html" class="sidebar-item-text sidebar-link">Lecture 8: Universal Mapping Properties</a>
  </div>
</li>
        <li class="sidebar-item">
  <div class="sidebar-item-container"> 
  <a href="./lecture9.html" class="sidebar-item-text sidebar-link active">Lecture 9: Colimits</a>
  </div>
</li>
        <li class="sidebar-item">
  <div class="sidebar-item-container"> 
  <a href="./lecture10.html" class="sidebar-item-text sidebar-link">Lecture 10: Applied Colimits</a>
  </div>
</li>
        <li class="sidebar-item">
  <div class="sidebar-item-container"> 
  <a href="./references.html" class="sidebar-item-text sidebar-link">References</a>
  </div>
</li>
    </ul>
    </div>
</nav>
<!-- margin-sidebar -->
    <div id="quarto-margin-sidebar" class="sidebar margin-sidebar">
        <nav id="TOC" role="doc-toc" class="toc-active">
    <h2 id="toc-title">Table of contents</h2>
   
  <ul>
  <li><a href="#colimits-as-gluing" id="toc-colimits-as-gluing" class="nav-link active" data-scroll-target="#colimits-as-gluing">Colimits as gluing</a></li>
  <li><a href="#pushouts" id="toc-pushouts" class="nav-link" data-scroll-target="#pushouts">Pushouts</a></li>
  </ul>
</nav>
    </div>
<!-- main -->
<main class="content" id="quarto-document-content">

<header id="title-block-header" class="quarto-title-block default">
<div class="quarto-title">
<h1 class="title d-none d-lg-block">Lecture 9: Colimits</h1>
</div>



<div class="quarto-title-meta">

    
  
    
  </div>
  

</header>

<div class="hidden">
<p>$$ </p>
<!-- Math: categories -->
<!-- Math: graphs -->
<p>$$</p>
</div>
<section id="colimits-as-gluing" class="level2">
<h2 class="anchored" data-anchor-id="colimits-as-gluing">Colimits as gluing</h2>
<p>The core idea behind colimits is that we take a bunch of objects in a category, take their “disjoint union” (i.e., their <span class="math inline">\(n\)</span>-ary coproduct), and then “glue” parts of those objects together.</p>
<p>So before we get into the category theory, let’s talk about exactly what that means.</p>
<p>We want to be able to “declare by fiat” that two elements of a set are actually the same element. How can we record this declaration mathematically?</p>
<p>We start out with a set <span class="math inline">\(X\)</span>. We then make a relation on <span class="math inline">\(X\)</span>, i.e.&nbsp;<span class="math inline">\(R \subset X \times X\)</span>, where <span class="math inline">\((x,x') \in X\)</span> if we are “declaring” that <span class="math inline">\(x\)</span> should be equal to <span class="math inline">\(x'\)</span>.</p>
<p>This relation should satisfy three properties.</p>
<ol type="1">
<li><span class="math inline">\((x,x) \in R\)</span> for all <span class="math inline">\(x\)</span></li>
<li>If <span class="math inline">\((x,y) \in R\)</span>, then <span class="math inline">\((y, x) \in R\)</span></li>
<li>If <span class="math inline">\((x,y) \in R\)</span> and <span class="math inline">\((y,z) \in R\)</span>, then <span class="math inline">\((x,z) \in R\)</span></li>
</ol>
<p>One way of saying this succinctly is that <span class="math inline">\((X,R)\)</span> is a preorder where all morphisms are invertible. This is called an <strong>equivalence relation</strong>.</p>
<p>We can then take the set of “connected components”, which we call <span class="math inline">\(X/R\)</span>. An element of <span class="math inline">\(X/R\)</span> is a subset <span class="math inline">\(U\)</span> of <span class="math inline">\(X\)</span> such that for all <span class="math inline">\(x,y \in U\)</span>, <span class="math inline">\((x,y) \in R\)</span>, and if <span class="math inline">\(x \in U\)</span> and <span class="math inline">\((x,y) \in R\)</span>, then <span class="math inline">\(y \in U\)</span>.</p>
<p>There is a very efficient data structure for storing an equivalence relation on the set <span class="math inline">\(\{1,\ldots,n\}\)</span>, called a <em>union find</em>.</p>
<p>We’re going to start with a more naive data structure, and then improve it to a union find.</p>
<p>The idea is that we choose a representative for each equivalence class, and we store the mapping from number to representative in an array. Two elements are in the same equivalence class if and only if their representatives are the same.</p>
<p>We start out with the equivalence classes <span class="math inline">\(\{\{1\},\ldots,\{n\}\}\)</span>, and thus each element is assigned itself as a representative.</p>
<div class="sourceCode" id="cb1"><pre class="sourceCode julia code-with-copy"><code class="sourceCode julia"><span id="cb1-1"><a href="#cb1-1" aria-hidden="true" tabindex="-1"></a><span class="kw">struct</span> RepStore</span>
<span id="cb1-2"><a href="#cb1-2" aria-hidden="true" tabindex="-1"></a>  representative<span class="op">::</span><span class="dt">Vector{Int}</span></span>
<span id="cb1-3"><a href="#cb1-3" aria-hidden="true" tabindex="-1"></a>  <span class="kw">function</span> <span class="fu">RepStore</span>(n<span class="op">::</span><span class="dt">Int</span>)</span>
<span id="cb1-4"><a href="#cb1-4" aria-hidden="true" tabindex="-1"></a>    <span class="fu">new</span>(<span class="fu">Vector</span><span class="dt">{Int}</span>(<span class="fl">1</span><span class="op">:</span>n))</span>
<span id="cb1-5"><a href="#cb1-5" aria-hidden="true" tabindex="-1"></a>  <span class="kw">end</span></span>
<span id="cb1-6"><a href="#cb1-6" aria-hidden="true" tabindex="-1"></a><span class="kw">end</span></span>
<span id="cb1-7"><a href="#cb1-7" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb1-8"><a href="#cb1-8" aria-hidden="true" tabindex="-1"></a><span class="fu">equivalent</span>(uf<span class="op">::</span><span class="dt">RepStore</span>, i<span class="op">::</span><span class="dt">Int</span>, j<span class="op">::</span><span class="dt">Int</span>) <span class="op">=</span> uf.representative[i] <span class="op">==</span> uf.representative[j]</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<p>We now want to be able to “declare by fiat” that two elements are equal. Naively, an algorithm for this would look something like the following.</p>
<div class="sourceCode" id="cb2"><pre class="sourceCode julia code-with-copy"><code class="sourceCode julia"><span id="cb2-1"><a href="#cb2-1" aria-hidden="true" tabindex="-1"></a><span class="kw">function</span> <span class="fu">union!</span>(uf<span class="op">::</span><span class="dt">RepStore</span>, i<span class="op">::</span><span class="dt">Int</span>, j<span class="op">::</span><span class="dt">Int</span>)</span>
<span id="cb2-2"><a href="#cb2-2" aria-hidden="true" tabindex="-1"></a>  irep, jrep <span class="op">=</span> uf.representative[i], uf.representative[j]</span>
<span id="cb2-3"><a href="#cb2-3" aria-hidden="true" tabindex="-1"></a>  <span class="cf">for</span> k <span class="kw">in</span> <span class="fl">1</span><span class="op">:</span><span class="fu">length</span>(uf.representative)</span>
<span id="cb2-4"><a href="#cb2-4" aria-hidden="true" tabindex="-1"></a>    <span class="cf">if</span> uf.representative[k] <span class="op">==</span> jrep</span>
<span id="cb2-5"><a href="#cb2-5" aria-hidden="true" tabindex="-1"></a>      uf.representative[k] <span class="op">=</span> irep</span>
<span id="cb2-6"><a href="#cb2-6" aria-hidden="true" tabindex="-1"></a>    <span class="cf">end</span></span>
<span id="cb2-7"><a href="#cb2-7" aria-hidden="true" tabindex="-1"></a>  <span class="cf">end</span></span>
<span id="cb2-8"><a href="#cb2-8" aria-hidden="true" tabindex="-1"></a><span class="kw">end</span></span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<p>This sets anything that previously had the same representative as <code>j</code> to now have the same representative as <code>i</code>.</p>
<p>But we can do better than this. Ideally, we would just write</p>
<div class="sourceCode" id="cb3"><pre class="sourceCode julia code-with-copy"><code class="sourceCode julia"><span id="cb3-1"><a href="#cb3-1" aria-hidden="true" tabindex="-1"></a><span class="kw">function</span> <span class="fu">union!</span>(uf<span class="op">::</span><span class="dt">RepStore</span>, i<span class="op">::</span><span class="dt">Int</span>, j<span class="op">::</span><span class="dt">Int</span>)</span>
<span id="cb3-2"><a href="#cb3-2" aria-hidden="true" tabindex="-1"></a>  irep, jrep <span class="op">=</span> uf.representative[i], uf.representative[j]</span>
<span id="cb3-3"><a href="#cb3-3" aria-hidden="true" tabindex="-1"></a>  uf.representative[jrep] <span class="op">=</span> irep</span>
<span id="cb3-4"><a href="#cb3-4" aria-hidden="true" tabindex="-1"></a><span class="kw">end</span></span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<p>This doesn’t quite work. In order to make it work, we use a different strategy for storing the representatives.</p>
<div class="sourceCode" id="cb4"><pre class="sourceCode julia code-with-copy"><code class="sourceCode julia"><span id="cb4-1"><a href="#cb4-1" aria-hidden="true" tabindex="-1"></a><span class="kw">struct</span> UnionFind</span>
<span id="cb4-2"><a href="#cb4-2" aria-hidden="true" tabindex="-1"></a>  parent<span class="op">::</span><span class="dt">Vector{Int}</span></span>
<span id="cb4-3"><a href="#cb4-3" aria-hidden="true" tabindex="-1"></a>  <span class="kw">function</span> <span class="fu">UnionFind</span>(n<span class="op">::</span><span class="dt">Int</span>)</span>
<span id="cb4-4"><a href="#cb4-4" aria-hidden="true" tabindex="-1"></a>    <span class="fu">new</span>(<span class="fu">Vector</span><span class="dt">{Int}</span>(<span class="fl">1</span><span class="op">:</span>n))</span>
<span id="cb4-5"><a href="#cb4-5" aria-hidden="true" tabindex="-1"></a>  <span class="kw">end</span></span>
<span id="cb4-6"><a href="#cb4-6" aria-hidden="true" tabindex="-1"></a><span class="kw">end</span></span>
<span id="cb4-7"><a href="#cb4-7" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb4-8"><a href="#cb4-8" aria-hidden="true" tabindex="-1"></a><span class="kw">function</span> <span class="fu">find_root</span>(uf<span class="op">::</span><span class="dt">UnionFind</span>, i<span class="op">::</span><span class="dt">Int</span>)</span>
<span id="cb4-9"><a href="#cb4-9" aria-hidden="true" tabindex="-1"></a>  parent <span class="op">=</span> uf.parent[i]</span>
<span id="cb4-10"><a href="#cb4-10" aria-hidden="true" tabindex="-1"></a>  <span class="cf">if</span> parent <span class="op">==</span> i</span>
<span id="cb4-11"><a href="#cb4-11" aria-hidden="true" tabindex="-1"></a>    i</span>
<span id="cb4-12"><a href="#cb4-12" aria-hidden="true" tabindex="-1"></a>  <span class="cf">else</span></span>
<span id="cb4-13"><a href="#cb4-13" aria-hidden="true" tabindex="-1"></a>    <span class="fu">find_root</span>(uf, parent)</span>
<span id="cb4-14"><a href="#cb4-14" aria-hidden="true" tabindex="-1"></a>  <span class="cf">end</span></span>
<span id="cb4-15"><a href="#cb4-15" aria-hidden="true" tabindex="-1"></a><span class="kw">end</span></span>
<span id="cb4-16"><a href="#cb4-16" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb4-17"><a href="#cb4-17" aria-hidden="true" tabindex="-1"></a><span class="kw">function</span> <span class="fu">union!</span>(uf<span class="op">::</span><span class="dt">UnionFind</span>, i<span class="op">::</span><span class="dt">Int</span>, j<span class="op">::</span><span class="dt">Int</span>)</span>
<span id="cb4-18"><a href="#cb4-18" aria-hidden="true" tabindex="-1"></a>  iroot, jroot <span class="op">=</span> <span class="fu">find_root</span>(uf, i), <span class="fu">find_root</span>(uf, j)</span>
<span id="cb4-19"><a href="#cb4-19" aria-hidden="true" tabindex="-1"></a>  uf.parent[jroot] <span class="op">=</span> iroot</span>
<span id="cb4-20"><a href="#cb4-20" aria-hidden="true" tabindex="-1"></a><span class="kw">end</span></span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<p>This implicitly stores the representative for each equivalence class via a chain of links. One way of thinking about this is that we are storing a <em>forest</em> of nodes, and we can check if two nodes are in the same tree by following the links up to the root and checking if the root is the same for each.</p>
<p>There are then several optimizations that we can make then in order to make this run even faster, which we won’t get into now, but once we have done that <code>find_root</code> and <code>union!</code> both run in essentially constant time.</p>
<p>So this gives us a good way of “declaring by fiat” that two elements of a set are equal: we just run <code>merge!</code> on them.</p>
<p>Let’s now use this to make an implementation of the categorical operation of <em>pushout</em>.</p>
</section>
<section id="pushouts" class="level2">
<h2 class="anchored" data-anchor-id="pushouts">Pushouts</h2>
<p>A <em>pushout</em> is a type of colimit, and understanding how pushouts work will generalize well to understanding of general colimits.</p>
<div class="rmenv" title="Definition">
<p>Suppose we have the following diagram in a category <span class="math inline">\(\mathsf{C}\)</span></p>
<div class="tikzcd">
<img src="8b50c5d7e06b858bd742256352810ed9d87202b0.svg" class="img-fluid">
</div>
<p>Then the <strong>pushout</strong> of this diagram is given by another object <span class="math inline">\(X +_{Z} Y \in \mathsf{C}\)</span> along with maps <span class="math inline">\(\iota_{X}\)</span>, <span class="math inline">\(\iota_{Y}\)</span> and <span class="math inline">\(\iota_{Z}\)</span> that make the following commute</p>
<div class="tikzcd">
<img src="59ab570a5743d4cc726153fa49339c9fc642b6a9.svg" class="img-fluid">
</div>
<p>such that for any <span class="math inline">\(W\)</span> with <span class="math inline">\(\iota_{X}'\)</span>, <span class="math inline">\(\iota_{Y}'\)</span> <span class="math inline">\(\iota_{Z}'\)</span> similar, there exists a unique map <span class="math inline">\(p_{W} \colon X +_{Z} Y \to W\)</span> such that the following commutes.</p>
<div class="tikzcd">
<img src="cf064fcc56f36ef878d613ca4a91d6f0923edf0b.svg" class="img-fluid">
</div>
<p>(there should also be <span class="math inline">\(\iota_{Z}\)</span> and <span class="math inline">\(\iota_{Z}'\)</span>, but it’s hard to fit them in that diagram).</p>
</div>
<p>The way we think about this is that <span class="math inline">\(X +_{Z} Y\)</span> is the coproduct of <span class="math inline">\(X\)</span> and <span class="math inline">\(Y\)</span>, but with the image of <span class="math inline">\(Z\)</span> in <span class="math inline">\(X\)</span> “equalized by fiat” with the image of <span class="math inline">\(Z\)</span> in <span class="math inline">\(Y\)</span>.</p>
<div class="rmenv" title="Example">
<p>In <span class="math inline">\(\mathsf{Set}\)</span>, the pushout of the diagram</p>
<div class="tikzcd">
<img src="8b50c5d7e06b858bd742256352810ed9d87202b0.svg" class="img-fluid">
</div>
<p>is <span class="math inline">\(X + Y/\sim\)</span>, where <span class="math inline">\(\sim\)</span> is the equivalence relation generated by <span class="math inline">\(f(z) \sim g(z)\)</span> for all <span class="math inline">\(z \in Z\)</span>.</p>
<p>We compute this with</p>
<div class="sourceCode" id="cb5"><pre class="sourceCode julia code-with-copy"><code class="sourceCode julia"><span id="cb5-1"><a href="#cb5-1" aria-hidden="true" tabindex="-1"></a><span class="kw">function</span> <span class="fu">pushout</span>(f<span class="op">::</span><span class="dt">FinFunction</span>, g<span class="op">::</span><span class="dt">FinFunction</span>)</span>
<span id="cb5-2"><a href="#cb5-2" aria-hidden="true" tabindex="-1"></a>  <span class="pp">@assert</span> <span class="fu">dom</span>(f) <span class="op">==</span> <span class="fu">dom</span>(g)</span>
<span id="cb5-3"><a href="#cb5-3" aria-hidden="true" tabindex="-1"></a>  n <span class="op">=</span> <span class="fu">length</span>(<span class="fu">codom</span>(f))</span>
<span id="cb5-4"><a href="#cb5-4" aria-hidden="true" tabindex="-1"></a>  m <span class="op">=</span> <span class="fu">length</span>(<span class="fu">codom</span>(g))</span>
<span id="cb5-5"><a href="#cb5-5" aria-hidden="true" tabindex="-1"></a>  po <span class="op">=</span> <span class="fu">UnionFind</span>(n <span class="op">+</span> m)</span>
<span id="cb5-6"><a href="#cb5-6" aria-hidden="true" tabindex="-1"></a>  <span class="cf">for</span> z <span class="kw">in</span> <span class="fu">dom</span>(f)</span>
<span id="cb5-7"><a href="#cb5-7" aria-hidden="true" tabindex="-1"></a>    <span class="fu">union!</span>(po, <span class="fu">f</span>(z), n <span class="op">+</span> <span class="fu">g</span>(z))</span>
<span id="cb5-8"><a href="#cb5-8" aria-hidden="true" tabindex="-1"></a>  <span class="cf">end</span></span>
<span id="cb5-9"><a href="#cb5-9" aria-hidden="true" tabindex="-1"></a>  roots <span class="op">=</span> <span class="fu">unique!</span>([<span class="fu">find_root</span>(res, i) for i <span class="kw">in</span> <span class="fl">1</span><span class="op">:</span><span class="fu">length</span>(po)])</span>
<span id="cb5-10"><a href="#cb5-10" aria-hidden="true" tabindex="-1"></a>  (<span class="fu">Set</span>(roots),</span>
<span id="cb5-11"><a href="#cb5-11" aria-hidden="true" tabindex="-1"></a>   <span class="fu">Dict</span>(i <span class="op">=&gt;</span> <span class="fu">find_root</span>(res, <span class="fu">f</span>(i)) <span class="cf">for</span> i <span class="kw">in</span> <span class="fl">1</span><span class="op">:</span>n),</span>
<span id="cb5-12"><a href="#cb5-12" aria-hidden="true" tabindex="-1"></a>   <span class="fu">Dict</span>(i <span class="op">=&gt;</span> <span class="fu">find_root</span>(res, <span class="fu">g</span>(i) <span class="op">+</span> n) <span class="cf">for</span> i <span class="kw">in</span> <span class="fl">1</span><span class="op">:</span>m),</span>
<span id="cb5-13"><a href="#cb5-13" aria-hidden="true" tabindex="-1"></a>   )</span>
<span id="cb5-14"><a href="#cb5-14" aria-hidden="true" tabindex="-1"></a><span class="cf">end</span></span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<p>Why is this a pushout? Well, given another set <span class="math inline">\(W\)</span> with maps in from <span class="math inline">\(X\)</span>, <span class="math inline">\(Y\)</span> and <span class="math inline">\(Z\)</span> that commute, we can figure out where to send each equivalence class in <span class="math inline">\(X+Y/\sim\)</span>, because by the commutation property, all elements of each equivalence class have to go to the same element of <span class="math inline">\(W\)</span>.</p>
</div>
<p>We can do the exact same thing for graphs. We can take two graphs, take their coproduct, and then “glue” some of their edges and vertices together, according to maps out of a third graph.</p>
<p>Now, recall in the last lecture that we characterized coproducts as representatives of certain functors. We can do the exact same thing here, but we have to describe the functor that it’s representing in a special way.</p>
<p>Let <span class="math inline">\(\mathsf{D}\)</span> be the category presented by the graph</p>
<div class="tikzcd">
<img src="bc7dc8055741041b159e288d51caa10635c03c38.svg" class="img-fluid">
</div>
<p>Then the “setup” for a pushout is a functor <span class="math inline">\(F \colon \mathsf{D} \to \mathsf{C}\)</span>.</p>
<div class="rmenv" title="Proposition">
<p>The pushout of <span class="math inline">\(F \colon \mathsf{D} \to \mathsf{C}\)</span> is a representing object for <span class="math inline">\(\operatorname{Hom}_{\mathsf{C}^{\mathsf{D}}}(F, \Delta(-))\)</span>, where <span class="math inline">\(\Delta \colon \mathsf{C}\to \mathsf{C}^{\mathsf{D}}\)</span> sends an object <span class="math inline">\(X\)</span> to the constant functor at <span class="math inline">\(X\)</span>.</p>
</div>
<div class="proof">
<p><span class="proof-title"><em>Proof</em>. </span>An element of <span class="math inline">\(\operatorname{Hom}_{\mathsf{C}^{\mathsf{D}}}(F, \Delta(W))\)</span> is a natural transformation <span class="math inline">\(\alpha\)</span> from <span class="math inline">\(F\)</span> to <span class="math inline">\(\Delta(W)\)</span>. Remember, a natural transformation consists of a <em>morphism</em> in <span class="math inline">\(\mathsf{C}\)</span> for every <em>object</em> in <span class="math inline">\(\mathsf{D}\)</span>, so in this case we have three morphisms. Then the naturality condition implies that the diagram</p>
<div class="tikzcd">
<img src="48c89f3df797cbdb6fdc7a02664fb8e32d87f7f8.svg" class="img-fluid">
</div>
<p>commutes.</p>
<p>A representative of <span class="math inline">\(\operatorname{Hom}_{\mathsf{C}^{\mathsf{D}}}(F, \Delta(-))\)</span> is an object <span class="math inline">\(\varprojlim F \in \mathsf{C}\)</span> such that <span class="math inline">\(\operatorname{Hom}_{\mathsf{C}}(\varprojlim F, W) \cong \operatorname{Hom}_{\mathsf{C}^{\mathsf{D}}}(F, \Delta(W))\)</span>. We can show that such an object satisfies the earlier definition of pushout by passing in the identity on <span class="math inline">\(\varprojlim F\)</span> into the right hand side, to get a map <span class="math inline">\(\operatorname{Hom}_{\mathsf{C}^{\mathsf{D}}}(F, \Delta(\varprojlim F))\)</span> that gives the diagram in the definition. And then the naturality of the isomorphism gives us the factorization property. The converse can be proved similarly.</p>
</div>
<p>This gives us a hint on how to do general colimits.</p>
<div class="rmenv" title="Definition">
<p>Given two categories <span class="math inline">\(\mathsf{D}\)</span> and <span class="math inline">\(\mathsf{C}\)</span>, and a functor <span class="math inline">\(F \colon \mathsf{D} \to \mathsf{C}\)</span>, the colimit <span class="math inline">\(\varprojlim F\)</span> is the representing object for <span class="math inline">\(\operatorname{Hom}_{\mathsf{C}^{\mathsf{D}}}(F, \Delta(-))\)</span> (if such an object exists).</p>
</div>
<div class="rmenv" title="Example">
<p>If <span class="math inline">\(\mathsf{D}\)</span> is the discrete category with two objects, then we just get coproducts again. More generally, we can do <span class="math inline">\(n\)</span>-ary coproducts by making <span class="math inline">\(\mathsf{D}\)</span> the discrete category with <span class="math inline">\(n\)</span> objects.</p>
</div>
<div class="rmenv" title="Example">
<p>If <span class="math inline">\(\mathsf{D}\)</span> is the <em>empty</em> category, what do we get? Well <span class="math inline">\(\operatorname{Hom}_{\mathsf{C}^{\mathsf{D}}}(F, \Delta(-))\)</span> is always a singleton, if <span class="math inline">\(F\)</span> is the unique functor from <span class="math inline">\(\mathsf{D}\)</span> to <span class="math inline">\(\mathsf{C}\)</span>. So we are looking for an object <span class="math inline">\(X \in C\)</span> such that <span class="math inline">\(\operatorname{Hom}(X,Y)\)</span> is a singleton for all <span class="math inline">\(Y\)</span>.</p>
<p>In <span class="math inline">\(\mathsf{Set}\)</span>, this is the empty set. More generally, this is called an <strong>initial object</strong>.</p>
</div>
<div class="rmenv" title="Example">
<p>If <span class="math inline">\(\mathsf{D}\)</span> is a category that looks like this:</p>
<div class="tikzcd">
<img src="63bd5bf3fae0371c03c473328cb1559c8cc7debc.svg" class="img-fluid">
</div>
<p>then the colimit of a functor <span class="math inline">\(F \colon \mathsf{D} \to \mathsf{C}\)</span> is called a <em>coequalizer</em>.</p>
<p>Category theory is the subject where the examples have examples: let’s give an example of a coequalizer. Suppose that <span class="math inline">\(\mathsf{C}\)</span> is the category of abelian groups, and we have the diagram</p>
<div class="tikzcd">
<img src="a0b9bce74650ddae6c8dfa6a5f13d3e089047109.svg" class="img-fluid">
</div>
<p>where <span class="math inline">\(H\)</span> is a subgroup of <span class="math inline">\(G\)</span>, <span class="math inline">\(f\)</span> is the inclusion, and <span class="math inline">\(0\)</span> is the constant map at the identity. Then the coequalizer of that diagram is <span class="math inline">\(G/H\)</span>, the quotient group. This is the group that results from “declaring by fiat” every element of <span class="math inline">\(H\)</span> to be <span class="math inline">\(0\)</span>.</p>
</div>
<p>Colimits are a rich subject which we will no doubt return to over and over again, but that will be it for today!</p>


</section>

</main> <!-- /main -->
<script id="quarto-html-after-body" type="application/javascript">
window.document.addEventListener("DOMContentLoaded", function (event) {
  const toggleBodyColorMode = (bsSheetEl) => {
    const mode = bsSheetEl.getAttribute("data-mode");
    const bodyEl = window.document.querySelector("body");
    if (mode === "dark") {
      bodyEl.classList.add("quarto-dark");
      bodyEl.classList.remove("quarto-light");
    } else {
      bodyEl.classList.add("quarto-light");
      bodyEl.classList.remove("quarto-dark");
    }
  }
  const toggleBodyColorPrimary = () => {
    const bsSheetEl = window.document.querySelector("link#quarto-bootstrap");
    if (bsSheetEl) {
      toggleBodyColorMode(bsSheetEl);
    }
  }
  toggleBodyColorPrimary();  
  const icon = "";
  const anchorJS = new window.AnchorJS();
  anchorJS.options = {
    placement: 'right',
    icon: icon
  };
  anchorJS.add('.anchored');
  const clipboard = new window.ClipboardJS('.code-copy-button', {
    target: function(trigger) {
      return trigger.previousElementSibling;
    }
  });
  clipboard.on('success', function(e) {
    // button target
    const button = e.trigger;
    // don't keep focus
    button.blur();
    // flash "checked"
    button.classList.add('code-copy-button-checked');
    var currentTitle = button.getAttribute("title");
    button.setAttribute("title", "Copied!");
    let tooltip;
    if (window.bootstrap) {
      button.setAttribute("data-bs-toggle", "tooltip");
      button.setAttribute("data-bs-placement", "left");
      button.setAttribute("data-bs-title", "Copied!");
      tooltip = new bootstrap.Tooltip(button, 
        { trigger: "manual", 
          customClass: "code-copy-button-tooltip",
          offset: [0, -8]});
      tooltip.show();    
    }
    setTimeout(function() {
      if (tooltip) {
        tooltip.hide();
        button.removeAttribute("data-bs-title");
        button.removeAttribute("data-bs-toggle");
        button.removeAttribute("data-bs-placement");
      }
      button.setAttribute("title", currentTitle);
      button.classList.remove('code-copy-button-checked');
    }, 1000);
    // clear code selection
    e.clearSelection();
  });
  function tippyHover(el, contentFn) {
    const config = {
      allowHTML: true,
      content: contentFn,
      maxWidth: 500,
      delay: 100,
      arrow: false,
      appendTo: function(el) {
          return el.parentElement;
      },
      interactive: true,
      interactiveBorder: 10,
      theme: 'quarto',
      placement: 'bottom-start'
    };
    window.tippy(el, config); 
  }
  const noterefs = window.document.querySelectorAll('a[role="doc-noteref"]');
  for (var i=0; i<noterefs.length; i++) {
    const ref = noterefs[i];
    tippyHover(ref, function() {
      // use id or data attribute instead here
      let href = ref.getAttribute('data-footnote-href') || ref.getAttribute('href');
      try { href = new URL(href).hash; } catch {}
      const id = href.replace(/^#\/?/, "");
      const note = window.document.getElementById(id);
      return note.innerHTML;
    });
  }
  const findCites = (el) => {
    const parentEl = el.parentElement;
    if (parentEl) {
      const cites = parentEl.dataset.cites;
      if (cites) {
        return {
          el,
          cites: cites.split(' ')
        };
      } else {
        return findCites(el.parentElement)
      }
    } else {
      return undefined;
    }
  };
  var bibliorefs = window.document.querySelectorAll('a[role="doc-biblioref"]');
  for (var i=0; i<bibliorefs.length; i++) {
    const ref = bibliorefs[i];
    const citeInfo = findCites(ref);
    if (citeInfo) {
      tippyHover(citeInfo.el, function() {
        var popup = window.document.createElement('div');
        citeInfo.cites.forEach(function(cite) {
          var citeDiv = window.document.createElement('div');
          citeDiv.classList.add('hanging-indent');
          citeDiv.classList.add('csl-entry');
          var biblioDiv = window.document.getElementById('ref-' + cite);
          if (biblioDiv) {
            citeDiv.innerHTML = biblioDiv.innerHTML;
          }
          popup.appendChild(citeDiv);
        });
        return popup.innerHTML;
      });
    }
  }
});
</script>
<nav class="page-navigation">
  <div class="nav-page nav-page-previous">
      <a href="./lecture8.html" class="pagination-link">
        <i class="bi bi-arrow-left-short"></i> <span class="nav-page-text">Lecture 8: Universal Mapping Properties</span>
      </a>          
  </div>
  <div class="nav-page nav-page-next">
      <a href="./lecture10.html" class="pagination-link">
        <span class="nav-page-text">Lecture 10: Applied Colimits</span> <i class="bi bi-arrow-right-short"></i>
      </a>
  </div>
</nav>
</div> <!-- /content -->



</body></html>